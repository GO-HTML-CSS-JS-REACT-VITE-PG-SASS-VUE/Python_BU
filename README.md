﻿123

```
Слайд 1: Теория — Переменные и арифметические действия
Что такое переменная?
Представьте себе коробку с названием. Вы можете положить 
в нее любое значение (число, текст и т.д.), а потом обращаться 
к нему по имени коробки. В программировании 
эта «коробка» называется переменной.
Имя переменной — это метка на коробке (например, age, price).
Значение переменной — это то, что лежит внутри (например, 25, 19.99).
Основные арифметические операции в Python:
Оператор	Операция	Пример
+	Сложение	5 + 2
-	Вычитание	5 - 2
*	Умножение	5 * 2
**	Возведение в степень	5 ** 2 (это 5²)
/	Деление	5 / 2 (результат 2.5)
//	Целочисленное деление	5 // 2 (результат 2)
%	Остаток от деления	5 % 2 (результат 1)
```
Слайд 2: Пример 1 — Простой калькулятор
Задача: Рассчитать общую стоимость покупки нескольких товаров.
```python
# 1. Создаем переменные и присваиваем им значения
price_per_kg = 350  # Цена за килограмм в рублях
weight = 2.5        # Вес в килограммах
# 2. Производим арифметическое действие (умножение)
total_price = price_per_kg * weight
# 3. Выводим результат на экран
print("Общая стоимость покупки:", total_price, "рублей")
```
Вывод в консоли:
```bash
Общая стоимость покупки: 875.0 рублей
Что произошло?
Мы «положили» в переменную price_per_kg число 350.
В переменную weight — число 2.5.
Создали новую переменную total_price, значением которой 
стал результат умножения двух предыдущих переменных.
Функция print() отобразила итог.
```
Слайд 3: Пример 2 — Конвертер температур и работа с разными операциями
Задача: Перевести температуру из градусов Фаренгейта в градусы Цельсия и вывести оба значения.
```python
# 1. Исходные данные: температура в Фаренгейтах
temp_fahrenheit = 98.6
# 2. Вычисляем температуру в Цельсиях по формуле
# Формула: (F - 32) * 5 / 9
temp_celsius = (temp_fahrenheit - 32) * 5 / 9
# 3. Округляем результат до одного знака после запятой для красоты
temp_celsius_rounded = round(temp_celsius, 1)
# 4. Выводим итоговый результат
print("Температура в Фаренгейтах:", temp_fahrenheit, "F")
print("Температура в Цельсиях:", temp_celsius_rounded, "C")
```
Вывод в консоли:
```bash
Температура в Фаренгейтах: 98.6 F
Температура в Цельсиях: 37.0 C
```
```
Что произошло?
В одном выражении (temp_fahrenheit - 32) * 5 / 9 
мы использовали сразу три арифметические операции: вычитание, умножение и деление. 
Python вычисляет их в правильном порядке (сначала в скобках).
Мы познакомились с функцией round(), которая округляет число до указанного количества знаков после запятой.
Этот пример показывает, как переменные помогают разбить сложную задачу на простые шаги.
Итог для презентации: Переменные позволяют хранить данные, 
а арифметические операции — манипулировать этими данными для получения новых результатов. 
Это основа любого вычисления в программировании.
Простые типы данных.
Слайд 1: Теория — Простые типы данных
Что такое тип данных?
Тип данных определяет:
Какой вид информации хранится в переменной
Какие операции можно с ней выполнять
Сколько памяти она занимает
Основные простые (встроенные) типы в Python:
int (целое число) — целые числа без дробной части
Пример: -5, 0, 42, 1000
float (число с плавающей точкой) — дробные числа
Пример: 3.14, -0.001, 2.0
str (строка) — текстовая информация
Обязательно заключаются в кавычки: "Hello", 'Python'
bool (логический тип) — имеет только два значения
True (истина) / False (ложь)
```
Слайд 2: Пример 1 — Определение типов и базовые операции
Задача: Продемонстрировать разные типы данных и операции с ними.
```python
# Демонстрация разных типов данных
age = 25                   # int - целое число
temperature = 36.6         # float - дробное число
name = "Анна"              # str - строка (текст)
is_student = True          # bool - логическое значение
# Выводим типы этих переменных с помощью функции type()
print("Тип age:", type(age))
print("Тип temperature:", type(temperature))
print("Тип name:", type(name))
print("Тип is_student:", type(is_student))
# Операции, характерные для каждого типа
print("\n--- Операции с разными типами ---")
print("Через 5 лет мне будет:", age + 5)           # Арифметика с int
print("Температура повысилась:", temperature + 0.5) # Арифметика с float
print("Привет, " + name + "!")                    # Конкатенация (склеивание) строк
print("Я студент?", is_student)                   # Работа с булевым значением
```
Вывод в консоли:
```bash
Тип age: <class 'int'>
Тип temperature: <class 'float'>
Тип name: <class 'str'>
Тип is_student: <class 'bool'>
--- Операции с разными типами ---
Через 5 лет мне будет: 30
Температура повысилась: 37.1
Привет, Анна!
Я студент? True
```
Слайд 3: Пример 2 — Преобразование типов данных
Задача: Показать, как преобразовывать данные между разными типами.
```python
# Частая ситуация: данные из внешнего источника (например, ввод пользователя)
user_input = "150"  # Это строка, а не число!

# 1. Попытка выполнить операцию без преобразования типа (вызовет ошибку)
# total = user_input + 50  # ОШИБКА! Нельзя складывать строку с числом

# 2. Правильное решение: преобразование типов
price = int(user_input)    # Преобразуем строку "150" в целое число 150
delivery = 50
total_cost = price + delivery

print("Цена товара:", price, "руб.")
print("Стоимость доставки:", delivery, "руб.")
print("Итого к оплате:", total_cost, "руб.")

# 3. Другие полезные преобразования
print("\n--- Другие преобразования ---")
weight = 7.89
print("Вес как целое число:", int(weight))        # float -> int (отбрасывает дробную часть)
print("Цена как строка: '" + str(price) + "'")    # int -> str (для вывода с текстом)
print("Является ли цена больше 100?", bool(price > 100))  # Результат сравнения -> bool
```
Вывод в консоли:
```bash
Цена товара: 150 руб.
Стоимость доставки: 50 руб.
Итого к оплате: 200 руб.

--- Другие преобразования ---
Вес как целое число: 7
Цена как строка: '150'
Является ли цена больше 100? True
```
Слайд 4: Ключевые выводы
```
int — для целых чисел, float — для дробных
str — для текста, всегда в кавычках
bool — только True или False
type() — функция для проверки типа переменной
int(), float(), str(), bool() — функции для преобразования типов
Python автоматически определяет тип при создании переменной
Несовместимые типы данных нельзя использовать вместе без преобразования
Почему это важно? Правильная работа с типами — основа написания корректных программ без ошибок!
```
Тема: Переменные и арифметические действия
Задания для практики:
Задание 1: Калькулятор площади
```python
# Рассчитайте площадь прямоугольника
# Данные: длина = 8.5, ширина = 4.2
# Выведите результат в формате: "Площадь прямоугольника: [результат]"
# Ваш код здесь
```
Задание 2: Конвертер валют
```python
# Конвертируйте доллары в рубли
# Данные: сумма в долларах = 150, курс доллара = 92.5
# Выведите: "150 долларов = [результат] рублей"
# Ваш код здесь

```
Задание 3: Расчет скидки
```python
# Рассчитайте итоговую стоимость товара со скидкой
# Данные: цена товара = 2500, скидка = 15%
# Выведите: "Цена со скидкой: [результат] рублей"
# Ваш код здесь
```
Тема: Простые типы данных
Задания для практики:
Задание 1: Анализатор данных
```python
# Определите типы данных и выполните преобразования
number_str = "125"
temperature = 23.7
is_sunny = "True"
# 1. Определите тип каждой переменной
# 2. Преобразуйте number_str в int и прибавьте 25
# 3. Преобразуйте temperature в int
# 4. Преобразуйте is_sunny в bool
# Ваш код здесь
```
Задание 2: Форматирование информации
```python
# Создайте информационную карточку студента
name = "Иван"
age = 20
average_grade = 4.5
is_budget_student = True

# Выведите информацию в формате:
# "Студент: [имя], Возраст: [возраст] лет"
# "Средний балл: [балл], Бюджет: [да/нет]"
# Ваш код здесь
```
Задание 3: Валидатор пароля
```python
# Проверьте, соответствует ли пароль требованиям
password = "12345"
min_length = 6

# 1. Определите тип password и min_length
# 2. Проверьте длину пароля (преобразуйте в нужные типы)
# 3. Выведите: "Пароль надежен: [True/False]"
# Ваш код здесь
```
Ответы к заданиям (для проверки):
Ответы к теме "Переменные":
```python
# #Задание 1
length = 8.5
width = 4.2
area = length * width
print("Площадь прямоугольника:", area)

# #Задание 2
dollars = 150
exchange_rate = 92.5
rubles = dollars * exchange_rate
print(f"{dollars} долларов = {rubles} рублей")

# #Задание 3
price = 2500
discount = 15
final_price = price * (1 - discount / 100)
print("Цена со скидкой:", final_price, "рублей")
```
Ответы к теме "Типы данных":
```python
# #Задание 1
number_str = "125"
temperature = 23.7
is_sunny = "True"

print("Тип number_str:", type(number_str))
print("Тип temperature:", type(temperature))
print("Тип is_sunny:", type(is_sunny))

number_int = int(number_str) + 25
temp_int = int(temperature)
is_sunny_bool = bool(is_sunny)

print("Результаты:", number_int, temp_int, is_sunny_bool)

# #Задание 2
name = "Иван"
age = 20
average_grade = 4.5
is_budget_student = True

print("Студент:", name + ", Возраст:", str(age), "лет")
print("Средний балл:", str(average_grade) + ", Бюджет:", str(is_budget_student))

# #Задание 3
password = "12345"
min_length = 6

print("Тип password:", type(password))
print("Тип min_length:", type(min_length))

is_secure = len(password) >= min_length
print("Пароль надежен:", is_secure)
```
Ввод и вывод информации.

Тема: Ввод и вывод информации
```
Слайд 1: Теория — Ввод и вывод информации
Функция вывода print()
Используется для отображения информации на экране
Может выводить текст, числа, переменные
Поддерживает вывод нескольких значений через запятую
Функция ввода input()
Используется для получения данных от пользователя
Всегда возвращает строку (str)
Можно добавить подсказку-приглашение для ввода
Особенности:
Данные от input() всегда нужно преобразовывать к нужному типу
print() автоматически добавляет пробел между аргументами
Можно форматировать вывод для красоты

```
Слайд 2: Пример 1 — Простая форма регистрации
Задача: Создать простую форму для ввода данных пользователя.
```python
# 1. Получаем данные от пользователя
print("=== Регистрация пользователя ===")
name = input("Введите ваше имя: ")
age = input("Введите ваш возраст: ")
city = input("Введите ваш город: ")

# 2. Выводим полученную информацию
print("\n=== Данные пользователя ===")
print("Имя:", name)
print("Возраст:", age)
print("Город:", city)

# 3. Выводим все данные в одной строке
print(f"\nПользователь: {name}, {age} лет, г. {city}")
```
Вывод в консоли:
```bash
=== Регистрация пользователя ===
Введите ваше имя: Мария
Введите ваш возраст: 25
Введите ваш город: Москва

=== Данные пользователя ===
Имя: Мария
Возраст: 25
Город: Москва

Пользователь: Мария, 25 лет, г. Москва
```
Слайд 3: Пример 2 — Калькулятор с пользовательским вводом
Задача: Создать калькулятор, который получает числа от пользователя.
```python
# 1. Получаем числа от пользователя (преобразуем к float)
print("=== Простой калькулятор ===")
num1 = float(input("Введите первое число: "))
num2 = float(input("Введите второе число: "))

# 2. Выполняем арифметические операции
sum_result = num1 + num2
diff_result = num1 - num2
mult_result = num1 * num2
div_result = num1 / num2

# 3. Выводим результаты с форматированием
print("\n=== Результаты вычислений ===")
print(f"{num1} + {num2} = {sum_result}")
print(f"{num1} - {num2} = {diff_result}")
print(f"{num1} * {num2} = {mult_result}")
print(f"{num1} / {num2} = {div_result:.2f}")  # Округляем до 2-х знаков
```
Вывод в консоли:
```bash
=== Простой калькулятор ===
Введите первое число: 15
Введите второе число: 4

=== Результаты вычислений ===
15.0 + 4.0 = 19.0
15.0 - 4.0 = 11.0
15.0 * 4.0 = 60.0
15.0 / 4.0 = 3.75
```
Слайд 4: Пример 3 — Анкета с проверкой типов данных
Задача: Создать анкету с разными типами данных и проверкой ввода.
```python
# Анкета с разными типами данных
print("=== Заполните анкету ===")

# Строковые данные
full_name = input("ФИО: ")
profession = input("Профессия: ")

# Числовые данные (с преобразованием)
experience = int(input("Опыт работы (лет): "))
salary = float(input("Желаемая зарплата: "))

# Логические данные
has_education = input("Есть высшее образование (да/нет): ").lower() == 'да'
is_ready_to_relocate = input("Готов к переезду (да/нет): ").lower() == 'да'

# Вывод форматированной анкеты
print("\n" + "="*40)
print("АНКЕТА СОИСКАТЕЛЯ")
print("="*40)
print(f"ФИО: {full_name}")
print(f"Профессия: {profession}")
print(f"Опыт работы: {experience} лет")
print(f"Желаемая зарплата: {salary:.0f} руб.")
print(f"Высшее образование: {'Да' if has_education else 'Нет'}")
print(f"Готов к переезду: {'Да' if is_ready_to_relocate else 'Нет'}")
print("="*40)
```
Вывод в консоли:
```bash
=== Заполните анкету ===
ФИО: Иванов Алексей Петрович
Профессия: Разработчик Python
Опыт работы (лет): 3
Желаемая зарплата: 120000.5
Есть высшее образование (да/нет): да
Готов к переезду (да/нет): нет

========================================
АНКЕТА СОИСКАТЕЛЯ
========================================
ФИО: Иванов Алексей Петрович
Профессия: Разработчик Python
Опыт работы: 3 лет
Желаемая зарплата: 120000 руб.
Высшее образование: Да
Готов к переезду: Нет
========================================
```
Слайд 5: Задания для практики
Задание 1: Персональный приветственник
```python
# Напишите программу, которая:
# 1. Запрашивает имя пользователя
# 2. Запрашивает его любимый цвет
# 3. Выводит: "Привет, [имя]! Твой любимый цвет - [цвет] - это классно!"
# Ваш код здесь
```
Задание 2: Конвертер единиц измерения
```python
# Напишите программу для конвертации километров в мили
# 1. Запросите у пользователя расстояние в километрах
# 2. Преобразуйте в мили (1 км = 0.621371 миль)
# 3. Выведите: "[км] км = [мили] миль"
# Ваш код здесь
```
Задание 3: Калькулятор чаевых
```python
# Напишите программу для расчета чаевых
# 1. Запросите сумму счета
# 2. Запросите процент чаевых (например, 10, 15, 20)
# 3. Рассчитайте сумму чаевых и итоговую сумму
# 4. Выведите: "Чаевые: [сумма], Итого к оплате: [итого]"
# Ваш код здесь
```
Слайд 6: Ответы к заданиям
```python
# #Задание 1: Персональный приветственник
name = input("Введите ваше имя: ")
color = input("Введите ваш любимый цвет: ")
print(f"Привет, {name}! Твой любимый цвет - {color} - это классно!")

# #Задание 2: Конвертер единиц измерения
km = float(input("Введите расстояние в километрах: "))
miles = km * 0.621371
print(f"{km} км = {miles:.2f} миль")

# #Задание 3: Калькулятор чаевых
bill_amount = float(input("Введите сумму счета: "))
tip_percent = float(input("Введите процент чаевых: "))
tip_amount = bill_amount * (tip_percent / 100)
total_amount = bill_amount + tip_amount
print(f"Чаевые: {tip_amount:.2f} руб., Итого к оплате: {total_amount:.2f} руб.")
```
Ключевые моменты:
```
input() всегда возвращает строку
Для числовых данных используйте int() или float()
print() может выводить несколько значений через запятую
f-строки (f"текст {переменная}") удобны для форматирования
Логические переменные.
Тема: Логические переменные (bool)
```
Слайд 1: Теория — Логические переменные
```
Что такое логические переменные?
Тип данных bool (boolean)
Могут принимать только два значения: True (Истина) или False (Ложь)
Используются для проверки условий и управления потоком программы
Логические операции:
and (И) - True, если ОБА выражения True
or (ИЛИ) - True, если ХОТЯ БЫ ОДНО выражение True
not (НЕ) - инвертирует значение (True → False, False → True)
Операторы сравнения:
== (равно), != (не равно)
> (больше), < (меньше)
>= (больше или равно), <= (меньше или равно)
```
Слайд 2: Пример 1 — Базовые логические операции
Задача: Показать работу логических операторов и операторов сравнения.
```python
# Базовые логические значения
is_sunny = True
is_weekend = False
temperature = 25
print("Базовые значения:")
print("Солнечно:", is_sunny)
print("Выходной:", is_weekend)
print("Температура:", temperature)
# Операторы сравнения
is_warm = temperature > 20
is_hot = temperature >= 30
is_exactly_25 = temperature == 25
print("\nРезультаты сравнений:")
print("Тепло (t > 20):", is_warm)
print("Жарко (t >= 30):", is_hot)
print("Ровно 25 градусов:", is_exactly_25)
# Логические операции
good_weather = is_sunny and is_warm
can_relax = is_weekend or good_weather
is_cold = not is_warm
print("\nЛогические операции:")
print("Хорошая погода (солнечно И тепло):", good_weather)
print("Можно отдыхать (выходной ИЛИ хорошая погода):", can_relax)
print("Холодно (НЕ тепло):", is_cold)
```
Вывод в консоли:
```bash
Базовые значения:
Солнечно: True
Выходной: False
Температура: 25
Результаты сравнений:
Тепло (t > 20): True
Жарко (t >= 30): False
Ровно 25 градусов: True
Логические операции:
Хорошая погода (солнечно И тепло): True
Можно отдыхать (выходной ИЛИ хорошая погода): True
Холодно (НЕ тепло): False
```
Слайд 3: Пример 2 — Проверка условий для входа в клуб
Задача: Создать систему проверки возраста и dress-code для ночного клуба.
```python
print("=== Проверка для входа в клуб ===")
# Получаем данные от пользователя
age = int(input("Введите ваш возраст: "))
has_id = input("Есть ли у вас ID? (да/нет): ").lower() == 'да'
is_dress_code_ok = input("Соответствует ли ваш внешний вид dress-code? (да/нет): ").lower() == 'да'
# Проверяем условия
is_adult = age >= 18
has_valid_id = has_id and is_adult
can_enter = has_valid_id and is_dress_code_ok
# Детальная проверка причин
too_young = age < 18
no_id = not has_id
bad_dress = not is_dress_code_ok
print("\n=== Результат проверки ===")
print(f"Возраст подходит: {is_adult}")
print(f"ID действителен: {has_valid_id}")
print(f"Dress-code соблюден: {is_dress_code_ok}")
print(f"Можно войти: {can_enter}")
# Объясняем причину отказа
if not can_enter:
    print("\nПричины отказа:")
    if too_young:
        print("- Несовершеннолетний")
    if no_id:
        print("- Нет ID")
    if bad_dress:
        print("- Несоответствие dress-code")
else:
    print("\nДобро пожаловать в клуб!")
```
Вывод в консоли:
```bash
=== Проверка для входа в клуб ===
Введите ваш возраст: 20
Есть ли у вас ID? (да/нет): да
Соответствует ли ваш внешний вид dress-code? (да/нет): нет
=== Результат проверки ===
Возраст подходит: True
ID действителен: True
Dress-code соблюден: False
Можно войти: False
Причины отказа:
- Несоответствие dress-code
```
Слайд 4: Пример 3 — Система проверки пароля
Задача: Создать систему проверки сложности пароля.
```python
print("=== Проверка сложности пароля ===")
password = input("Введите пароль: ")
# Проверяем различные критерии безопасности
has_min_length = len(password) >= 8
has_uppercase = any(char.isupper() for char in password)
has_lowercase = any(char.islower() for char in password)
has_digit = any(char.isdigit() for char in password)
has_special = any(not char.isalnum() for char in password)
# Общая оценка сложности
is_strong = has_min_length and has_uppercase and has_lowercase and has_digit and has_special
is_medium = has_min_length and ((has_uppercase and has_lowercase) or has_digit)
is_weak = not is_strong and not is_medium
print("\n=== Анализ пароля ===")
print(f"Длина ≥ 8 символов: {has_min_length}")
print(f"Есть заглавные буквы: {has_uppercase}")
print(f"Есть строчные буквы: {has_lowercase}")
print(f"Есть цифры: {has_digit}")
print(f"Есть спецсимволы: {has_special}")
print("\n=== Оценка сложности ===")
print(f"Слабый пароль: {is_weak}")
print(f"Средний пароль: {is_medium}")
print(f"Сильный пароль: {is_strong}")
# Рекомендации
if is_weak:
    print("Рекомендация: Используйте больше различных типов символов")
elif is_medium:
    print("Рекомендация: Добавьте спецсимволы для усиления")
else:
    print("Отличный пароль! Он надежно защищен")
```
Вывод в консоли:
```bash
=== Проверка сложности пароля ===
Введите пароль: MyPass123!
=== Анализ пароля ===
Длина ≥ 8 символов: True
Есть заглавные буквы: True
Есть строчные буквы: True
Есть цифры: True
Есть спецсимволы: True
=== Оценка сложности ===
Слабый пароль: False
Средний пароль: False
Сильный пароль: True
Отличный пароль! Он надежно защищен
```
Слайд 5: Задания для практики
Задание 1: Проверка студенческой скидки
```python
# Напишите программу, которая проверяет право на студенческую скидку
# Условия: возраст ≤ 25 И статус студента = True
# Запросите у пользователя возраст и статус студента
# Выведите: "Скидка доступна: [True/False]"
# Ваш код здесь
```
Задание 2: Калькулятор доставки
```python
# Напишите программу для расчета бесплатной доставки
# Условия бесплатной доставки: 
# - Сумма заказа ≥ 5000 ИЛИ 
# - VIP-клиент = True
# Запросите сумму заказа и статус VIP-клиента
# Выведите: "Бесплатная доставка: [True/False]"
# Ваш код здесь
```
Задание 3: Система доступа к контенту
```python
# Напишите программу проверки доступа к контенту
# Условия доступа: возраст ≥ 18 И подписка активна = True
# Дополнительно: родительский контроль отключен = True
# Запросите все необходимые данные
# Выведите: "Доступ разрешен: [True/False]"
# Ваш код здесь
```
Слайд 6: Ответы к заданиям
```python
# #Задание 1: Проверка студенческой скидки
age = int(input("Введите ваш возраст: "))
is_student = input("Вы студент? (да/нет): ").lower() == 'да'
discount_available = age <= 25 and is_student
print("Скидка доступна:", discount_available)
# #Задание 2: Калькулятор доставки
order_amount = float(input("Введите сумму заказа: "))
is_vip = input("Вы VIP-клиент? (да/нет): ").lower() == 'да'
free_delivery = order_amount >= 5000 or is_vip
print("Бесплатная доставка:", free_delivery)
# #Задание 3: Система доступа к контенту
age = int(input("Введите ваш возраст: "))
subscription_active = input("Подписка активна? (да/нет): ").lower() == 'да'
parental_control_off = input("Родительский контроль отключен? (да/нет): ").lower() == 'да'
access_granted = age >= 18 and subscription_active and parental_control_off
print("Доступ разрешен:", access_granted)
```
Ключевые моменты:
```
bool значения всегда True или False
Операторы сравнения возвращают bool значения
Логические операции (and, or, not) комбинируют условия
Часто используются в условиях для принятия решений в программах
Операторы отношений.
```
 «Операторы отношений»
Тема: Операторы отношений
```
Слайд 1: Теория — Операторы отношений
Что такое операторы отношений?
Операторы для сравнения двух значений
Всегда возвращают логическое значение: True или False
Используются для проверки условий в программах
```
Основные операторы отношений:
Оператор	Название	Пример	Результат
==	Равно	5 == 5	True
!=	Не равно	5 != 3	True
>	Больше	5 > 3	True
<	Меньше	5 < 3	False
>=	Больше или равно	5 >= 5	True
<=	Меньше или равно	5 <= 3	False
Особенности:
Работают с разными типами данных: числа, строки, логические значения
Строки сравниваются посимвольно (лексикографически)
Регистр имеет значение при сравнении строк
Слайд 2: Пример 1 — Базовые операции сравнения
Задача: Показать работу всех операторов отношений с числами.
```python
# Определяем переменные для сравнения
a = 10
b = 5
c = 10

print("Переменные для сравнения:")
print(f"a = {a}, b = {b}, c = {c}")

print("\n=== Результаты сравнений ===")
# Оператор равенства
print(f"a == c: {a == c}")      # 10 равно 10
print(f"a == b: {a == b}")      # 10 равно 5

# Оператор неравенства
print(f"a != b: {a != b}")      # 10 не равно 5
print(f"a != c: {a != c}")      # 10 не равно 10

# Операторы больше/меньше
print(f"a > b: {a > b}")        # 10 больше 5
print(f"b < a: {b < a}")        # 5 меньше 10
print(f"a < b: {a < b}")        # 10 меньше 5

# Операторы больше/меньше или равно
print(f"a >= c: {a >= c}")      # 10 больше или равно 10
print(f"a >= b: {a >= b}")      # 10 больше или равно 5
print(f"b <= a: {b <= a}")      # 5 меньше или равно 10
print(f"b <= c: {b <= c}")      # 5 меньше или равно 10

# Сравнение с отрицательными числами
negative_num = -5
print(f"\nСравнение с отрицательными:")
print(f"{a} > {negative_num}: {a > negative_num}")
print(f"{b} == {negative_num}: {b == negative_num}")
```
Вывод в консоли:
```bash
Переменные для сравнения:
a = 10, b = 5, c = 10

=== Результаты сравнений ===
a == c: True
a == b: False
a != b: True
a != c: False
a > b: True
b < a: True
a < b: False
a >= c: True
a >= b: True
b <= a: True
b <= c: True

Сравнение с отрицательными:
10 > -5: True
5 == -5: False
```
Слайд 3: Пример 2 — Сравнение строк и разных типов данных
Задача: Показать сравнение строк и особенности работы операторов.
```python
print("=== Сравнение строк ===")

# Сравнение строк
name1 = "Анна"
name2 = "анна"  # разный регистр
name3 = "Анна"
word1 = "apple"
word2 = "banana"

print("Строки для сравнения:")
print(f"name1 = '{name1}', name2 = '{name2}', name3 = '{name3}'")

print("\nРезультаты сравнения строк:")
print(f"'{name1}' == '{name3}': {name1 == name3}")  # True - одинаковые
print(f"'{name1}' == '{name2}': {name1 == name2}")  # False - разный регистр
print(f"'{name1}' != '{name2}': {name1 != name2}")  # True - разные

# Лексикографическое сравнение (по алфавиту)
print(f"\nЛексикографическое сравнение:")
print(f"'{word1}' < '{word2}': {word1 < word2}")    # True - 'a' перед 'b'
print(f"'{word2}' > '{word1}': {word2 > word1}")    # True - 'b' после 'a'

print("\n=== Сравнение разных типов данных ===")
# Сравнение чисел разных типов
int_num = 10
float_num = 10.0
str_num = "10"

print(f"int {int_num} == float {float_num}: {int_num == float_num}")  # True
print(f"int {int_num} == str '{str_num}': {int_num == str_num}")      # False
print(f"float {float_num} == str '{str_num}': {float_num == str_num}") # False

# Преобразование перед сравнением
print(f"\nПосле преобразования:")
print(f"int {int_num} == int('{str_num}'): {int_num == int(str_num)}") # True
```
Вывод в консоли:
```bash
=== Сравнение строк ===
Строки для сравнения:
name1 = 'Анна', name2 = 'анна', name3 = 'Анна'

Результаты сравнения строк:
'Анна' == 'Анна': True
'Анна' == 'анна': False
'Анна' != 'анна': True

Лексикографическое сравнение:
'apple' < 'banana': True
'banana' > 'apple': True

=== Сравнение разных типов данных ===
int 10 == float 10.0: True
int 10 == str '10': False
float 10.0 == str '10': False

После преобразования:
int 10 == int('10'): True
```
Слайд 4: Пример 3 — Практическое применение: система оценок
Задача: Создать систему проверки оценок студента.
```python
print("=== Система проверки успеваемости ===")

# Получаем данные от пользователя
student_name = input("Введите имя студента: ")
math_score = int(input("Введите оценку по математике: "))
physics_score = int(input("Введите оценку по физике: "))
programming_score = int(input("Введите оценку по программированию: "))

# Проверяем различные условия
passed_all = math_score >= 3 and physics_score >= 3 and programming_score >= 3
excellent_student = math_score == 5 and physics_score == 5 and programming_score == 5
good_student = (math_score >= 4 and physics_score >= 4 and programming_score >= 4) and not excellent_student
has_failed = math_score < 3 or physics_score < 3 or programming_score < 3

# Сравниваем предметы между собой
math_better_physics = math_score > physics_score
physics_better_programming = physics_score > programming_score
all_equal = math_score == physics_score == programming_score

print("\n=== Результаты анализа ===")
print(f"Студент: {student_name}")
print(f"Оценки: Математика={math_score}, Физика={physics_score}, Программирование={programming_score}")

print("\n=== Общая успеваемость ===")
print(f"Сдал все предметы: {passed_all}")
print(f"Отличник: {excellent_student}")
print(f"Хорошист: {good_student}")
print(f"Есть несданные предметы: {has_failed}")

print("\n=== Сравнение предметов ===")
print(f"Математика лучше физики: {math_better_physics}")
print(f"Физика лучше программирования: {physics_better_programming}")
print(f"Все оценки одинаковые: {all_equal}")

# Анализ самого сильного предмета
if math_score >= physics_score and math_score >= programming_score:
    strongest = "Математика"
elif physics_score >= math_score and physics_score >= programming_score:
    strongest = "Физика"
else:
    strongest = "Программирование"
print(f"Самый сильный предмет: {strongest}")
```
Вывод в консоли:
```bash
=== Система проверки успеваемости ===
Введите имя студента: Алексей
Введите оценку по математике: 5
Введите оценку по физике: 4
Введите оценку по программированию: 5

=== Результаты анализа ===
Студент: Алексей
Оценки: Математика=5, Физика=4, Программирование=5

=== Общая успеваемость ===
Сдал все предметы: True
Отличник: False
Хорошист: True
Есть несданные предметы: False

=== Сравнение предметов ===
Математика лучше физики: True
Физика лучше программирования: False
Все оценки одинаковые: False
Самый сильный предмет: Математика
```
Слайд 5: Задания для практики
Задание 1: Проверка возраста
```python
# Напишите программу, которая проверяет различные возрастные категории
# Запросите возраст у пользователя
# Проверьте: является ли человек совершеннолетним, пенсионером, ребенком
# Используйте: >=, <=, and, or
# Ваш код здесь
```
Задание 2: Сравнение чисел
```python
# Напишите программу для сравнения трех чисел
# Запросите три числа у пользователя
# Проверьте: какое число наибольшее, наименьшее, есть ли равные числа
# Используйте: >, <, ==, !=
# Ваш код здесь
```
Задание 3: Проверка пароля
```python
# Напишите программу для проверки совпадения паролей
# Запросите пароль и подтверждение пароля
# Проверьте: совпадают ли пароли, достаточная ли длина (≥8 символов)
# Используйте: ==, >=, len()
# Ваш код здесь
```
Слайд 6: Ответы к заданиям
```python
# #Задание 1: Проверка возраста
age = int(input("Введите ваш возраст: "))
is_adult = age >= 18
is_pensioner = age >= 65
is_child = age < 18
is_teenager = age >= 13 and age <= 19
print(f"Совершеннолетний: {is_adult}")
print(f"Пенсионер: {is_pensioner}")
print(f"Ребенок: {is_child}")
print(f"Подросток: {is_teenager}")
# #Задание 2: Сравнение чисел
num1 = float(input("Введите первое число: "))
num2 = float(input("Введите второе число: "))
num3 = float(input("Введите третье число: "))
max_num = max(num1, num2, num3)
min_num = min(num1, num2, num3)
has_equal = num1 == num2 or num1 == num3 or num2 == num3
all_different = num1 != num2 and num1 != num3 and num2 != num3
print(f"Наибольшее число: {max_num}")
print(f"Наименьшее число: {min_num}")
print(f"Есть равные числа: {has_equal}")
print(f"Все числа разные: {all_different}")
# #Задание 3: Проверка пароля
password = input("Введите пароль: ")
confirm_password = input("Подтвердите пароль: ")
passwords_match = password == confirm_password
has_min_length = len(password) >= 8
is_valid = passwords_match and has_min_length
print(f"Пароли совпадают: {passwords_match}")
print(f"Достаточная длина: {has_min_length}")
print(f"Пароль валиден: {is_valid}")
```
Ключевые моменты:
```
Операторы отношений всегда возвращают True или False
== проверяет равенство, != - неравенство
При сравнении строк учитывается регистр
Числа разных типов можно сравнивать (int с float)
Операторы отношений часто комбинируются с логическими операторами
Варианты инструкции if
```
 «Варианты инструкции if»
 ```
Тема: Варианты инструкции if
Слайд 1: Теория — Варианты инструкции if
Инструкция if — основа управления потоком выполнения программы
Позволяет выполнять код только при выполнении определенных условий
Основные варианты:
Простой if — одна ветка выполнения
if-else — две ветки (истина/ложь)
if-elif-else — множественный выбор
Вложенные if — условия внутри условий
Синтаксис:
```
```python
if условие:
    # код при True
elif другое_условие:
    # код при True
else:
    # код если все False
```
Слайд 2: Пример 1 — Простой if и if-else
Задача: Проверка возраста для доступа к контенту.
```python
print("=== Проверка возраста для доступа ===")
# Простой if
age = int(input("Введите ваш возраст: "))
print("\n--- Простой if ---")
if age >= 18:
    print("Доступ разрешен к взрослому контенту")
if age < 18:
    print("Доступ ограничен")
print("\n--- if-else ---")
# if-else (взаимоисключающие условия)
if age >= 18:
    print("Доступ разрешен к взрослому контенту")
    print("Можно совершать покупки")
else:
    print("Доступ ограничен")
    print("Доступен только детский контент")
print("\n--- Дополнительная проверка ---")
# Проверка на совершеннолетие с дополнительными условиями
if age >= 18:
    print("Вы совершеннолетний")
else:
    years_left = 18 - age
    print(f"До совершеннолетия осталось: {years_left} лет")
```
Вывод в консоли:
```bash
=== Проверка возраста для доступа ===
Введите ваш возраст: 16
--- Простой if ---
Доступ ограничен
--- if-else ---
Доступ ограничен
Доступен только детский контент
--- Дополнительная проверка ---
До совершеннолетия осталось: 2 лет
```
Слайд 3: Пример 2 — Множественный выбор (if-elif-else)
Задача: Система оценок с множественными условиями.
```python
print("=== Система оценок ===")
score = int(input("Введите балл (0-100): "))
print("\n--- if-elif-else цепочка ---")
# Множественный выбор
if score >= 90:
    grade = "A"
    comment = "Отлично!"
elif score >= 80:
    grade = "B" 
    comment = "Очень хорошо"
elif score >= 70:
    grade = "C"
    comment = "Хорошо"
elif score >= 60:
    grade = "D"
    comment = "Удовлетворительно"
else:
    grade = "F"
    comment = "Неудовлетворительно"
print(f"Оценка: {grade}")
print(f"Комментарий: {comment}")
print("\n--- Проверка на отличника ---")
# Дополнительные проверки
if grade == "A":
    print("Поздравляем! Вы отличник!")
    if score == 100:
        print("Идеальный результат!")
elif grade == "B" or grade == "C":
    print("Хорошая работа!")
else:
    print("Нужно подтянуть знания")
print("\n--- Статус студента ---")
# Определение статуса
if score >= 70:
    status = "Успевающий"
elif score >= 60:
    status = "Условно успевающий"
else:
    status = "Неуспевающий"
print(f"Статус: {status}")
```
Вывод в консоли:
```bash
=== Система оценок ===
Введите балл (0-100): 85
--- if-elif-else цепочка ---
Оценка: B
Комментарий: Очень хорошо
--- Проверка на отличника ---
Хорошая работа!
--- Статус студента ---
Статус: Успевающий
```
Слайд 4: Пример 3 — Вложенные условия и сложные проверки
Задача: Система банковских операций с несколькими уровнями проверок.
```python
print("=== Банковская система ===")
balance = float(input("Введите текущий баланс: "))
requested_amount = float(input("Введите сумму для снятия: "))
is_vip = input("VIP клиент? (да/нет): ").lower() == 'да'
has_overdraft = input("Есть овердрафт? (да/нет): ").lower() == 'да'
print("\n=== Проверка возможности операции ===")
# Вложенные условия
if requested_amount <= balance:
    # Хватает средств
    balance -= requested_amount
    print(f"Операция выполнена успешно!")
    print(f"Снято: {requested_amount} руб.")
    print(f"Остаток на счете: {balance} руб.")    
    # Проверка минимального остатка
    if balance < 1000:
        print("Внимание: низкий остаток на счете!")        
else:
    # Не хватает средств
    print("Недостаточно средств на счете")
    
    # Проверка овердрафта для VIP
    if has_overdraft and is_vip:
        overdraft_limit = 5000
        available_overdraft = balance + overdraft_limit        
        if requested_amount <= available_overdraft:
            print("Одобрен овердрафт!")
            balance -= requested_amount
            print(f"Снято: {requested_amount} руб.")
            print(f"Баланс с овердрафтом: {balance} руб.")
        else:
            print("Превышен лимит овердрафта")
            
    elif is_vip and not has_overdraft:
        print("Обратитесь в банк для подключения овердрафта")        
    else:
        print("Доступные варианты:")
        print(f"- Снять доступную сумму: {balance} руб.")
        if not is_vip:
            print("- Станьте VIP клиентом для получения овердрафта")
print("\n=== Дополнительные услуги ===")
# Сложные условия с and/or
if balance > 10000 and is_vip:
    print("Доступна премиальная кредитная карта")
elif balance > 5000 or is_vip:
    print("Доступен стандартный кредитный лимит")
else:
    print("Изучите наши сберегательные программы")
```
Вывод в консоли:
```bash
=== Банковская система ===
Введите текущий баланс: 8000
Введите сумму для снятия: 12000
VIP клиент? (да/нет): да
Есть овердрафт? (да/нет): да

=== Проверка возможности операции ===
Недостаточно средств на счете
Одобрен овердрафт!
Снято: 12000.0 руб.
Баланс с овердрафтом: -4000.0 руб.

=== Дополнительные услуги ===
Изучите наши сберегательные программы
```
Слайд 5: Пример 4 — Сокращенные формы и best practices
Задача: Показать различные стили написания условий.
```python
print("=== Различные стили условий ===")
temperature = int(input("Введите температуру: "))
is_weekend = input("Выходной? (да/нет): ").lower() == 'да'
is_holiday = input("Праздник? (да/нет): ").lower() == 'да'
print("\n--- Традиционный стиль ---")
if temperature > 25:
    if is_weekend or is_holiday:
        print("Идеально для пляжа!")
    else:
        print("Жарко, но нужно работать")
else:
    print("Прохладная погода")
print("\n--- Упрощенный стиль с переменными-флагами ---")
# Создаем понятные переменные для условий
perfect_beach_weather = temperature > 25
can_relax = is_weekend or is_holiday
if perfect_beach_weather and can_relax:
    print("Идеально для пляжа!")
elif perfect_beach_weather and not can_relax:
    print("Жарко, но нужно работать")
else:
    print("Прохладная погода")
print("\n--- Каскадные проверки ---")
# Последовательные проверки
if temperature > 30:
    print("Очень жарко")
elif temperature > 20:
    print("Тепло")
elif temperature > 10:
    print("Прохладно")
elif temperature > 0:
    print("Холодно")
else:
    print("Мороз")
print("\n--- Короткие условия ---")
# One-line условия для простых случаев
weather_status = "Жарко" if temperature > 25 else "Умеренно"
print(f"Погода: {weather_status}")
# Тернарный оператор
activity = "Отдых" if can_relax else "Работа"
print(f"Рекомендация: {activity}")
```
Вывод в консоли:
```bash
=== Различные стили условий ===
Введите температуру: 28
Выходной? (да/нет): да
Праздник? (да/нет): нет
--- Традиционный стиль ---
Идеально для пляжа!
--- Упрощенный стиль с переменными-флагами ---
Идеально для пляжа!
--- Каскадные проверки ---
Тепло
--- Короткие условия ---
Погода: Жарко
Рекомендация: Отдых
```
Слайд 6: Задания для практики
Задание 1: Калькулятор скидок
```python
# Напишите программу расчета скидки в магазине
# Правила: 
# - При покупке от 5000 руб. - скидка 5%
# - При покупке от 10000 руб. - скидка 10% 
# - При покупке от 20000 руб. - скидка 15%
# - Постоянным клиентам +5% к скидке
# Запросите сумму покупки и статус клиента
# Выведите итоговую сумму и размер скидки
# Ваш код здесь
```
Задание 2: Определение времени суток
```python
# Напишите программу определения времени суток
# Правила:
# 5-11 утра - Утро
# 12-17 день - День  
# 18-23 вечер - Вечер
# 0-4 ночь - Ночь
# Запросите время (часы) и выведите период суток
# Добавьте проверку корректности ввода (0-23)
# Ваш код здесь
```
Задание 3: Система аутентификации
```python
# Напишите систему проверки логина и пароля
# Условия:
# - Логин должен быть не менее 5 символов
# - Пароль должен быть не менее 8 символов  
# - Пароль должен содержать цифры и буквы
# - Подтверждение пароля должно совпадать
# Запросите все данные и выведите результат проверки
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Калькулятор скидок
amount = float(input("Введите сумму покупки: "))
is_regular = input("Постоянный клиент? (да/нет): ").lower() == 'да'
if amount >= 20000:
    discount = 15
elif amount >= 10000:
    discount = 10
elif amount >= 5000:
    discount = 5
else:
    discount = 0

if is_regular:
    discount += 5
final_amount = amount * (1 - discount / 100)
print(f"Скидка: {discount}%")
print(f"Итоговая сумма: {final_amount:.2f} руб.")
# #Задание 2: Определение времени суток
hour = int(input("Введите текущий час (0-23): "))
if hour < 0 or hour > 23:
    print("Ошибка! Введите число от 0 до 23")
elif 5 <= hour <= 11:
    print("Утро")
elif 12 <= hour <= 17:
    print("День")
elif 18 <= hour <= 23:
    print("Вечер")
else:
    print("Ночь")
# #Задание 3: Система аутентификации
login = input("Введите логин: ")
password = input("Введите пароль: ")
confirm_password = input("Подтвердите пароль: ")
# Проверки
is_login_valid = len(login) >= 5
is_password_length_ok = len(password) >= 8
has_digit = any(char.isdigit() for char in password)
has_letter = any(char.isalpha() for char in password)
is_password_complex = has_digit and has_letter
passwords_match = password == confirm_password
if is_login_valid and is_password_length_ok and is_password_complex and passwords_match:
    print("Регистрация успешна!")
else:
    print("Ошибки:")
    if not is_login_valid:
        print("- Логин должен быть не менее 5 символов")
    if not is_password_length_ok:
        print("- Пароль должен быть не менее 8 символов")
    if not is_password_complex:
        print("- Пароль должен содержать цифры и буквы")
    if not passwords_match:
        print("- Пароли не совпадают")
```
Ключевые моменты:
```
if — для одиночных условий
if-else — для выбора из двух вариантов
if-elif-else — для множественного выбора
Вложенные if — для сложных многоуровневых проверок
Всегда используйте отступы (4 пробела)
Делайте условия читаемыми с помощью переменных-флагов
Синтаксис циклических инструкций while, for
```
 «Синтаксис циклических инструкций while, for»
Тема: Синтаксис циклических инструкций while, for
Слайд 1: 
```
Теория — Циклические инструкции
Циклы — конструкции для многократного выполнения блока кода
Два основных типа циклов в Python:
while — повторение пока условие истинно
for — перебор элементов последовательности
Ключевые слова:
break — немедленный выход из цикла
continue — переход к следующей итерации
else — выполняется после нормального завершения цикла (без break)
```
Слайд 2: Цикл while — синтаксис и базовые примеры
Синтаксис:
```python
while условие:
    # выполняемый код
```
Задача: Простой счетчик и ввод до определенного значения.
```python
print("=== Цикл while - базовые примеры ===")
print("\n--- Простой счетчик ---")
# Счетчик от 1 до 5
counter = 1
while counter <= 5:
    print(f"Итерация №{counter}")
    counter += 1  # важно изменять условие!
print("\n--- Ввод пароля ---")
# Повторять пока пароль неверный
password = ""
correct_password = "python123"
while password != correct_password:
    password = input("Введите пароль: ")
    if password != correct_password:
        print("Неверный пароль! Попробуйте снова.")
    else:
        print("Доступ разрешен!")

print("\n--- Обратный отсчет ---")
# Обратный отсчет с проверкой
time_left = 10
while time_left > 0:
    print(f"Осталось секунд: {time_left}")
    time_left -= 1
print("Время вышло!")
```
Вывод в консоли:
```bash
=== Цикл while - базовые примеры ===
--- Простой счетчик ---
Итерация №1
Итерация №2
Итерация №3
Итерация №4
Итерация №5
--- Ввод пароля ---
Введите пароль: 123
Неверный пароль! Попробуйте снова.
Введите пароль: python123
Доступ разрешен!
--- Обратный отсчет ---
Осталось секунд: 10
Осталось секунд: 9
...
Осталось секунд: 1
Время вышло!
```
Слайд 3: Цикл for — синтаксис и базовые примеры
Синтаксис:
```python
for элемент in последовательность:
    # выполняемый код
```
Задача: Перебор различных последовательностей.
```python
print("=== Цикл for - базовые примеры ===")
print("\n--- Перебор строки ---")
# Перебор символов в строке
word = "Python"
for char in word:
    print(f"Символ: {char}")

print("\n--- Перебор списка ---")
# Перебор элементов списка
fruits = ["яблоко", "банан", "апельсин", "киви"]
for fruit in fruits:
    print(f"Фрукт: {fruit}")

print("\n--- Функция range() ---")
# Range для генерации числовых последовательностей
print("Range(5):")
for i in range(5):
    print(i, end=" ")

print("\n\nRange(2, 8):")
for i in range(2, 8):
    print(i, end=" ")

print("\n\nRange(1, 10, 2):")
for i in range(1, 10, 2):  # start, stop, step
    print(i, end=" ")

print("\n\n--- Перебор с индексом ---")
# enumerate для получения индекса и значения
colors = ["красный", "зеленый", "синий", "желтый"]
for index, color in enumerate(colors):
    print(f"Индекс {index}: {color}")
```
Вывод в консоли:
```bash
=== Цикл for - базовые примеры ===

--- Перебор строки ---
Символ: P
Символ: y
Символ: t
Символ: h
Символ: o
Символ: n

--- Перебор списка ---
Фрукт: яблоко
Фрукт: банан
Фрукт: апельсин
Фрукт: киви

--- Функция range() ---
Range(5):
0 1 2 3 4 

Range(2, 8):
2 3 4 5 6 7 

Range(1, 10, 2):
1 3 5 7 9 

--- Перебор с индексом ---
Индекс 0: красный
Индекс 1: зеленый
Индекс 2: синий
Индекс 3: желтый
```
Слайд 4: Управление циклами — break, continue, else
Задача: Показать работу управляющих конструкций в циклах.
```python
print("=== Управление циклами ===")

print("\n--- Оператор break ---")
# Поиск первого четного числа
numbers = [1, 3, 5, 8, 9, 12, 15]
print(f"Список: {numbers}")

for num in numbers:
    if num % 2 == 0:
        print(f"Найдено первое четное число: {num}")
        break
    print(f"Проверяем {num} - нечетное")

print("\n--- Оператор continue ---")
# Пропуск нечетных чисел
print("Четные числа из списка:")
for num in numbers:
    if num % 2 != 0:
        continue  # переходим к следующей итерации
    print(f"Четное: {num}")
print("\n--- Блок else в циклах ---")
# Else выполняется если цикл завершился нормально (без break)
print("Поиск числа 20 в списке:")
for num in numbers:
    if num == 20:
        print("Число 20 найдено!")
        break
else:
    print("Число 20 не найдено в списке")

print("\n--- While с break ---")
# Бесконечный цикл с условием выхода
total = 0
while True:
    number = int(input("Введите число (0 для выхода): "))
    if number == 0:
        break
    total += number
    print(f"Текущая сумма: {total}")

print(f"Итоговая сумма: {total}")
```
Вывод в консоли:
```bash
=== Управление циклами ===

--- Оператор break ---
Список: [1, 3, 5, 8, 9, 12, 15]
Проверяем 1 - нечетное
Проверяем 3 - нечетное
Проверяем 5 - нечетное
Найдено первое четное число: 8

--- Оператор continue ---
Четные числа из списка:
Четное: 8
Четное: 12

--- Блок else в циклах ---
Поиск числа 20 в списке:
Число 20 не найдено в списке

--- While с break ---
Введите число (0 для выхода): 5
Текущая сумма: 5
Введите число (0 для выхода): 10
Текущая сумма: 15
Введите число (0 для выхода): 0
Итоговая сумма: 15
```
Слайд 5: Практические примеры
Задача: Реальные кейсы использования циклов.
```python
print("=== Практические примеры ===")

print("\n--- Калькулятор среднего балла ---")
# While для ввода неизвестного количества значений
total = 0
count = 0

print("Введите оценки (для завершения введите -1):")
while True:
    grade = int(input("Оценка: "))
    if grade == -1:
        break
    if 1 <= grade <= 5:
        total += grade
        count += 1
    else:
        print("Ошибка! Оценка должна быть от 1 до 5")

if count > 0:
    average = total / count
    print(f"Средний балл: {average:.2f}")
else:
    print("Оценки не введены")

print("\n--- Таблица умножения ---")
# Вложенные циклы for
print("Таблица умножения:")
for i in range(1, 6):
    for j in range(1, 6):
        result = i * j
        print(f"{i} × {j} = {result:2}", end="  ")
    print()  # новая строка

print("\n--- Анализ текста ---")
# For для анализа строки
text = "Программирование на Python это интересно и полезно"
vowels = "аеёиоуыэюяaeiou"
consonants = "бвгджзйклмнпрстфхцчшщbcdfghjklmnpqrstvwxyz"

vowel_count = 0
consonant_count = 0

for char in text.lower():
    if char in vowels:
        vowel_count += 1
    elif char in consonants:
        consonant_count += 1

print(f"Текст: '{text}'")
print(f"Гласных: {vowel_count}")
print(f"Согласных: {consonant_count}")
print(f"Всего букв: {vowel_count + consonant_count}")
```
Вывод в консоли:
```bash
=== Практические примеры ===

--- Калькулятор среднего балла ---
Введите оценки (для завершения введите -1):
Оценка: 5
Оценка: 4
Оценка: 3
Оценка: 5
Оценка: -1
Средний балл: 4.25

--- Таблица умножения ---
Таблица умножения:
1 × 1 =  1  1 × 2 =  2  1 × 3 =  3  1 × 4 =  4  1 × 5 =  5  
2 × 1 =  2  2 × 2 =  4  2 × 3 =  6  2 × 4 =  8  2 × 5 = 10  
3 × 1 =  3  3 × 2 =  6  3 × 3 =  9  3 × 4 = 12  3 × 5 = 15  
4 × 1 =  4  4 × 2 =  8  4 × 3 = 12  4 × 4 = 16  4 × 5 = 20  
5 × 1 =  5  5 × 2 = 10  5 × 3 = 15  5 × 4 = 20  5 × 5 = 25  

--- Анализ текста ---
Текст: 'Программирование на Python это интересно и полезно'
Гласных: 19
Согласных: 22
Всего букв: 41
```
Слайд 6: Задания для практики
Задание 1: Сумма чисел
```python
# Напишите программу, которая:
# 1. Запрашивает у пользователя числа через while
# 2. Завершает ввод при вводе 0
# 3. Выводит сумму всех введенных чисел
# 4. Выводит количество введенных чисел
# Ваш код здесь
```
Задание 2: Поиск простых чисел
```python
# Напишите программу, которая:
# 1. Использует for для перебора чисел от 2 до 50
# 2. Проверяет каждое число на простоту
# 3. Выводит все простые числа в этом диапазоне
# Простое число - делится только на 1 и на себя
# Ваш код здесь
```
Задание 3: Статистика текста
```python
# Напишите программу, которая:
# 1. Запрашивает у пользователя текст
# 2. Использует for для анализа текста
# 3. Подсчитывает: количество слов, символов, предложений
# 4. Выводит статистику
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Сумма чисел
total = 0
count = 0

print("Введите числа (0 для завершения):")
while True:
    number = float(input("Число: "))
    if number == 0:
        break
    total += number
    count += 1

print(f"Сумма чисел: {total}")
print(f"Количество чисел: {count}")
if count > 0:
    print(f"Среднее значение: {total / count:.2f}")

# #Задание 2: Поиск простых чисел
print("Простые числа от 2 до 50:")
for number in range(2, 51):
    is_prime = True
    for divisor in range(2, int(number ** 0.5) + 1):
        if number % divisor == 0:
            is_prime = False
            break
    if is_prime:
        print(number, end=" ")

# #Задание 3: Статистика текста
text = input("Введите текст: ")

# Количество символов
char_count = len(text)

# Количество слов
words = text.split()
word_count = len(words)

# Количество предложений (грубая оценка)
sentence_count = text.count('.') + text.count('!') + text.count('?')

print("\n=== Статистика текста ===")
print(f"Символов: {char_count}")
print(f"Слов: {word_count}")
print(f"Предложений: {sentence_count}")
print(f"Средняя длина слова: {char_count / word_count:.1f} символов" if word_count > 0 else "Нет слов")
```
Ключевые моменты:
```
while — когда количество итераций неизвестно
for — когда нужно перебрать известную последовательность
break — для досрочного выхода из цикла
continue — для пропуска итерации
else в циклах — выполняется при нормальном завершении
Всегда проверяйте, чтобы условие в while могло стать ложным
Логические переменные в условии цикла.
```
 «Логические переменные в условии цикла»

Тема: Логические переменные в условии цикла
```
Слайд 1: Теория — Логические переменные в условиях циклов
Логические переменные (флаги) — мощный инструмент для управления циклами
Позволяют создавать понятные и читаемые условия
Преимущества использования:
Улучшают читаемость кода
Позволяют разделить проверку условия и логику цикла
Упрощают сложные условия
Легко изменять логику работы цикла
Основные подходы:
Флаги для управления циклом while
Логические переменные в сложных условиях
Флаги-триггеры для изменения поведения
Комбинация нескольких флагов
```
Слайд 2: Пример 1 — Простые флаги в цикле while
Задача: Управление игровым циклом с помощью флагов.
```python
print("=== Игровой цикл с флагами ===")

# Инициализация флагов
game_running = True
player_alive = True
level_completed = False
current_level = 1

print("Игра началась!")
print(f"Уровень {current_level}")

while game_running:
    print(f"\n--- Уровень {current_level} ---")
    
    # Игровая логика
    action = input("Ваше действие (атака/бежать/выйти): ").lower()
    
    if action == "выйти":
        game_running = False
        print("Игра завершена.")
        
    elif action == "атака":
        print("Вы атаковали врага!")
        # Случайный исход боя
        import random
        if random.choice([True, False]):
            print("Победа! Уровень пройден.")
            level_completed = True
        else:
            print("Поражение! Игра окончена.")
            player_alive = False
            
    elif action == "бежать":
        print("Вы сбежали с уровня.")
        level_completed = True
        
    else:
        print("Неизвестное действие")
    
    # Проверка условий после итерации
    if not player_alive:
        print("\nИгра окончена! Вы проиграли.")
        game_running = False
        
    if level_completed:
        current_level += 1
        print(f"\nПереход на уровень {current_level}!")
        level_completed = False
        if current_level > 3:
            print("Поздравляем! Вы прошли все уровни!")
            game_running = False

print("Спасибо за игру!")
```
Вывод в консоли:
```bash
=== Игровой цикл с флагами ===
Игра началась!
Уровень 1

--- Уровень 1 ---
Ваше действие (атака/бежать/выйти): атака
Вы атаковали врага!
Победа! Уровень пройден.

Переход на уровень 2!

--- Уровень 2 ---
Ваше действие (атака/бежать/выйти): бежать
Вы сбежали с уровня.

Переход на уровень 3!

--- Уровень 3 ---
Ваше действие (атака/бежать/выйти): выйти
Игра завершена.
Спасибо за игру!
```
Слайд 3: Пример 2 — Комбинация флагов в сложных условиях
Задача: Система аутентификации с несколькими проверками.
```python
print("=== Система аутентификации ===")

# Инициализация флагов безопасности
is_authenticated = False
is_blocked = False
attempts_left = 3
max_attempts = 3
security_lock = False

correct_login = "admin"
correct_password = "secret123"

print("Добро пожаловать в систему!")

while not is_authenticated and not is_blocked and not security_lock:
    print(f"\nПопыток осталось: {attempts_left}")
    
    login = input("Логин: ")
    password = input("Пароль: ")
    
    # Проверка учетных данных
    login_correct = (login == correct_login)
    password_correct = (password == correct_password)
    
    if login_correct and password_correct:
        is_authenticated = True
        print("Успешная аутентификация! Добро пожаловать в систему.")
        
    else:
        attempts_left -= 1
        
        # Анализ ошибки
        if not login_correct and not password_correct:
            print("Ошибка: Неверный логин и пароль")
        elif not login_correct:
            print("Ошибка: Неверный логин")
        else:
            print("Ошибка: Неверный пароль")
        
        # Проверка блокировки
        if attempts_left <= 0:
            is_blocked = True
            print("Аккаунт заблокирован! Слишком много неудачных попыток.")
        
        # Проверка подозрительной активности
        if attempts_left == 1:
            suspicious = input("Обнаружена подозрительная активность. Продолжить? (да/нет): ").lower()
            if suspicious != 'да':
                security_lock = True
                print("Система заблокирована из соображений безопасности.")

# Дополнительные проверки после цикла
if is_blocked:
    print("\nОбратитесь к администратору для разблокировки.")
    
if security_lock:
    print("\nАктивирована защита от взлома.")

if is_authenticated:
    print("\nДоступ к системе разрешен.")
    # Дальнейшая логика работы в системе...
```
Вывод в консоли:
```bash
=== Система аутентификации ===
Добро пожаловать в систему!

Попыток осталось: 3
Логин: user
Пароль: 123
Ошибка: Неверный логин и пароль

Попыток осталось: 2
Логин: admin
Пароль: wrong
Ошибка: Неверный пароль

Попыток осталось: 1
Логин: admin
Пароль: secret123
Успешная аутентификация! Добро пожаловать в систему.

Доступ к системе разрешен.
```
Слайд 4: Пример 3 — Флаги для обработки данных
Задача: Анализ и обработка набора данных с использованием флагов.
```python
print("=== Анализ данных студентов ===")

students = [
    {"name": "Анна", "grades": [5, 4, 5, 3, 5]},
    {"name": "Борис", "grades": [3, 3, 2, 4, 3]},
    {"name": "Виктор", "grades": [4, 5, 4, 5, 4]},
    {"name": "Дарья", "grades": [2, 3, 2, 2, 3]},
    {"name": "Елена", "grades": [5, 5, 5, 5, 5]}
]

# Инициализация флагов анализа
has_excellent_students = False
has_failing_students = False
all_passed = True
found_problematic = False

print("Анализ успеваемости студентов:\n")

for student in students:
    name = student["name"]
    grades = student["grades"]
    
    # Расчет статистики
    average_grade = sum(grades) / len(grades)
    min_grade = min(grades)
    max_grade = max(grades)
    
    # Установка флагов на основе данных
    is_excellent = (min_grade >= 4 and average_grade >= 4.5)
    is_failing = any(grade < 3 for grade in grades)
    has_improvement_potential = (average_grade < 4.0 and max_grade >= 4)
    
    # Обновление общих флагов
    if is_excellent:
        has_excellent_students = True
    if is_failing:
        has_failing_students = True
    if is_failing:
        all_passed = False
    if has_improvement_potential:
        found_problematic = True
    
    # Вывод информации о студенте
    status = ""
    if is_excellent:
        status = "ОТЛИЧНИК"
    elif is_failing:
        status = "НЕУСПЕВАЮЩИЙ"
    elif has_improvement_potential:
        status = "ПОТЕНЦИАЛ"
    else:
        status = "СТАНДАРТ"
    
    print(f"{name}: средний балл {average_grade:.1f} [{status}]")

# Вывод общего анализа на основе флагов
print("\n=== ОБЩИЙ АНАЛИЗ ===")
print(f"Есть отличники: {has_excellent_students}")
print(f"Есть неуспевающие: {has_failing_students}")
print(f"Все сдали сессию: {all_passed}")
print(f"Есть студенты с потенциалом: {found_problematic}")

# Рекомендации на основе анализа
if has_failing_students:
    print("\nРЕКОМЕНДАЦИЯ: Организовать дополнительные занятия")
if has_excellent_students and not has_failing_students:
    print("\nРЕКОМЕНДАЦИЯ: Отличные результаты! Так держать!")
if found_problematic:
    print("\nРЕКОМЕНДАЦИЯ: Обратить внимание на студентов с потенциалом")
```
Вывод в консоли:
```bash
=== Анализ данных студентов ===
Анализ успеваемости студентов:

Анна: средний балл 4.4 [ПОТЕНЦИАЛ]
Борис: средний балл 3.0 [НЕУСПЕВАЮЩИЙ]
Виктор: средний балл 4.4 [ПОТЕНЦИАЛ]
Дарья: средний балл 2.4 [НЕУСПЕВАЮЩИЙ]
Елена: средний балл 5.0 [ОТЛИЧНИК]

=== ОБЩИЙ АНАЛИЗ ===
Есть отличники: True
Есть неуспевающие: True
Все сдали сессию: False
Есть студенты с потенциалом: True

РЕКОМЕНДАЦИЯ: Организовать дополнительные занятия
РЕКОМЕНДАЦИЯ: Обратить внимание на студентов с потенциалом
```
Слайд 5: Пример 4 — Флаги в цикле for с обработкой ошибок
Задача: Обработка пользовательского ввода с валидацией.
```python
print("=== Система регистрации пользователей ===")

# Данные для регистрации
users_data = []

# Флаги для управления процессом
registration_active = True
data_valid = False
errors_detected = False

print("Заполните данные для регистрации (для завершения введите 'выход'):")

while registration_active:
    user = {}
    
    print(f"\n--- Регистрация пользователя #{len(users_data) + 1} ---")
    
    # Ввод имени с валидацией
    name_valid = False
    while not name_valid:
        name = input("Имя: ")
        if name.lower() == 'выход':
            registration_active = False
            break
            
        if len(name) < 2:
            print("Ошибка: Имя должно содержать минимум 2 символа")
            errors_detected = True
        elif not name.isalpha():
            print("Ошибка: Имя должно содержать только буквы")
            errors_detected = True
        else:
            user['name'] = name
            name_valid = True
    
    if not registration_active:
        break
    
    # Ввод возраста с валидацией
    age_valid = False
    while not age_valid:
        age_input = input("Возраст: ")
        if not age_input.isdigit():
            print("Ошибка: Возраст должен быть числом")
            errors_detected = True
        else:
            age = int(age_input)
            if age < 18:
                print("Ошибка: Регистрация доступна с 18 лет")
                errors_detected = True
            elif age > 120:
                print("Ошибка: Некорректный возраст")
                errors_detected = True
            else:
                user['age'] = age
                age_valid = True
    
    # Ввод email с валидацией
    email_valid = False
    while not email_valid:
        email = input("Email: ")
        if '@' not in email or '.' not in email:
            print("Ошибка: Некорректный email")
            errors_detected = True
        else:
            user['email'] = email
            email_valid = True
    
    # Если все данные валидны, добавляем пользователя
    if name_valid and age_valid and email_valid:
        users_data.append(user)
        print(f"Пользователь {user['name']} успешно зарегистрирован!")
        data_valid = True
    
    # Предложение продолжить
    continue_reg = input("\nЗарегистрировать еще одного пользователя? (да/нет): ").lower()
    if continue_reg != 'да':
        registration_active = False

# Итоговый отчет
print(f"\n=== ИТОГИ РЕГИСТРАЦИИ ===")
print(f"Зарегистрировано пользователей: {len(users_data)}")
print(f"Обнаружено ошибок ввода: {errors_detected}")
print(f"Данные прошли валидацию: {data_valid}")

if users_data:
    print("\nЗарегистрированные пользователи:")
    for i, user in enumerate(users_data, 1):
        print(f"{i}. {user['name']}, {user['age']} лет, {user['email']}")
```
Вывод в консоли:
```bash
=== Система регистрации пользователей ===
Заполните данные для регистрации (для завершения введите 'выход'):

--- Регистрация пользователя #1 ---
Имя: Анна
Возраст: 25
Email: anna@mail.ru
Пользователь Анна успешно зарегистрирован!

Зарегистрировать еще одного пользователя? (да/нет): нет

=== ИТОГИ РЕГИСТРАЦИИ ===
Зарегистрировано пользователей: 1
Обнаружено ошибок ввода: False
Данные прошли валидацию: True

Зарегистрированные пользователи:
1. Анна, 25 лет, anna@mail.ru
```
Слайд 6: Задания для практики
Задание 1: Угадай число с подсказками
```python
# Напишите игру "Угадай число" с использованием флагов:
# - number_found: число угадано
# - too_many_attempts: превышено количество попыток  
# - give_hint: показывать подсказки
# - game_active: игра активна
# Программа должна давать подсказки "больше/меньше"
# Ваш код здесь
```
Задание 2: Анализатор текста
```python
# Напишите программу анализа текста с флагами:
# - has_digits: содержит цифры
# - has_uppercase: содержит заглавные буквы
# - has_special: содержит спецсимволы
# - is_secure: соответствует критериям безопасности
# Программа должна анализировать введенный текст
# Ваш код здесь
```
Задание 3: Система заказа в кафе
```python
# Напишите систему заказа с флагами:
# - order_complete: заказ завершен
# - payment_received: оплата получена
# - kitchen_notified: кухня уведомлена  
# - ready_to_serve: готово к подаче
# Симулируйте процесс от заказа до подачи
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Угадай число с подсказками
import random

print("=== Игра 'Угадай число' ===")
secret_number = random.randint(1, 100)
number_found = False
too_many_attempts = False
game_active = True
attempts = 0
max_attempts = 7

print("Я загадал число от 1 до 100. Угадай его!")

while game_active and not number_found and not too_many_attempts:
    attempts += 1
    guess = int(input(f"\nПопытка {attempts}. Введите число: "))
    
    if guess == secret_number:
        number_found = True
        print(f"Поздравляю! Вы угадали число {secret_number} за {attempts} попыток!")
    elif guess < secret_number:
        print("Загаданное число БОЛЬШЕ")
    else:
        print("Загаданное число МЕНЬШЕ")
    
    if attempts >= max_attempts and not number_found:
        too_many_attempts = True
        print(f"К сожалению, попытки закончились. Загаданное число было: {secret_number}")

# #Задание 2: Анализатор текста
print("=== Анализатор текста ===")

text = input("Введите текст для анализа: ")

has_digits = any(char.isdigit() for char in text)
has_uppercase = any(char.isupper() for char in text)
has_lowercase = any(char.islower() for char in text)
has_special = any(not char.isalnum() and not char.isspace() for char in text)
is_long_enough = len(text) >= 8
has_mixed_case = has_uppercase and has_lowercase

is_secure = (is_long_enough and has_digits and has_mixed_case and 
             (has_special or has_digits))

print("\n=== РЕЗУЛЬТАТЫ АНАЛИЗА ===")
print(f"Содержит цифры: {has_digits}")
print(f"Содержит заглавные буквы: {has_uppercase}")
print(f"Содержит строчные буквы: {has_lowercase}")
print(f"Содержит спецсимволы: {has_special}")
print(f"Достаточная длина: {is_long_enough}")
print(f"Соответствует критериям безопасности: {is_secure}")

# #Задание 3: Система заказа в кафе
print("=== Система заказа в кафе ===")

order_complete = False
payment_received = False
kitchen_notified = False
ready_to_serve = False
order_active = True

print("Добро пожаловать! Начнем оформление заказа.")

while order_active:
    if not order_complete:
        print("\n1. Выберите блюда из меню")
        print("2. Подтвердите заказ")
        choice = input("Ваш выбор: ")
        
        if choice == "2":
            order_complete = True
            print("Заказ подтвержден!")
    
    elif order_complete and not payment_received:
        print("\nОжидание оплаты...")
        payment = input("Оплата получена? (да/нет): ").lower()
        if payment == 'да':
            payment_received = True
            print("Оплата подтверждена!")
    
    elif payment_received and not kitchen_notified:
        print("\nУведомление кухни...")
        kitchen_notified = True
        print("Кухня приступила к приготовлению!")
    
    elif kitchen_notified and not ready_to_serve:
        print("\nПриготовление...")
        ready = input("Блюдо готово? (да/нет): ").lower()
        if ready == 'да':
            ready_to_serve = True
            print("Заказ готов к подаче!")
            order_active = False

print("\n=== ЗАКАЗ ЗАВЕРШЕН ===")
print("Приятного аппетита!")
```
Ключевые моменты:
```
Флаги делают код читаемым и понятным
Позволяют разделить сложные условия на простые компоненты
Упрощают отладку и модификацию кода
Можно комбинировать несколько флагов для сложной логики
Флаги особенно полезны в циклах с множественными условиями выхода
Методы и функции строк.
```
 «Методы и функции строк»
Тема: Методы и функции строк
```
Слайд 1: Теория — Методы и функции строк
Строка — неизменяемая последовательность символов
В Python строки имеют множество встроенных методов для работы с текстом
Основные категории методов:
Регистр: изменение регистра символов
Поиск: поиск подстрок и символов
Проверка: проверка содержимого строки
Модификация: замена, разделение, объединение
Форматирование: оформление вывода
Важно: Строки неизменяемы — методы возвращают новые строки!
```
Слайд 2: Пример 1 — Методы регистра и базовые проверки
Задача: Показать работу методов изменения регистра и проверки содержимого.
```python
print("=== Методы регистра и проверки ===")

text = "  Hello, World! Python Programming 2024  "
print(f"Исходная строка: '{text}'")

print("\n--- Методы регистра ---")
print(f"upper(): '{text.upper()}'")           # В верхний регистр
print(f"lower(): '{text.lower()}'")           # В нижний регистр
print(f"title(): '{text.title()}'")           # Каждое слово с заглавной
print(f"capitalize(): '{text.capitalize()}'") # Первая буква заглавная
print(f"swapcase(): '{text.swapcase()}'")     # Инвертировать регистр

print("\n--- Методы проверки ---")
print(f"isalpha(): '{text}'.isalpha() = {text.isalpha()}")
print(f"isdigit(): '{text}'.isdigit() = {text.isdigit()}")
print(f"isalnum(): '{text}'.isalnum() = {text.isalnum()}")
print(f"isspace(): '{text}'.isspace() = {text.isspace()}")

# Проверка частей строки
clean_text = "HelloPython"
print(f"\n'{clean_text}'.isalpha() = {clean_text.isalpha()}")
print(f"'12345'.isdigit() = {'12345'.isdigit()}")
print(f"'Hello123'.isalnum() = {'Hello123'.isalnum()}")

print("\n--- Удаление пробелов ---")
print(f"strip(): '{text.strip()}'")           # Удалить пробелы с обеих сторон
print(f"lstrip(): '{text.lstrip()}'")         # Удалить пробелы слева
print(f"rstrip(): '{text.rstrip()}'")         # Удалить пробелы справа
```
Вывод в консоли:
```bash
=== Методы регистра и проверки ===
Исходная строка: '  Hello, World! Python Programming 2024  '

--- Методы регистра ---
upper(): '  HELLO, WORLD! PYTHON PROGRAMMING 2024  '
lower(): '  hello, world! python programming 2024  '
title(): '  Hello, World! Python Programming 2024  '
capitalize(): '  hello, world! python programming 2024  '
swapcase(): '  hELLO, wORLD! pYTHON pROGRAMMING 2024  '

--- Методы проверки ---
isalpha(): '  Hello, World! Python Programming 2024  '.isalpha() = False
isdigit(): '  Hello, World! Python Programming 2024  '.isdigit() = False
isalnum(): '  Hello, World! Python Programming 2024  '.isalnum() = False
isspace(): '  Hello, World! Python Programming 2024  '.isspace() = False

'HelloPython'.isalpha() = True
'12345'.isdigit() = True
'Hello123'.isalnum() = True

--- Удаление пробелов ---
strip(): 'Hello, World! Python Programming 2024'
lstrip(): 'Hello, World! Python Programming 2024  '
rstrip(): '  Hello, World! Python Programming 2024'
```
Слайд 3: Пример 2 — Поиск и замена в строках
Задача: Показать методы поиска подстрок и замены содержимого.
```python
print("=== Поиск и замена в строках ===")

text = "Python is powerful. Python is easy. Python is fun!"
print(f"Исходный текст: '{text}'")

print("\n--- Методы поиска ---")
# find() - поиск с начала, возвращает индекс или -1
print(f"find('Python'): {text.find('Python')}")
print(f"find('Java'): {text.find('Java')}")
print(f"find('Python', 10): {text.find('Python', 10)}")  # Поиск с позиции 10

# rfind() - поиск с конца
print(f"rfind('Python'): {text.rfind('Python')}")

# index() - как find(), но вызывает ошибку если не найдено
print(f"index('is'): {text.index('is')}")

# count() - подсчет вхождений
print(f"count('Python'): {text.count('Python')}")
print(f"count('is'): {text.count('is')}")

print("\n--- Проверка начала и конца ---")
print(f"startswith('Python'): {text.startswith('Python')}")
print(f"startswith('powerful'): {text.startswith('powerful')}")
print(f"endswith('fun!'): {text.endswith('fun!')}")
print(f"endswith('easy.'): {text.endswith('easy.')}")

print("\n--- Методы замены ---")
# replace() - замена всех вхождений
new_text = text.replace('Python', 'Java')
print(f"replace('Python', 'Java'): '{new_text}'")

# Замена ограниченного количества вхождений
limited_replace = text.replace('is', 'IS', 2)
print(f"replace('is', 'IS', 2): '{limited_replace}'")

print("\n--- Практический пример: очистка текста ---")
dirty_text = "  ---Hello,,, World!!!...   "
clean = dirty_text.strip().replace('-', '').replace(',', '').replace('!', '').replace('.', '')
print(f"Исходный: '{dirty_text}'")
print(f"Очищенный: '{clean}'")
```
Вывод в консоли:
```bash
=== Поиск и замена в строках ===
Исходный текст: 'Python is powerful. Python is easy. Python is fun!'

--- Методы поиска ---
find('Python'): 0
find('Java'): -1
find('Python', 10): 20
rfind('Python'): 40
index('is'): 7
count('Python'): 3
count('is'): 3

--- Проверка начала и конца ---
startswith('Python'): True
startswith('powerful'): False
endswith('fun!'): True
endswith('easy.'): False

--- Методы замены ---
replace('Python', 'Java'): 'Java is powerful. Java is easy. Java is fun!'
replace('is', 'IS', 2): 'Python IS powerful. Python IS easy. Python is fun!'

--- Практический пример: очистка текста ---
Исходный: '  ---Hello,,, World!!!...   '
Очищенный: 'Hello World'
```
Слайд 4: Пример 3 — Разделение и объединение строк
Задача: Показать работу методов для разделения и сборки строк.
```python
print("=== Разделение и объединение строк ===")

# Исходные данные
csv_data = "John,25,Developer,New York"
paragraph = "Python is a programming language. It is easy to learn. It is powerful."
words_text = "apple banana cherry date elderberry"

print("Исходные строки:")
print(f"CSV: '{csv_data}'")
print(f"Текст: '{paragraph}'")
print(f"Слова: '{words_text}'")

print("\n--- Методы разделения ---")
# split() - разделение по пробелам по умолчанию
words = words_text.split()
print(f"split(): {words}")

# split() с указанием разделителя
csv_parts = csv_data.split(',')
print(f"split(','): {csv_parts}")

# split() с ограничением количества разбиений
limited_split = csv_data.split(',', 2)
print(f"split(',', 2): {limited_split}")

# splitlines() - разделение по строкам
multiline_text = "First line\nSecond line\nThird line"
lines = multiline_text.splitlines()
print(f"splitlines(): {lines}")

print("\n--- Методы объединения ---")
# join() - объединение списка в строку
fruits = ['apple', 'banana', 'cherry']
fruits_string = ', '.join(fruits)
print(f"join(', '): '{fruits_string}'")

numbers = ['1', '2', '3', '4', '5']
numbers_string = '-'.join(numbers)
print(f"join('-'): '{numbers_string}'")

# Объединение с разделителем-переносом строк
lines_joined = '\n'.join(['Line 1', 'Line 2', 'Line 3'])
print(f"join('\\n'):\n{lines_joined}")

print("\n--- Практический пример: обработка CSV ---")
print("Обработка данных сотрудника:")
name, age, job, city = csv_data.split(',')
print(f"Имя: {name.strip()}")
print(f"Возраст: {age.strip()}")
print(f"Должность: {job.strip()}")
print(f"Город: {city.strip()}")

print("\n--- Разделение предложений ---")
sentences = paragraph.split('. ')
print("Предложения:")
for i, sentence in enumerate(sentences, 1):
    if sentence:  # Пропускаем пустые строки
        print(f"{i}. {sentence}")
```
Вывод в консоли:
```bash
=== Разделение и объединение строк ===
Исходные строки:
CSV: 'John,25,Developer,New York'
Текст: 'Python is a programming language. It is easy to learn. It is powerful.'
Слова: 'apple banana cherry date elderberry'

--- Методы разделения ---
split(): ['apple', 'banana', 'cherry', 'date', 'elderberry']
split(','): ['John', '25', 'Developer', 'New York']
split(',', 2): ['John', '25', 'Developer,New York']
splitlines(): ['First line', 'Second line', 'Third line']

--- Методы объединения ---
join(', '): 'apple, banana, cherry'
join('-'): '1-2-3-4-5'
join('\n'):
Line 1
Line 2
Line 3

--- Практический пример: обработка CSV ---
Обработка данных сотрудника:
Имя: John
Возраст: 25
Должность: Developer
Город: New York

--- Разделение предложений ---
Предложения:
1. Python is a programming language.
2. It is easy to learn.
3. It is powerful.
```
Слайд 5: Пример 4 — Форматирование строк и полезные методы
Задача: Показать различные способы форматирования строк и дополнительные методы.
```python
print("=== Форматирование строк и полезные методы ===")

name = "Anna"
age = 25
salary = 75000.50

print("--- Старые способы форматирования ---")
# %-форматирование
message1 = "Имя: %s, Возраст: %d, Зарплата: %.2f" % (name, age, salary)
print(f"% formatting: {message1}")

# str.format()
message2 = "Имя: {}, Возраст: {}, Зарплата: {:.2f}".format(name, age, salary)
print(f"str.format(): {message2}")

message3 = "Имя: {n}, Возраст: {a}, Зарплата: {s:.2f}".format(n=name, a=age, s=salary)
print(f"named format: {message3}")

print("\n--- f-строки (рекомендуется) ---")
# f-strings (Python 3.6+)
message4 = f"Имя: {name}, Возраст: {age}, Зарплата: {salary:.2f}"
print(f"f-string: {message4}")

# Выражения в f-строках
message5 = f"Через 5 лет будет: {age + 5} лет"
print(f"f-string с выражением: {message5}")

print("\n--- Выравнивание текста ---")
text = "Python"
print(f"ljust(10): '{text.ljust(10)}'")    # Выравнивание по левому краю
print(f"rjust(10): '{text.rjust(10)}'")    # Выравнивание по правому краю  
print(f"center(10): '{text.center(10)}'")  # Выравнивание по центру
print(f"center(10, '-'): '{text.center(10, '-')}'")  # С заполнителем

print("\n--- Полезные методы ---")
# zfill() - заполнение нулями слева
number = "42"
print(f"zfill(5): '{number.zfill(5)}'")

# partition() - разделение на 3 части по первому вхождению
data = "key=value=extra"
part1, sep, part2 = data.partition('=')
print(f"partition('='): {part1}, {sep}, {part2}")

# expandtabs() - замена табуляций пробелами
tab_text = "Name\tAge\tCity"
print(f"expandtabs(): '{tab_text.expandtabs(10)}'")

print("\n--- Практический пример: генерация отчета ---")
employees = [
    {"name": "John Smith", "position": "Developer", "salary": 75000},
    {"name": "Anna Brown", "position": "Manager", "salary": 85000},
    {"name": "Tom Wilson", "position": "Analyst", "salary": 65000}
]

print("ОТЧЕТ ПО СОТРУДНИКАМ")
print("=" * 50)
print(f"{'Имя':<15} {'Должность':<12} {'Зарплата':>10}")
print("-" * 50)

for emp in employees:
    name = emp["name"][:14]  # Обрезаем если слишком длинное
    position = emp["position"][:11]
    salary = f"${emp['salary']:,.2f}"
    print(f"{name:<15} {position:<12} {salary:>10}")

print("=" * 50)
total_salary = sum(emp["salary"] for emp in employees)
print(f"{'ИТОГО:':<28} ${total_salary:>10,.2f}")
```
Вывод в консоли:
```bash
=== Форматирование строк и полезные методы ===
--- Старые способы форматирования ---
% formatting: Имя: Anna, Возраст: 25, Зарплата: 75000.50
str.format(): Имя: Anna, Возраст: 25, Зарплата: 75000.50
named format: Имя: Anna, Возраст: 25, Зарплата: 75000.50

--- f-строки (рекомендуется) ---
f-string: Имя: Anna, Возраст: 25, Зарплата: 75000.50
f-string с выражением: Через 5 лет будет: 30 лет

--- Выравнивание текста ---
ljust(10): 'Python    '
rjust(10): '    Python'
center(10): '  Python  '
center(10, '-'): '--Python--'

--- Полезные методы ---
zfill(5): '00042'
partition('='): key, =, value=extra
expandtabs(): 'Name      Age       City'

--- Практический пример: генерация отчета ---
ОТЧЕТ ПО СОТРУДНИКАМ
==================================================
Имя             Должность       Зарплата
--------------------------------------------------
John Smith      Developer       $75,000.00
Anna Brown      Manager         $85,000.00
Tom Wilson      Analyst         $65,000.00
==================================================
ИТОГО:                         $225,000.00
```
Слайд 6: Задания для практики
Задание 1: Валидатор email
```python
# Напишите программу для проверки email:
# 1. Должен содержать @ и точку после @
# 2. Домен не менее 2 символов
# 3. Локальная часть не пустая
# 4. Используйте методы строк для проверки
# Ваш код здесь
```
Задание 2: Анализатор текста
```python
# Напишите программу анализа текста:
# 1. Подсчитайте количество слов, предложений
# 2. Найдите самое длинное слово
# 3. Посчитайте частоту использования слов
# 4. Используйте split(), lower(), strip()
# Ваш код здесь
```
Задание 3: Генератор паролей
```python
# Напишите программу генерации паролей:
# 1. Минимум 8 символов
# 2. Должен содержать буквы в верхнем и нижнем регистре
# 3. Должен содержать цифры
# 4. Должен содержать спецсимволы
# 5. Используйте строковые методы для проверки
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Валидатор email
def validate_email(email):
    email = email.strip()
    
    # Проверка наличия @
    if '@' not in email:
        return False, "Email должен содержать @"
    
    # Разделение на локальную часть и домен
    local_part, domain = email.split('@', 1)
    
    # Проверка локальной части
    if not local_part:
        return False, "Локальная часть не может быть пустой"
    
    # Проверка домена
    if '.' not in domain:
        return False, "Домен должен содержать точку"
    
    domain_parts = domain.split('.')
    if len(domain_parts[-1]) < 2:
        return False, "Домен верхнего уровня должен быть не менее 2 символов"
    
    return True, "Email корректен"

# Тестирование
email = input("Введите email: ")
is_valid, message = validate_email(email)
print(message)

# #Задание 2: Анализатор текста
def analyze_text(text):
    # Очистка текста
    text = text.strip()
    
    # Подсчет предложений (грубая оценка)
    sentences = [s for s in text.split('.') if s.strip()]
    sentence_count = len(sentences)
    
    # Разделение на слова
    words = text.split()
    word_count = len(words)
    
    # Самое длинное слово
    longest_word = max(words, key=len) if words else ""
    
    # Частота слов
    word_freq = {}
    for word in words:
        clean_word = word.lower().strip('.,!?;:')
        if clean_word:
            word_freq[clean_word] = word_freq.get(clean_word, 0) + 1
    
    # Самые частые слова
    most_common = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:5]
    
    return {
        'word_count': word_count,
        'sentence_count': sentence_count,
        'longest_word': longest_word,
        'most_common': most_common
    }

# Тестирование
text = input("Введите текст для анализа: ")
results = analyze_text(text)
print(f"Слов: {results['word_count']}")
print(f"Предложений: {results['sentence_count']}")
print(f"Самое длинное слово: '{results['longest_word']}'")
print("Самые частые слова:", results['most_common'])

# #Задание 3: Генератор паролей
import random
import string

def generate_password(length=12):
    if length < 8:
        return "Пароль должен быть не менее 8 символов"
    
    # Наборы символов
    lowercase = string.ascii_lowercase
    uppercase = string.ascii_uppercase
    digits = string.digits
    special = "!@#$%^&*"
    
    # Гарантируем наличие всех типов символов
    password = [
        random.choice(lowercase),
        random.choice(uppercase),
        random.choice(digits),
        random.choice(special)
    ]
    
    # Заполняем остаток случайными символами
    all_chars = lowercase + uppercase + digits + special
    password.extend(random.choice(all_chars) for _ in range(length - 4))
    
    # Перемешиваем
    random.shuffle(password)
    
    return ''.join(password)

def validate_password(password):
    errors = []
    
    if len(password) < 8:
        errors.append("Менее 8 символов")
    
    if not any(c.islower() for c in password):
        errors.append("Нет строчных букв")
    
    if not any(c.isupper() for c in password):
        errors.append("Нет заглавных букв")
    
    if not any(c.isdigit() for c in password):
        errors.append("Нет цифр")
    
    if not any(c in "!@#$%^&*" for c in password):
        errors.append("Нет спецсимволов")
    
    return len(errors) == 0, errors

# Тестирование
password = generate_password()
print(f"Сгенерированный пароль: {password}")
is_valid, errors = validate_password(password)
print(f"Пароль валиден: {is_valid}")
if not is_valid:
    print("Ошибки:", errors)
```
Ключевые моменты:
```
Строки неизменяемы — методы возвращают новые строки
lower(), upper(), title() — для работы с регистром
find(), index(), count() — для поиска
replace() — для замены подстрок
split(), join() — для разделения и объединения
strip(), lstrip(), rstrip() — для удаления пробелов
startswith(), endswith() — для проверки начала/конца
f-строки — современный способ форматирования
Индексация и срезы.
```
 «Индексация и срезы»
Тема: Индексация и срезы
```
Слайд 1: Теория — Индексация и срезы
Индексация — обращение к отдельным элементам последовательности
Срезы — извлечение подпоследовательности из последовательности
Особенности в Python:
Индексация начинается с 0
Отрицательные индексы: отсчет с конца (-1 — последний элемент)
Срезы: [start:stop:step]
Работает со строками, списками, кортежами и другими последовательностями
```
Слайд 2: Пример 1 — Базовая индексация
Задача: Показать работу с положительными и отрицательными индексами.
```python
print("=== Базовая индексация ===")

text = "Python"
numbers = [10, 20, 30, 40, 50, 60, 70]

print(f"Строка: '{text}'")
print(f"Список: {numbers}")

print("\n--- Положительные индексы (слева направо) ---")
print("Строка:")
print(f"text[0] = '{text[0]}'")    # P
print(f"text[1] = '{text[1]}'")    # y
print(f"text[2] = '{text[2]}'")    # t
print(f"text[3] = '{text[3]}'")    # h
print(f"text[4] = '{text[4]}'")    # o
print(f"text[5] = '{text[5]}'")    # n

print("\nСписок:")
print(f"numbers[0] = {numbers[0]}")  # 10
print(f"numbers[2] = {numbers[2]}")  # 30
print(f"numbers[4] = {numbers[4]}")  # 50

print("\n--- Отрицательные индексы (справа налево) ---")
print("Строка:")
print(f"text[-1] = '{text[-1]}'")  # n (последний)
print(f"text[-2] = '{text[-2]}'")  # o (предпоследний)
print(f"text[-3] = '{text[-3]}'")  # h
print(f"text[-6] = '{text[-6]}'")  # P

print("\nСписок:")
print(f"numbers[-1] = {numbers[-1]}")  # 70 (последний)
print(f"numbers[-3] = {numbers[-3]}")  # 50
print(f"numbers[-7] = {numbers[-7]}")  # 10

print("\n--- Попытка обращения к несуществующему индексу ---")
try:
    print(f"text[10] = '{text[10]}'")
except IndexError as e:
    print(f"Ошибка: {e}")

try:
    print(f"numbers[-10] = {numbers[-10]}")
except IndexError as e:
    print(f"Ошибка: {e}")
```
Вывод в консоли:
```bash
=== Базовая индексация ===
Строка: 'Python'
Список: [10, 20, 30, 40, 50, 60, 70]

--- Положительные индексы (слева направо) ---
Строка:
text[0] = 'P'
text[1] = 'y'
text[2] = 't'
text[3] = 'h'
text[4] = 'o'
text[5] = 'n'

Список:
numbers[0] = 10
numbers[2] = 30
numbers[4] = 50

--- Отрицательные индексы (справа налево) ---
Строка:
text[-1] = 'n'
text[-2] = 'o'
text[-3] = 'h'
text[-6] = 'P'

Список:
numbers[-1] = 70
numbers[-3] = 50
numbers[-7] = 10

--- Попытка обращения к несуществующему индексу ---
Ошибка: string index out of range
Ошибка: list index out of range
```
Слайд 3: Пример 2 — Базовые срезы
Задача: Показать работу срезов с разными параметрами.
```python
print("=== Базовые срезы ===")

text = "Программирование на Python"
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(f"Строка: '{text}'")
print(f"Список: {numbers}")

print("\n--- Синтаксис среза: [start:stop:step] ---")
print("start - начало среза (включительно)")
print("stop - конец среза (не включительно)")
print("step - шаг (по умолчанию 1)")

print("\n--- Простые срезы ---")
print(f"text[0:10] = '{text[0:10]}'")        # С 0 по 9 индекс
print(f"text[5:15] = '{text[5:15]}'")        # С 5 по 14 индекс
print(f"numbers[2:7] = {numbers[2:7]}")      # С 2 по 6 индекс

print("\n--- Срезы с опущенными границами ---")
print(f"text[:8] = '{text[:8]}'")            # С начала до 7 индекса
print(f"text[12:] = '{text[12:]}'")          # С 12 индекса до конца
print(f"text[:] = '{text[:]}'")              # Вся строка (копия)
print(f"numbers[5:] = {numbers[5:]}")        # С 5 до конца
print(f"numbers[:5] = {numbers[:5]}")        # С начала до 4

print("\n--- Отрицательные индексы в срезах ---")
print(f"text[-6:] = '{text[-6:]}'")          # Последние 6 символов
print(f"text[:-10] = '{text[:-10]}'")        # Все кроме последних 10
print(f"numbers[-4:-1] = {numbers[-4:-1]}")  # С -4 до -2

print("\n--- Сравнение с индексацией ---")
print("Индексация возвращает элемент:")
print(f"text[5] = '{text[5]}'")
print("Срез возвращает подпоследовательность:")
print(f"text[5:6] = '{text[5:6]}'")
```
Вывод в консоли:
```bash
=== Базовые срезы ===
Строка: 'Программирование на Python'
Список: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

--- Синтаксис среза: [start:stop:step] ---
start - начало среза (включительно)
stop - конец среза (не включительно)
step - шаг (по умолчанию 1)

--- Простые срезы ---
text[0:10] = 'Программир'
text[5:15] = 'ммирование '
numbers[2:7] = [2, 3, 4, 5, 6]

--- Срезы с опущенными границами ---
text[:8] = 'Программ'
text[12:] = 'ние на Python'
text[:] = 'Программирование на Python'
numbers[5:] = [5, 6, 7, 8, 9]
numbers[:5] = [0, 1, 2, 3, 4]

--- Отрицательные индексы в срезах ---
text[-6:] = 'Python'
text[:-10] = 'Программирован'
numbers[-4:-1] = [6, 7, 8]

--- Сравнение с индексацией ---
Индексация возвращает элемент:
text[5] = 'а'
Срез возвращает подпоследовательность:
text[5:6] = 'а'
```
Слайд 4: Пример 3 — Срезы с шагом и расширенные возможности
Задача: Показать работу срезов с шагом и специальные случаи.
```python
print("=== Срезы с шагом и расширенные возможности ===")

text = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
numbers = list(range(20))

print(f"Алфавит: '{text}'")
print(f"Числа: {numbers}")

print("\n--- Срезы с шагом (step) ---")
print(f"text[::2] = '{text[::2]}'")          # Каждый второй символ
print(f"text[1::2] = '{text[1::2]}'")        # Каждый второй, начиная с 1
print(f"numbers[::3] = {numbers[::3]}")      # Каждое третье число

print("\n--- Отрицательный шаг (реверс) ---")
print(f"text[::-1] = '{text[::-1]}'")        # Обратный порядок
print(f"text[::-2] = '{text[::-2]}'")        # Каждый второй в обратном порядке
print(f"numbers[::-1] = {numbers[::-1]}")    # Реверс списка

print("\n--- Комбинированные срезы ---")
print(f"text[5:15:2] = '{text[5:15:2]}'")    # С 5 до 14, каждый второй
print(f"text[20:10:-1] = '{text[20:10:-1]}'") # С 20 до 11 в обратном порядке
print(f"text[10:0:-2] = '{text[10:0:-2]}'")  # С 10 до 1, каждый второй в обратном

print("\n--- Специальные случаи ---")
print("Пустые срезы:")
print(f"text[10:5] = '{text[10:5]}'")        # Пустая строка (start > stop)
print(f"numbers[15:10] = {numbers[15:10]}")  # Пустой список

print("\n--- Практические примеры ---")
# Извлечение четных и нечетных чисел
even_numbers = numbers[::2]
odd_numbers = numbers[1::2]
print(f"Четные: {even_numbers}")
print(f"Нечетные: {odd_numbers}")

# Разделение строки на части
email = "user@example.com"
username = email[:email.index('@')]
domain = email[email.index('@')+1:]
print(f"Email: {email}")
print(f"Имя пользователя: {username}")
print(f"Домен: {domain}")

# Извлечение последних элементов
last_three = numbers[-3:]
print(f"Последние три: {last_three}")
```
Вывод в консоли:
```bash
=== Срезы с шагом и расширенные возможности ===
Алфавит: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
Числа: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

--- Срезы с шагом (step) ---
text[::2] = 'ACEGIKMOQSUWY'
text[1::2] = 'BDFHJLNPRTVXZ'
numbers[::3] = [0, 3, 6, 9, 12, 15, 18]

--- Отрицательный шаг (реверс) ---
text[::-1] = 'ZYXWVUTSRQPONMLKJIHGFEDCBA'
text[::-2] = 'ZXVTRPNLJHFDB'
numbers[::-1] = [19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

--- Комбинированные срезы ---
text[5:15:2] = 'FHJLN'
text[20:10:-1] = 'UTSRQPONMLK'
text[10:0:-2] = 'KIGEC'

--- Специальные случаи ---
Пустые срезы:
text[10:5] = ''
numbers[15:10] = []

--- Практические примеры ---
Четные: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
Нечетные: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Email: user@example.com
Имя пользователя: user
Домен: example.com
Последние три: [17, 18, 19]
```
Слайд 5: Пример 4 — Практическое применение
Задача: Показать реальные примеры использования индексации и срезов.
```python
print("=== Практическое применение ===")

print("\n--- Обработка файловых путей ---")
file_path = "/home/user/documents/report.pdf"

# Извлечение компонентов пути
filename = file_path[file_path.rfind('/')+1:]
extension = filename[filename.rfind('.')+1:]
name_without_ext = filename[:filename.rfind('.')]
directory = file_path[:file_path.rfind('/')]

print(f"Полный путь: {file_path}")
print(f"Имя файла: {filename}")
print(f"Расширение: {extension}")
print(f"Имя без расширения: {name_without_ext}")
print(f"Директория: {directory}")

print("\n--- Анализ даты ---")
date_string = "2024-12-19"

# Разбор даты на компоненты
year = date_string[:4]
month = date_string[5:7]
day = date_string[8:]

print(f"Дата: {date_string}")
print(f"Год: {year}")
print(f"Месяц: {month}")
print(f"День: {day}")

print("\n--- Обработка текста ---")
sentence = "Быстрая коричневая лиса прыгает через ленивую собаку"

# Разные способы извлечения слов
first_word = sentence[:sentence.find(' ')]
last_word = sentence[sentence.rfind(' ')+1:]
words = sentence.split()
middle_words = ' '.join(words[1:-1])  # Все слова кроме первого и последнего

print(f"Предложение: '{sentence}'")
print(f"Первое слово: '{first_word}'")
print(f"Последнее слово: '{last_word}'")
print(f"Средние слова: '{middle_words}'")

print("\n--- Работа с цифрами ---")
phone_number = "+7 (912) 345-67-89"

# Очистка номера телефона
clean_number = phone_number.replace('+', '').replace('(', '').replace(')', '').replace(' ', '').replace('-', '')
country_code = clean_number[:1]
operator_code = clean_number[1:4]
main_number = clean_number[4:]

print(f"Исходный номер: {phone_number}")
print(f"Очищенный номер: {clean_number}")
print(f"Код страны: {country_code}")
print(f"Код оператора: {operator_code}")
print(f"Основной номер: {main_number}")

print("\n--- Шифрование Цезаря ---")
def caesar_cipher(text, shift):
    result = ""
    for char in text:
        if char.isalpha():
            # Определяем базовый символ (A или a)
            base = ord('A') if char.isupper() else ord('a')
            # Сдвигаем символ и обеспечиваем циклический сдвиг
            shifted = (ord(char) - base + shift) % 26
            result += chr(base + shifted)
        else:
            result += char
    return result

original = "Hello, World!"
encrypted = caesar_cipher(original, 3)
decrypted = caesar_cipher(encrypted, -3)

print(f"Оригинал: '{original}'")
print(f"Зашифровано (сдвиг 3): '{encrypted}'")
print(f"Расшифровано: '{decrypted}'")
```
Вывод в консоли:
```bash
=== Практическое применение ===

--- Обработка файловых путей ---
Полный путь: /home/user/documents/report.pdf
Имя файла: report.pdf
Расширение: pdf
Имя без расширения: report
Директория: /home/user/documents

--- Анализ даты ---
Дата: 2024-12-19
Год: 2024
Месяц: 12
День: 19

--- Обработка текста ---
Предложение: 'Быстрая коричневая лиса прыгает через ленивую собаку'
Первое слово: 'Быстрая'
Последнее слово: 'собаку'
Средние слова: 'коричневая лиса прыгает через ленивую'

--- Работа с цифрами ---
Исходный номер: +7 (912) 345-67-89
Очищенный номер: 79123456789
Код страны: 7
Код оператора: 912
Основной номер: 3456789

--- Шифрование Цезаря ---
Оригинал: 'Hello, World!'
Зашифровано (сдвиг 3): 'Khoor, Zruog!'
Расшифровано: 'Hello, World!'
```
Слайд 6: Задания для практики
Задание 1: Реверс слов в предложении
```python
# Напишите функцию, которая переворачивает слова в предложении
# Пример: "hello world" -> "world hello"
# Используйте срезы и методы строк
# Ваш код здесь
```
Задание 2: Валидатор номера карты
```python
# Напишите функцию для проверки номера банковской карты
# Правила: 
# - Должен содержать 16 цифр
# - Могут быть пробелы или дефисы каждые 4 цифры
# - Извлеките только цифры и проверьте длину
# - Выделите первые 4 цифры (префикс)
# Ваш код здесь
```
Задание 3: Генератор аббревиатур
```python
# Напишите функцию, которая создает аббревиатуру из фразы
# Пример: "Соединенные Штаты Америки" -> "США"
# Берет первые буквы каждого слова и объединяет в верхнем регистре
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Реверс слов в предложении
def reverse_words(sentence):
    words = sentence.split()
    reversed_words = words[::-1]
    return ' '.join(reversed_words)

# Тестирование
test_sentence = "Python программирование это интересно"
result = reverse_words(test_sentence)
print(f"Исходное: '{test_sentence}'")
print(f"Результат: '{result}'")

# #Задание 2: Валидатор номера карты
def validate_card_number(card_number):
    # Удаляем все нецифровые символы
    clean_number = ''.join(char for char in card_number if char.isdigit())
    
    # Проверяем длину
    if len(clean_number) != 16:
        return False, f"Неверная длина: {len(clean_number)} цифр вместо 16"
    
    # Извлекаем префикс
    prefix = clean_number[:4]
    
    # Проверяем по алгоритму Луна (упрощенная версия)
    is_valid = True  # Здесь можно добавить реальную проверку
    
    return True, f"Номер валиден. Префикс: {prefix}"

# Тестирование
card_numbers = [
    "1234-5678-9012-3456",
    "1234 5678 9012 3456",
    "1234567890123456",
    "1234-5678-9012-345",  # Неверная длина
]

for card in card_numbers:
    is_valid, message = validate_card_number(card)
    print(f"'{card}' -> {message}")

# #Задание 3: Генератор аббревиатур
def generate_acronym(phrase):
    words = phrase.split()
    acronym = ''.join(word[0] for word in words if word)  # Берем первую букву каждого слова
    return acronym.upper()

# Тестирование
phrases = [
    "Соединенные Штаты Америки",
    "Национальное управление по аэронавтике и исследованию космического пространства",
    "Процессор центральный",
    "random access memory"
]

for phrase in phrases:
    acronym = generate_acronym(phrase)
    print(f"'{phrase}' -> '{acronym}'")
```
Ключевые моменты:
```
Индексация: sequence[index] — доступ к одному элементу
Срезы: sequence[start:stop:step] — доступ к подпоследовательности
Положительные индексы: слева направо (0-based)
Отрицательные индексы: справа налево (-1 — последний)
start включительно, stop исключительно
Шаг может быть отрицательным для реверса
Срезы всегда возвращают новую последовательность
Выход за границы при срезах не вызывает ошибок (возвращают пустую последовательность)
Методы и функции списков.
```
 «Методы и функции списков»
Тема: Методы и функции списков
```
Слайд 1: Теория — Методы и функции списков
Список — изменяемая упорядоченная коллекция элементов
В Python списки имеют богатый набор методов для манипуляции данными
Основные категории методов:
Добавление элементов: append(), extend(), insert()
Удаление элементов: remove(), pop(), clear()
Поиск и информация: index(), count(), len()
Сортировка и порядок: sort(), reverse(), sorted()
Копирование: copy(), list(), [:]
Математические операции: sum(), min(), max()
```
Слайд 2: Пример 1 — Добавление элементов в список
Задача: Показать различные способы добавления элементов в список.
```python
print("=== Добавление элементов в список ===")

# Создаем начальные списки
fruits = ["яблоко", "банан"]
numbers = [1, 2, 3]
mixed = [10, "текст", 3.14]

print(f"Начальный список fruits: {fruits}")
print(f"Начальный список numbers: {numbers}")
print(f"Начальный список mixed: {mixed}")

print("\n--- Метод append() ---")
# append() - добавление одного элемента в конец
fruits.append("апельсин")
numbers.append(4)
mixed.append(True)

print(f"После append(): {fruits}")
print(f"После append(): {numbers}")
print(f"После append(): {mixed}")

print("\n--- Метод extend() ---")
# extend() - добавление нескольких элементов (расширение списка)
new_fruits = ["киви", "манго"]
fruits.extend(new_fruits)
numbers.extend([5, 6, 7])

print(f"После extend(): {fruits}")
print(f"После extend(): {numbers}")

print("\n--- Метод insert() ---")
# insert() - вставка элемента на определенную позицию
fruits.insert(1, "груша")  # Вставка на позицию 1 (второй элемент)
numbers.insert(0, 0)       # Вставка в начало
fruits.insert(-1, "виноград")  # Вставка перед последним элементом

print(f"После insert(): {fruits}")
print(f"После insert(): {numbers}")

print("\n--- Конкатенация списков ---")
# Сложение списков (создает новый список)
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined = list1 + list2
print(f"list1 + list2 = {combined}")
print(f"Исходный list1: {list1}")  # Не изменился

print("\n--- Сравнение append() и extend() ---")
test_list1 = [1, 2, 3]
test_list2 = [1, 2, 3]

test_list1.append([4, 5])    # Добавляет список как один элемент
test_list2.extend([4, 5])    # Добавляет элементы из списка

print(f"append([4, 5]): {test_list1}")  # [1, 2, 3, [4, 5]]
print(f"extend([4, 5]): {test_list2}")  # [1, 2, 3, 4, 5]
```
Вывод в консоли:
```bash
=== Добавление элементов в список ===
Начальный список fruits: ['яблоко', 'банан']
Начальный список numbers: [1, 2, 3]
Начальный список mixed: [10, 'текст', 3.14]

--- Метод append() ---
После append(): ['яблоко', 'банан', 'апельсин']
После append(): [1, 2, 3, 4]
После append(): [10, 'текст', 3.14, True]

--- Метод extend() ---
После extend(): ['яблоко', 'банан', 'апельсин', 'киви', 'манго']
После extend(): [1, 2, 3, 4, 5, 6, 7]

--- Метод insert() ---
После insert(): ['яблоко', 'груша', 'банан', 'апельсин', 'киви', 'виноград', 'манго']
После insert(): [0, 1, 2, 3, 4, 5, 6, 7]

--- Конкатенация списков ---
list1 + list2 = [1, 2, 3, 4, 5, 6]
Исходный list1: [1, 2, 3]

--- Сравнение append() и extend() ---
append([4, 5]): [1, 2, 3, [4, 5]]
extend([4, 5]): [1, 2, 3, 4, 5]
```
Слайд 3: Пример 2 — Удаление элементов из списка
Задача: Показать различные способы удаления элементов из списка.
```python
print("=== Удаление элементов из списка ===")

# Создаем списки для демонстрации
numbers = [10, 20, 30, 40, 50, 30, 60, 70, 30]
fruits = ["яблоко", "банан", "апельсин", "киви", "манго"]
mixed = [1, "текст", 3.14, True, "текст"]

print(f"Исходный numbers: {numbers}")
print(f"Исходный fruits: {fruits}")
print(f"Исходный mixed: {mixed}")

print("\n--- Метод remove() ---")
# remove() - удаляет первое вхождение элемента
numbers.remove(30)
mixed.remove("текст")

print(f"После remove(30): {numbers}")
print(f"После remove('текст'): {mixed}")

print("\n--- Метод pop() ---")
# pop() - удаляет и возвращает элемент по индексу
removed_fruit = fruits.pop(2)      # Удаляет третий элемент
removed_last = fruits.pop()        # Удаляет последний элемент
removed_number = numbers.pop(0)    # Удаляет первый элемент

print(f"Удаленные элементы: '{removed_fruit}', '{removed_last}', {removed_number}")
print(f"После pop(): {fruits}")
print(f"После pop(): {numbers}")

print("\n--- Оператор del ---")
# del - удаление по индексу или срезу
del numbers[1]           # Удаляет второй элемент
del mixed[2:4]           # Удаляет срез (элементы 2 и 3)

print(f"После del: {numbers}")
print(f"После del: {mixed}")

print("\n--- Метод clear() ---")
# clear() - полная очистка списка
temp_list = [1, 2, 3, 4, 5]
print(f"До clear(): {temp_list}")
temp_list.clear()
print(f"После clear(): {temp_list}")

print("\n--- Удаление всех вхождений элемента ---")
# Удаление всех вхождений числа 30
while 30 in numbers:
    numbers.remove(30)

print(f"После удаления всех 30: {numbers}")

print("\n--- Сравнение remove() и pop() ---")
test_list = ["A", "B", "C", "D"]

# remove() - по значению, не возвращает удаленный элемент
test_list.remove("B")
print(f"После remove('B'): {test_list}")

# pop() - по индексу, возвращает удаленный элемент
element = test_list.pop(1)
print(f"После pop(1): {test_list}, удален: '{element}'")
```
Вывод в консоли:
```bash
=== Удаление элементов из списка ===
Исходный numbers: [10, 20, 30, 40, 50, 30, 60, 70, 30]
Исходный fruits: ['яблоко', 'банан', 'апельсин', 'киви', 'манго']
Исходный mixed: [1, 'текст', 3.14, True, 'текст']

--- Метод remove() ---
После remove(30): [10, 20, 40, 50, 30, 60, 70, 30]
После remove('текст'): [1, 3.14, True, 'текст']

--- Метод pop() ---
Удаленные элементы: 'апельсин', 'манго', 10
После pop(): ['яблоко', 'банан', 'киви']
После pop(): [20, 40, 50, 30, 60, 70, 30]

--- Оператор del ---
После del: [20, 50, 30, 60, 70, 30]
После del: [1, 3.14]

--- Метод clear() ---
До clear(): [1, 2, 3, 4, 5]
После clear(): []

--- Удаление всех вхождений элемента ---
После удаления всех 30: [20, 50, 60, 70]

--- Сравнение remove() и pop() ---
После remove('B'): ['A', 'C', 'D']
После pop(1): ['A', 'D'], удален: 'C'
```
Слайд 4: Пример 3 — Поиск и информация о списках
Задача: Показать методы для получения информации о списках.
```python
print("=== Поиск и информация о списках ===")

# Создаем списки для демонстрации
numbers = [5, 2, 8, 2, 1, 9, 2, 7, 2]
fruits = ["яблоко", "банан", "апельсин", "киви", "банан"]
mixed = [10, "hello", 3.14, True, "hello"]

print(f"numbers: {numbers}")
print(f"fruits: {fruits}")
print(f"mixed: {mixed}")

print("\n--- Метод index() ---")
# index() - поиск индекса элемента
print(f"index(8) в numbers: {numbers.index(8)}")
print(f"index('киви') в fruits: {fruits.index('киви')}")
print(f"index('hello') в mixed: {mixed.index('hello')}")

# Поиск с указанием начальной позиции
print(f"index(2, 3) в numbers: {numbers.index(2, 3)}")  # Поиск с позиции 3
print(f"index('банан', 2) в fruits: {fruits.index('банан', 2)}")

print("\n--- Метод count() ---")
# count() - подсчет количества вхождений
print(f"count(2) в numbers: {numbers.count(2)}")
print(f"count('банан') в fruits: {fruits.count('банан')}")
print(f"count('hello') в mixed: {mixed.count('hello')}")
print(f"count(99) в numbers: {numbers.count(99)}")  # Несуществующий элемент

print("\n--- Функция len() ---")
# len() - длина списка
print(f"len(numbers): {len(numbers)}")
print(f"len(fruits): {len(fruits)}")
print(f"len(mixed): {len(mixed)}")
print(f"len([]): {len([])}")  # Пустой список

print("\n--- Проверка наличия элемента (in) ---")
# Оператор in - проверка наличия элемента
print(f"8 in numbers: {8 in numbers}")
print(f"99 in numbers: {99 in numbers}")
print(f"'яблоко' in fruits: {'яблоко' in fruits}")
print(f"'виноград' in fruits: {'виноград' in fruits}")

print("\n--- Функции min(), max(), sum() ---")
# Работают только с числовыми списками
numeric_list = [5, 2, 8, 1, 9, 3]
print(f"numeric_list: {numeric_list}")
print(f"min(numeric_list): {min(numeric_list)}")
print(f"max(numeric_list): {max(numeric_list)}")
print(f"sum(numeric_list): {sum(numeric_list)}")

print("\n--- Практический пример: анализ данных ---")
grades = [4, 5, 3, 4, 5, 2, 5, 4, 3, 5, 4, 5, 3, 4]

print(f"Оценки: {grades}")
print(f"Всего оценок: {len(grades)}")
print(f"Средний балл: {sum(grades) / len(grades):.2f}")
print(f"Лучшая оценка: {max(grades)}")
print(f"Худшая оценка: {min(grades)}")
print(f"Количество пятерок: {grades.count(5)}")
print(f"Количество двоек: {grades.count(2)}")

# Поиск первой двойки
if 2 in grades:
    first_bad_index = grades.index(2)
    print(f"Первая двойка на позиции: {first_bad_index}")
else:
    print("Двоек нет!")
```
Вывод в консоли:
```bash
=== Поиск и информация о списках ===
numbers: [5, 2, 8, 2, 1, 9, 2, 7, 2]
fruits: ['яблоко', 'банан', 'апельсин', 'киви', 'банан']
mixed: [10, 'hello', 3.14, True, 'hello']

--- Метод index() ---
index(8) в numbers: 2
index('киви') в fruits: 3
index('hello') в mixed: 1
index(2, 3) в numbers: 3
index('банан', 2) в fruits: 4

--- Метод count() ---
count(2) в numbers: 4
count('банан') в fruits: 2
count('hello') в mixed: 2
count(99) в numbers: 0

--- Функция len() ---
len(numbers): 9
len(fruits): 5
len(mixed): 5
len([]): 0

--- Проверка наличия элемента (in) ---
8 in numbers: True
99 in numbers: False
'яблоко' in fruits: True
'виноград' in fruits: False

--- Функции min(), max(), sum() ---
numeric_list: [5, 2, 8, 1, 9, 3]
min(numeric_list): 1
max(numeric_list): 9
sum(numeric_list): 28

--- Практический пример: анализ данных ---
Оценки: [4, 5, 3, 4, 5, 2, 5, 4, 3, 5, 4, 5, 3, 4]
Всего оценок: 14
Средний балл: 4.07
Лучшая оценка: 5
Худшая оценка: 2
Количество пятерок: 5
Количество двоек: 1
Первая двойка на позиции: 5
```
Слайд 5: Пример 4 — Сортировка и копирование списков
Задача: Показать методы сортировки и различные способы копирования списков.
```python
print("=== Сортировка и копирование списков ===")

# Создаем списки для демонстрации
numbers = [5, 2, 8, 1, 9, 3, 7, 4, 6]
fruits = ["яблоко", "банан", "апельсин", "киви", "виноград"]
words = ["Python", "java", "C++", "JavaScript", "ruby"]

print(f"Исходный numbers: {numbers}")
print(f"Исходный fruits: {fruits}")
print(f"Исходный words: {words}")

print("\n--- Метод sort() ---")
# sort() - сортировка на месте (изменяет исходный список)
numbers.sort()
fruits.sort()
words.sort()  # Сортировка с учетом регистра

print(f"После sort() numbers: {numbers}")
print(f"После sort() fruits: {fruits}")
print(f"После sort() words: {words}")

print("\n--- Сортировка в обратном порядке ---")
numbers.sort(reverse=True)
fruits.sort(reverse=True)

print(f"Обратная сортировка numbers: {numbers}")
print(f"Обратная сортировка fruits: {fruits}")

print("\n--- Функция sorted() ---")
# sorted() - возвращает новый отсортированный список
unsorted = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_list = sorted(unsorted)
sorted_reverse = sorted(unsorted, reverse=True)

print(f"Исходный: {unsorted}")
print(f"sorted(): {sorted_list}")
print(f"sorted(reverse=True): {sorted_reverse}")
print(f"Исходный не изменился: {unsorted}")

print("\n--- Метод reverse() ---")
# reverse() - обратный порядок на месте
test_list = [1, 2, 3, 4, 5]
print(f"До reverse(): {test_list}")
test_list.reverse()
print(f"После reverse(): {test_list}")

print("\n--- Копирование списков ---")
original = [1, 2, 3, [4, 5]]

# Поверхностное копирование
copy1 = original.copy()        # Метод copy()
copy2 = list(original)         # Функция list()
copy3 = original[:]            # Срез

# Глубокое копирование (для вложенных списков)
import copy
deep_copy = copy.deepcopy(original)

print(f"Оригинал: {original}")
print(f"copy(): {copy1}")
print(f"list(): {copy2}")
print(f"[:]: {copy3}")
print(f"deepcopy(): {deep_copy}")

print("\n--- Изменение копий ---")
# Изменяем вложенный список в оригинале
original[3].append(6)

print("После изменения вложенного списка:")
print(f"Оригинал: {original}")
print(f"copy(): {copy1}")        # Изменилась!
print(f"list(): {copy2}")        # Изменилась!
print(f"[:]: {copy3}")           # Изменилась!
print(f"deepcopy(): {deep_copy}")  # Не изменилась!

print("\n--- Сортировка сложных структур ---")
students = [
    ("Анна", 4.5),
    ("Борис", 3.8),
    ("Виктор", 4.2),
    ("Дарья", 4.8)
]

# Сортировка по среднему баллу (второй элемент кортежа)
students.sort(key=lambda x: x[1], reverse=True)
print("Студенты по убыванию баллов:")
for name, grade in students:
    print(f"  {name}: {grade}")
```
Вывод в консоли:
```bash
=== Сортировка и копирование списков ===
Исходный numbers: [5, 2, 8, 1, 9, 3, 7, 4, 6]
Исходный fruits: ['яблоко', 'банан', 'апельсин', 'киви', 'виноград']
Исходный words: ['Python', 'java', 'C++', 'JavaScript', 'ruby']

--- Метод sort() ---
После sort() numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9]
После sort() fruits: ['апельсин', 'банан', 'виноград', 'киви', 'яблоко']
После sort() words: ['C++', 'JavaScript', 'Python', 'java', 'ruby']

--- Сортировка в обратном порядке ---
Обратная сортировка numbers: [9, 8, 7, 6, 5, 4, 3, 2, 1]
Обратная сортировка fruits: ['яблоко', 'киви', 'виноград', 'банан', 'апельсин']

--- Функция sorted() ---
Исходный: [3, 1, 4, 1, 5, 9, 2, 6]
sorted(): [1, 1, 2, 3, 4, 5, 6, 9]
sorted(reverse=True): [9, 6, 5, 4, 3, 2, 1, 1]
Исходный не изменился: [3, 1, 4, 1, 5, 9, 2, 6]

--- Метод reverse() ---
До reverse(): [1, 2, 3, 4, 5]
После reverse(): [5, 4, 3, 2, 1]

--- Копирование списков ---
Оригинал: [1, 2, 3, [4, 5]]
copy(): [1, 2, 3, [4, 5]]
list(): [1, 2, 3, [4, 5]]
[:]: [1, 2, 3, [4, 5]]
deepcopy(): [1, 2, 3, [4, 5]]

--- Изменение копий ---
После изменения вложенного списка:
Оригинал: [1, 2, 3, [4, 5, 6]]
copy(): [1, 2, 3, [4, 5, 6]]
list(): [1, 2, 3, [4, 5, 6]]
[:]: [1, 2, 3, [4, 5, 6]]
deepcopy(): [1, 2, 3, [4, 5]]

--- Сортировка сложных структур ---
Студенты по убыванию баллов:
  Дарья: 4.8
  Анна: 4.5
  Виктор: 4.2
  Борис: 3.8
```
Слайд 6: Задания для практики
Задание 1: Управление списком задач
```python
# Напишите программу для управления списком задач:
# 1. Добавление задачи
# 2. Удаление задачи по названию
# 3. Отметка задачи как выполненной
# 4. Показать все задачи
# Используйте методы списков
# Ваш код здесь
```
Задание 2: Анализатор оценок
```python
# Напишите программу анализа оценок:
# 1. Удалить самые высокие и низкие оценки
# 2. Посчитать средний балл
# 3. Найти наиболее частую оценку
# 4. Отсортировать оценки
# Используйте sort(), remove(), count(), sum()
# Ваш код здесь
```
Задание 3: Обработка данных пользователей
```python
# Напишите программу обработки данных:
# 1. Разделить полные имена на имя и фамилию
# 2. Отсортировать по фамилии
# 3. Удалить дубликаты
# 4. Создать список email на основе имен
# Используйте различные методы списков
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Управление списком задач
def todo_manager():
    tasks = []
    
    while True:
        print("\n=== Менеджер задач ===")
        print("1. Добавить задачу")
        print("2. Удалить задачу")
        print("3. Показать задачи")
        print("4. Выход")
        
        choice = input("Выберите действие: ")
        
        if choice == "1":
            task = input("Введите задачу: ")
            tasks.append(task)
            print(f"Задача '{task}' добавлена!")
            
        elif choice == "2":
            if not tasks:
                print("Список задач пуст!")
                continue
                
            print("Текущие задачи:")
            for i, task in enumerate(tasks, 1):
                print(f"{i}. {task}")
                
            task_name = input("Введите задачу для удаления: ")
            if task_name in tasks:
                tasks.remove(task_name)
                print(f"Задача '{task_name}' удалена!")
            else:
                print("Задача не найдена!")
                
        elif choice == "3":
            if not tasks:
                print("Список задач пуст!")
            else:
                print("Текущие задачи:")
                for i, task in enumerate(tasks, 1):
                    print(f"{i}. {task}")
                    
        elif choice == "4":
            print("Выход из программы!")
            break
            
        else:
            print("Неверный выбор!")

# #Задание 2: Анализатор оценок
def analyze_grades(grades):
    if len(grades) < 3:
        return "Недостаточно оценок для анализа"
    
    # Создаем копию чтобы не изменять оригинал
    grades_copy = grades.copy()
    
    # Удаляем самую высокую и самую низкую оценку
    grades_copy.remove(max(grades_copy))
    grades_copy.remove(min(grades_copy))
    
    # Считаем статистику
    average = sum(grades_copy) / len(grades_copy)
    
    # Находим наиболее частую оценку
    most_common = max(set(grades_copy), key=grades_copy.count)
    
    # Сортируем
    grades_copy.sort()
    
    return {
        'filtered_grades': grades_copy,
        'average': average,
        'most_common': most_common,
        'original_count': len(grades),
        'filtered_count': len(grades_copy)
    }

# Тестирование
grades = [5, 4, 3, 5, 2, 4, 5, 3, 4, 5]
result = analyze_grades(grades)
print(f"Исходные оценки: {grades}")
print(f"После фильтрации: {result['filtered_grades']}")
print(f"Средний балл: {result['average']:.2f}")
print(f"Наиболее частая оценка: {result['most_common']}")

# #Задание 3: Обработка данных пользователей
def process_users(full_names):
    # Удаляем дубликаты
    unique_names = list(set(full_names))
    
    # Разделяем на имена и фамилии
    first_names = []
    last_names = []
    
    for name in unique_names:
        parts = name.split()
        if len(parts) >= 2:
            first_names.append(parts[0])
            last_names.append(parts[1])
    
    # Сортируем по фамилии
    sorted_names = sorted(unique_names, key=lambda x: x.split()[-1])
    
    # Создаем email
    emails = []
    for name in unique_names:
        parts = name.split()
        if len(parts) >= 2:
            email = f"{parts[0].lower()}.{parts[1].lower()}@company.com"
            emails.append(email)
    
    return {
        'unique_names': unique_names,
        'sorted_names': sorted_names,
        'first_names': first_names,
        'last_names': last_names,
        'emails': emails
    }

# Тестирование
users = ["Иван Иванов", "Анна Петрова", "Петр Сидоров", 
         "Мария Иванова", "Иван Иванов", "Анна Петрова"]
result = process_users(users)
print(f"Уникальные имена: {result['unique_names']}")
print(f"Отсортировано по фамилии: {result['sorted_names']}")
print(f"Email адреса: {result['emails']}")
```
Ключевые моменты:
```
append() — добавить один элемент в конец
extend() — добавить несколько элементов
insert() — вставить элемент по индексу
remove() — удалить по значению
pop() — удалить по индексу и вернуть элемент
sort() — сортировка на месте
sorted() — возвращает новый отсортированный список
copy() — поверхностное копирование
index(), count() — поиск информации
Списки изменяемы — методы изменяют оригинальный список
Кортежи.
```
 «Кортежи»
Тема: Кортежи (tuple)
```
Слайд 1: Теория — Кортежи
Кортеж — неизменяемая упорядоченная коллекция элементов
Обозначаются круглыми скобками: (1, 2, 3)
Могут содержать элементы разных типов
Поддерживают индексацию и срезы как списки
Неизменяемы — нельзя добавлять, удалять или изменять элементы
Преимущества кортежей:
Занимают меньше памяти чем списки
Безопасность данных (защита от изменений)
Могут быть ключами в словарях
Используются для возврата нескольких значений из функций
```
Слайд 2: Пример 1 — Создание и базовые операции
Задача: Показать различные способы создания кортежей и базовые операции.
```python
print("=== Создание и базовые операции с кортежами ===")

print("\n--- Способы создания кортежей ---")
# Пустой кортеж
empty_tuple = ()
print(f"Пустой кортеж: {empty_tuple}")

# Кортеж с одним элементом (нужна запятая!)
single_element = (42,)
print(f"Кортеж с одним элементом: {single_element}")

# Обычный кортеж
numbers = (1, 2, 3, 4, 5)
print(f"Кортеж чисел: {numbers}")

# Кортеж разных типов
mixed = (10, "hello", 3.14, True)
print(f"Смешанный кортеж: {mixed}")

# Без скобок (кортеж через запятую)
no_parentheses = 1, 2, 3
print(f"Кортеж без скобок: {no_parentheses}")

# Функция tuple()
from_list = tuple([1, 2, 3])
from_string = tuple("Python")
print(f"Из списка: {from_list}")
print(f"Из строки: {from_string}")

print("\n--- Индексация и срезы ---")
data = (10, 20, 30, 40, 50, 60, 70)
print(f"Кортеж: {data}")

print(f"data[0] = {data[0]}")        # Первый элемент
print(f"data[-1] = {data[-1]}")      # Последний элемент
print(f"data[2:5] = {data[2:5]}")    # Срез
print(f"data[::2] = {data[::2]}")    # С шагом 2
print(f"data[::-1] = {data[::-1]}")  # Реверс

print("\n--- Операции с кортежами ---")
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)

print(f"tuple1 + tuple2 = {tuple1 + tuple2}")  # Конкатенация
print(f"tuple1 * 3 = {tuple1 * 3}")            # Повторение
print(f"len(tuple1) = {len(tuple1)}")          # Длина
print(f"3 in tuple1 = {3 in tuple1}")          # Проверка наличия

print("\n--- Неизменяемость кортежей ---")
test_tuple = (1, 2, 3)
print(f"Исходный кортеж: {test_tuple}")

# Попытка изменить элемент вызовет ошибку
try:
    test_tuple[0] = 100
except TypeError as e:
    print(f"Ошибка при изменении: {e}")

# Но можно создать новый кортеж
new_tuple = (100,) + test_tuple[1:]
print(f"Новый кортеж: {new_tuple}")
```
Вывод в консоли:
```bash
=== Создание и базовые операции с кортежами ===

--- Способы создания кортежей ---
Пустой кортеж: ()
Кортеж с одним элементом: (42,)
Кортеж чисел: (1, 2, 3, 4, 5)
Смешанный кортеж: (10, 'hello', 3.14, True)
Кортеж без скобок: (1, 2, 3)
Из списка: (1, 2, 3)
Из строки: ('P', 'y', 't', 'h', 'o', 'n')

--- Индексация и срезы ---
Кортеж: (10, 20, 30, 40, 50, 60, 70)
data[0] = 10
data[-1] = 70
data[2:5] = (30, 40, 50)
data[::2] = (10, 30, 50, 70)
data[::-1] = (70, 60, 50, 40, 30, 20, 10)

--- Операции с кортежами ---
tuple1 + tuple2 = (1, 2, 3, 4, 5, 6)
tuple1 * 3 = (1, 2, 3, 1, 2, 3, 1, 2, 3)
len(tuple1) = 3
3 in tuple1 = True

--- Неизменяемость кортежей ---
Исходный кортеж: (1, 2, 3)
Ошибка при изменении: 'tuple' object does not support item assignment
Новый кортеж: (100, 2, 3)
```
Слайд 3: Пример 2 — Методы кортежей и распаковка
Задача: Показать методы кортежей и распаковку значений.
```python
print("=== Методы кортежей и распаковка ===")

# Создаем кортежи для демонстрации
numbers = (5, 2, 8, 2, 1, 9, 2, 7, 2)
fruits = ("яблоко", "банан", "апельсин", "киви", "банан")
coordinates = (10, 20, 30)

print(f"numbers: {numbers}")
print(f"fruits: {fruits}")
print(f"coordinates: {coordinates}")

print("\n--- Методы кортежей ---")
# count() - подсчет вхождений элемента
print(f"numbers.count(2) = {numbers.count(2)}")
print(f"fruits.count('банан') = {fruits.count('банан')}")
print(f"fruits.count('виноград') = {fruits.count('виноград')}")

# index() - поиск индекса элемента
print(f"numbers.index(8) = {numbers.index(8)}")
print(f"fruits.index('киви') = {fruits.index('киви')}")
print(f"numbers.index(2, 3) = {numbers.index(2, 3)}")  # Поиск с позиции 3

print("\n--- Распаковка кортежей ---")
# Простая распаковка
x, y, z = coordinates
print(f"Распаковка: x={x}, y={y}, z={z}")

# Распаковка с игнорированием элементов
point = (100, 200, 300)
a, b, _ = point  # Игнорируем третий элемент
print(f"Игнорирование: a={a}, b={b}")

# Распаковка с оператором *
data = (1, 2, 3, 4, 5, 6)
first, *middle, last = data
print(f"Расширенная распаковка: first={first}, middle={middle}, last={last}")

# Обмен значений через кортежи
var1, var2 = 10, 20
print(f"До обмена: var1={var1}, var2={var2}")
var1, var2 = var2, var1  # Обмен через кортеж
print(f"После обмена: var1={var1}, var2={var2}")

print("\n--- Использование в циклах ---")
# Кортежи в цикле for
points = [(1, 2), (3, 4), (5, 6), (7, 8)]

print("Координаты точек:")
for x, y in points:
    print(f"  x={x}, y={y}")

# enumerate() возвращает кортежи (индекс, значение)
print("\nИндексы и значения:")
for index, fruit in enumerate(fruits):
    print(f"  {index}: {fruit}")

print("\n--- Сравнение со списками ---")
import sys

tuple_size = (1, 2, 3, 4, 5)
list_size = [1, 2, 3, 4, 5]

print(f"Кортеж: {tuple_size}")
print(f"Список: {list_size}")
print(f"Размер кортежа в памяти: {sys.getsizeof(tuple_size)} байт")
print(f"Размер списка в памяти: {sys.getsizeof(list_size)} байт")
```
Вывод в консоли:
```bash
=== Методы кортежей и распаковка ===
numbers: (5, 2, 8, 2, 1, 9, 2, 7, 2)
fruits: ('яблоко', 'банан', 'апельсин', 'киви', 'банан')
coordinates: (10, 20, 30)

--- Методы кортежей ---
numbers.count(2) = 4
fruits.count('банан') = 2
fruits.count('виноград') = 0
numbers.index(8) = 2
fruits.index('киви') = 3
numbers.index(2, 3) = 3

--- Распаковка кортежей ---
Распаковка: x=10, y=20, z=30
Игнорирование: a=100, b=200
Расширенная распаковка: first=1, middle=[2, 3, 4, 5], last=6
До обмена: var1=10, var2=20
После обмена: var1=20, var2=10

--- Использование в циклах ---
Координаты точек:
  x=1, y=2
  x=3, y=4
  x=5, y=6
  x=7, y=8

Индексы и значения:
  0: яблоко
  1: банан
  2: апельсин
  3: киви
  4: банан

--- Сравнение со списками ---
Кортеж: (1, 2, 3, 4, 5)
Список: [1, 2, 3, 4, 5]
Размер кортежа в памяти: 80 байт
Размер списка в памяти: 104 байт
```
Слайд 4: Пример 3 — Практическое применение кортежей
Задача: Показать реальные примеры использования кортежей.
```python
print("=== Практическое применение кортежей ===")

print("\n--- Возврат нескольких значений из функции ---")
def calculate_stats(numbers):
    """Возвращает статистику по списку чисел"""
    if not numbers:
        return None
    return min(numbers), max(numbers), sum(numbers) / len(numbers)

data = [10, 20, 30, 40, 50]
stats = calculate_stats(data)
print(f"Данные: {data}")
print(f"Статистика: мин={stats[0]}, макс={stats[1]}, среднее={stats[2]:.2f}")

# Распаковка результата
min_val, max_val, avg_val = calculate_stats(data)
print(f"Распаковано: min={min_val}, max={max_val}, avg={avg_val:.2f}")

print("\n--- Кортежи как ключи словаря ---")
# Координаты как ключи для хранения данных на карте
world_map = {
    (0, 0): "Начало пути",
    (1, 0): "Лес",
    (1, 1): "Горы", 
    (2, 1): "Озеро",
    (2, 2): "Город"
}

print("Карта мира:")
for coord, location in world_map.items():
    print(f"  Координаты {coord}: {location}")

# Поиск по координатам
search_coord = (1, 1)
if search_coord in world_map:
    print(f"На координатах {search_coord} находится: {world_map[search_coord]}")

print("\n--- Хранение констант ---")
# Кортежи для хранения неизменяемых констант
COLORS = (
    "RED", "GREEN", "BLUE", "YELLOW", 
    "BLACK", "WHITE", "PURPLE", "ORANGE"
)

DAYS_OF_WEEK = (
    "Понедельник", "Вторник", "Среда", 
    "Четверг", "Пятница", "Суббота", "Воскресенье"
)

print(f"Доступные цвета: {COLORS}")
print(f"Дни недели: {DAYS_OF_WEEK}")
print(f"Первый день недели: {DAYS_OF_WEEK[0]}")
print(f"Количество цветов: {len(COLORS)}")

print("\n--- Работа с базой данных (имитация) ---")
def get_user_info(user_id):
    """Имитация получения данных пользователя из БД"""
    # В реальности здесь был бы SQL-запрос
    users = {
        1: ("Анна", "Иванова", 25, "anna@mail.ru"),
        2: ("Петр", "Петров", 30, "petr@mail.ru"),
        3: ("Мария", "Сидорова", 22, "maria@mail.ru")
    }
    return users.get(user_id, ("Неизвестно", "Неизвестно", 0, "нет"))

user_id = 2
name, surname, age, email = get_user_info(user_id)
print(f"Данные пользователя ID {user_id}:")
print(f"  Имя: {name} {surname}")
print(f"  Возраст: {age}")
print(f"  Email: {email}")

print("\n--- Сортировка с кортежами ---")
students = [
    ("Анна", 4.5, 2023),
    ("Борис", 3.8, 2022),
    ("Виктор", 4.2, 2023),
    ("Дарья", 4.8, 2022)
]

# Сортировка по среднему баллу (убывание)
sorted_by_grade = sorted(students, key=lambda x: x[1], reverse=True)
print("Студенты по убыванию баллов:")
for name, grade, year in sorted_by_grade:
    print(f"  {name}: {grade}")

# Сортировка по году, затем по баллу
sorted_complex = sorted(students, key=lambda x: (x[2], x[1]), reverse=True)
print("\nСтуденты по году и баллу:")
for name, grade, year in sorted_complex:
    print(f"  {name}: балл {grade}, год {year}")
```
Вывод в консоли:
```bash
=== Практическое применение кортежей ===

--- Возврат нескольких значений из функции ---
Данные: [10, 20, 30, 40, 50]
Статистика: мин=10, макс=50, среднее=30.00
Распаковано: min=10, max=50, avg=30.00

--- Кортежи как ключи словаря ---
Карта мира:
  Координаты (0, 0): Начало пути
  Координаты (1, 0): Лес
  Координаты (1, 1): Горы
  Координаты (2, 1): Озеро
  Координаты (2, 2): Город
На координатах (1, 1) находится: Горы

--- Хранение констант ---
Доступные цвета: ('RED', 'GREEN', 'BLUE', 'YELLOW', 'BLACK', 'WHITE', 'PURPLE', 'ORANGE')
Дни недели: ('Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье')
Первый день недели: Понедельник
Количество цветов: 8

--- Работа с базой данных (имитация) ---
Данные пользователя ID 2:
  Имя: Петр Петров
  Возраст: 30
  Email: petr@mail.ru

--- Сортировка с кортежами ---
Студенты по убыванию баллов:
  Дарья: 4.8
  Анна: 4.5
  Виктор: 4.2
  Борис: 3.8

Студенты по году и баллу:
  Анна: балл 4.5, год 2023
  Виктор: балл 4.2, год 2023
  Дарья: балл 4.8, год 2022
  Борис: балл 3.8, год 2022
```
Слайд 5: Пример 4 — Вложенные кортежи и преобразования
Задача: Показать работу с вложенными кортежами и преобразования типов.
```python
print("=== Вложенные кортежи и преобразования ===")

print("\n--- Вложенные кортежи ---")
# Кортежи могут содержать другие кортежи
complex_data = (
    ("Иван", 25, "инженер"),
    ("Анна", 30, "менеджер"),
    ("Петр", 22, "аналитик"),
    ("Мария", 28, "разработчик")
)

print("Сотрудники:")
for person in complex_data:
    name, age, position = person
    print(f"  {name}, {age} лет, {position}")

# Доступ к вложенным элементам
print(f"\nПервый сотрудник: {complex_data[0]}")
print(f"Имя первого сотрудника: {complex_data[0][0]}")
print(f"Возраст второго сотрудника: {complex_data[1][1]}")

print("\n--- Многоуровневые кортежи ---")
# Координаты в 3D пространстве с цветом
shapes = (
    ((0, 0, 0), (10, 10, 10), "красный"),
    ((5, 5, 5), (15, 15, 15), "синий"),
    ((10, 10, 10), (20, 20, 20), "зеленый")
)

print("Фигуры в 3D:")
for shape in shapes:
    start, end, color = shape
    x1, y1, z1 = start
    x2, y2, z2 = end
    print(f"  От ({x1},{y1},{z1}) до ({x2},{y2},{z2}), цвет: {color}")

print("\n--- Преобразование между кортежами и списками ---")
# Кортеж -> Список
tuple_data = (1, 2, 3, 4, 5)
list_data = list(tuple_data)
print(f"Кортеж: {tuple_data}")
print(f"Список: {list_data}")

# Изменяем список
list_data.append(6)
list_data[0] = 100
print(f"Измененный список: {list_data}")

# Список -> Кортеж
new_tuple = tuple(list_data)
print(f"Новый кортеж: {new_tuple}")

print("\n--- Сравнение кортежей ---")
# Кортежи сравниваются поэлементно
tuple1 = (1, 2, 3)
tuple2 = (1, 2, 4)
tuple3 = (1, 2, 3)

print(f"{tuple1} == {tuple3}: {tuple1 == tuple3}")
print(f"{tuple1} == {tuple2}: {tuple1 == tuple2}")
print(f"{tuple1} < {tuple2}: {tuple1 < tuple2}")  # 3 < 4
print(f"{tuple2} > {tuple1}: {tuple2 > tuple1}")

# Сравнение разных длин
print(f"(1, 2) < (1, 2, 3): {(1, 2) < (1, 2, 3)}")

print("\n--- Практический пример: система координат ---")
def calculate_distance(point1, point2):
    """Вычисление расстояния между двумя точками в 2D"""
    x1, y1 = point1
    x2, y2 = point2
    distance = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
    return distance

def get_midpoint(point1, point2):
    """Нахождение средней точки"""
    x1, y1 = point1
    x2, y2 = point2
    midpoint = ((x1 + x2) / 2, (y1 + y2) / 2)
    return midpoint

# Использование
point_a = (0, 0)
point_b = (3, 4)

distance = calculate_distance(point_a, point_b)
midpoint = get_midpoint(point_a, point_b)

print(f"Точка A: {point_a}")
print(f"Точка B: {point_b}")
print(f"Расстояние: {distance:.2f}")
print(f"Средняя точка: {midpoint}")
```
Вывод в консоли:
```bash
=== Вложенные кортежи и преобразования ===

--- Вложенные кортежи ---
Сотрудники:
  Иван, 25 лет, инженер
  Анна, 30 лет, менеджер
  Петр, 22 лет, аналитик
  Мария, 28 лет, разработчик

Первый сотрудник: ('Иван', 25, 'инженер')
Имя первого сотрудника: Иван
Возраст второго сотрудника: 30

--- Многоуровневые кортежи ---
Фигуры в 3D:
  От (0,0,0) до (10,10,10), цвет: красный
  От (5,5,5) до (15,15,15), цвет: синий
  От (10,10,10) до (20,20,20), цвет: зеленый

--- Преобразование между кортежами и списками ---
Кортеж: (1, 2, 3, 4, 5)
Список: [1, 2, 3, 4, 5]
Измененный список: [100, 2, 3, 4, 5, 6]
Новый кортеж: (100, 2, 3, 4, 5, 6)

--- Сравнение кортежей ---
(1, 2, 3) == (1, 2, 3): True
(1, 2, 3) == (1, 2, 4): False
(1, 2, 3) < (1, 2, 4): True
(1, 2, 4) > (1, 2, 3): True
(1, 2) < (1, 2, 3): True

--- Практический пример: система координат ---
Точка A: (0, 0)
Точка B: (3, 4)
Расстояние: 5.00
Средняя точка: (1.5, 2.0)
```
Слайд 6: Задания для практики
Задание 1: Система координат
```python
# Напишите функции для работы с точками:
# 1. Функция создания точки (x, y)
# 2. Функция вычисления расстояния между точками
# 3. Функция отражения точки относительно оси
# 4. Используйте кортежи для хранения координат
# Ваш код здесь
```
Задание 2: Обработка данных студентов
```python
# Напишите программу для работы со студентами:
# 1. Хранить данные в кортежах (имя, балл, год)
# 2. Найти студента с максимальным баллом
# 3. Посчитать средний балл
# 4. Отсортировать студентов по году и баллу
# Ваш код здесь
```
Задание 3: Конвертер цветов
```python
# Напишите программу для работы с RGB-цветами:
# 1. Хранить цвета в кортежах (R, G, B)
# 2. Конвертировать в HEX формат
# 3. Смешивать два цвета
# 4. Находить противоположный цвет
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Система координат
def create_point(x, y):
    return (x, y)

def distance_between_points(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5

def reflect_point(point, axis):
    x, y = point
    if axis == 'x':
        return (x, -y)
    elif axis == 'y':
        return (-x, y)
    else:
        return point

# Тестирование
p1 = create_point(0, 0)
p2 = create_point(3, 4)
print(f"Точка 1: {p1}")
print(f"Точка 2: {p2}")
print(f"Расстояние: {distance_between_points(p1, p2):.2f}")
print(f"Отражение p1 по X: {reflect_point(p1, 'x')}")

# #Задание 2: Обработка данных студентов
students = [
    ("Анна", 4.5, 2023),
    ("Борис", 3.8, 2022),
    ("Виктор", 4.2, 2023),
    ("Дарья", 4.8, 2022),
    ("Елена", 4.0, 2023)
]

def find_top_student(students):
    return max(students, key=lambda x: x[1])

def average_grade(students):
    total = sum(grade for _, grade, _ in students)
    return total / len(students)

def sort_students(students):
    return sorted(students, key=lambda x: (x[2], x[1]), reverse=True)

# Тестирование
top_student = find_top_student(students)
avg = average_grade(students)
sorted_students = sort_students(students)

print(f"Лучший студент: {top_student[0]} с баллом {top_student[1]}")
print(f"Средний балл: {avg:.2f}")
print("Отсортированные студенты:")
for name, grade, year in sorted_students:
    print(f"  {name}: {grade} ({year})")

# #Задание 3: Конвертер цветов
def rgb_to_hex(rgb):
    r, g, b = rgb
    return f"#{r:02x}{g:02x}{b:02x}".upper()

def mix_colors(color1, color2):
    r1, g1, b1 = color1
    r2, g2, b2 = color2
    return ((r1 + r2) // 2, (g1 + g2) // 2, (b1 + b2) // 2)

def complementary_color(color):
    r, g, b = color
    return (255 - r, 255 - g, 255 - b)

# Тестирование
red = (255, 0, 0)
blue = (0, 0, 255)
green = (0, 255, 0)

print(f"Красный в HEX: {rgb_to_hex(red)}")
print(f"Синий в HEX: {rgb_to_hex(blue)}")
mixed = mix_colors(red, blue)
print(f"Смешанный красный и синий: {mixed} -> {rgb_to_hex(mixed)}")
comp_red = complementary_color(red)
print(f"Противоположный красному: {comp_red} -> {rgb_to_hex(comp_red)}")
```
Ключевые моменты:
```
Кортежи неизменяемы — нельзя изменить после создания
Создание: (), tuple(), (1,) (запятая для одного элемента)
Методы: только count() и index()
Распаковка: a, b, c = my_tuple
Использование: возврат нескольких значений, ключи словарей, константы
Преимущества: меньше памяти, безопасность данных, хешируемость
Преобразование: tuple(list), list(tuple)
Множества.
```
 «Множества»
Тема: Множества (set)
```
Слайд 1: Теория — Множества
Множество — неупорядоченная коллекция уникальных элементов

Обозначаются фигурными скобками: {1, 2, 3}

Содержат только уникальные элементы (дубликаты удаляются)

Не поддерживают индексацию (нет порядка)

Изменяемы (можно добавлять и удалять элементы)

Основные характеристики:

Быстрые операции проверки принадлежности

Поддержка математических операций над множествами

Элементы должны быть хешируемыми (неизменяемыми типами)

```
Слайд 2: Пример 1 — Создание и базовые операции
Задача: Показать различные способы создания множеств и базовые операции.
```python
print("=== Создание и базовые операции с множествами ===")

print("\n--- Способы создания множеств ---")
# Пустое множество (нельзя использовать {})
empty_set = set()
print(f"Пустое множество: {empty_set}")

# Множество из элементов
numbers = {1, 2, 3, 4, 5}
print(f"Множество чисел: {numbers}")

# Множество автоматически удаляет дубликаты
with_duplicates = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4}
print(f"С дубликатами: {1, 2, 2, 3, 3, 3, 4, 4, 4, 4}")
print(f"Без дубликатов: {with_duplicates}")

# Множество из строки (уникальные символы)
chars = set("программирование")
print(f"Множество из строки: {chars}")

# Множество из списка
from_list = set([1, 2, 3, 2, 1, 4, 5])
print(f"Множество из списка: {from_list}")

print("\n--- Базовые операции ---")
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}

print(f"set_a: {set_a}")
print(f"set_b: {set_b}")

print(f"Длина set_a: {len(set_a)}")
print(f"Проверка 3 in set_a: {3 in set_a}")
print(f"Проверка 9 in set_a: {9 in set_a}")

print("\n--- Добавление и удаление элементов ---")
test_set = {1, 2, 3}
print(f"Начальное множество: {test_set}")

# add() - добавление одного элемента
test_set.add(4)
test_set.add(2)  # Дубликат не добавится
print(f"После add(4), add(2): {test_set}")

# update() - добавление нескольких элементов
test_set.update([5, 6, 7])
test_set.update({8, 9})
print(f"После update([5,6,7]), update({{8,9}}): {test_set}")

# remove() - удаление элемента (ошибка если нет)
test_set.remove(3)
print(f"После remove(3): {test_set}")

# discard() - удаление элемента (без ошибки если нет)
test_set.discard(10)  # Нет ошибки
test_set.discard(4)
print(f"После discard(10), discard(4): {test_set}")

# pop() - удаление случайного элемента
removed = test_set.pop()
print(f"После pop(): {test_set}, удален: {removed}")

# clear() - очистка множества
test_set.clear()
print(f"После clear(): {test_set}")
```
Вывод в консоли:
```bash
=== Создание и базовые операции с множествами ===

--- Способы создания множеств ---
Пустое множество: set()
Множество чисел: {1, 2, 3, 4, 5}
С дубликатами: {1, 2, 3, 4}
Без дубликатов: {1, 2, 3, 4}
Множество из строки: {'а', 'в', 'г', 'е', 'и', 'м', 'н', 'о', 'п', 'р'}
Множество из списка: {1, 2, 3, 4, 5}

--- Базовые операции ---
set_a: {1, 2, 3, 4, 5}
set_b: {4, 5, 6, 7, 8}
Длина set_a: 5
Проверка 3 in set_a: True
Проверка 9 in set_a: False

--- Добавление и удаление элементов ---
Начальное множество: {1, 2, 3}
После add(4), add(2): {1, 2, 3, 4}
После update([5,6,7]), update({8,9}): {1, 2, 3, 4, 5, 6, 7, 8, 9}
После remove(3): {1, 2, 4, 5, 6, 7, 8, 9}
После discard(10), discard(4): {1, 2, 5, 6, 7, 8, 9}
После pop(): {2, 5, 6, 7, 8, 9}, удален: 1
После clear(): set()
```
Слайд 3: Пример 2 — Операции над множествами
Задача: Показать математические операции над множествами.
```python
print("=== Операции над множествами ===")

set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}
set_c = {3, 4, 5}

print(f"set_a: {set_a}")
print(f"set_b: {set_b}")
print(f"set_c: {set_c}")

print("\n--- Объединение (union) ---")
# Все элементы из обоих множеств
union_ab = set_a | set_b
union_method = set_a.union(set_b)
print(f"set_a | set_b: {union_ab}")
print(f"set_a.union(set_b): {union_method}")

print("\n--- Пересечение (intersection) ---")
# Только общие элементы
intersection_ab = set_a & set_b
intersection_method = set_a.intersection(set_b)
print(f"set_a & set_b: {intersection_ab}")
print(f"set_a.intersection(set_b): {intersection_method}")

print("\n--- Разность (difference) ---")
# Элементы в A, но не в B
difference_ab = set_a - set_b
difference_method = set_a.difference(set_b)
print(f"set_a - set_b: {difference_ab}")
print(f"set_a.difference(set_b): {difference_method}")

# Разность B - A
difference_ba = set_b - set_a
print(f"set_b - set_a: {difference_ba}")

print("\n--- Симметрическая разность (symmetric difference) ---")
# Элементы которые в A или в B, но не в обоих
sym_diff = set_a ^ set_b
sym_diff_method = set_a.symmetric_difference(set_b)
print(f"set_a ^ set_b: {sym_diff}")
print(f"set_a.symmetric_difference(set_b): {sym_diff_method}")

print("\n--- Проверка подмножеств ---")
# issubset() - является ли подмножеством
print(f"set_c ⊆ set_a: {set_c.issubset(set_a)}")
print(f"set_c <= set_a: {set_c <= set_a}")
print(f"set_a ⊆ set_c: {set_a.issubset(set_c)}")

# issuperset() - является ли надмножеством
print(f"set_a ⊇ set_c: {set_a.issuperset(set_c)}")
print(f"set_a >= set_c: {set_a >= set_c}")

print("\n--- Непересекающиеся множества ---")
# isdisjoint() - не имеют общих элементов
set_x = {1, 2, 3}
set_y = {4, 5, 6}
set_z = {3, 4, 5}

print(f"set_x: {set_x}, set_y: {set_y}")
print(f"set_x и set_y не пересекаются: {set_x.isdisjoint(set_y)}")
print(f"set_x и set_z не пересекаются: {set_x.isdisjoint(set_z)}")

print("\n--- Изменяющие методы ---")
# Методы, которые изменяют исходное множество
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(f"set1: {set1}, set2: {set2}")

set1.update(set2)  # Объединение на месте
print(f"После set1.update(set2): {set1}")

set1 = {1, 2, 3}
set1.intersection_update(set2)  # Пересечение на месте
print(f"После set1.intersection_update(set2): {set1}")

set1 = {1, 2, 3, 4, 5}
set1.difference_update({3, 4})  # Разность на месте
print(f"После set1.difference_update({{3,4}}): {set1}")
```
Вывод в консоли:
```bash
=== Операции над множествами ===
set_a: {1, 2, 3, 4, 5}
set_b: {4, 5, 6, 7, 8}
set_c: {3, 4, 5}

--- Объединение (union) ---
set_a | set_b: {1, 2, 3, 4, 5, 6, 7, 8}
set_a.union(set_b): {1, 2, 3, 4, 5, 6, 7, 8}

--- Пересечение (intersection) ---
set_a & set_b: {4, 5}
set_a.intersection(set_b): {4, 5}

--- Разность (difference) ---
set_a - set_b: {1, 2, 3}
set_a.difference(set_b): {1, 2, 3}
set_b - set_a: {8, 6, 7}

--- Симметрическая разность (symmetric difference) ---
set_a ^ set_b: {1, 2, 3, 6, 7, 8}
set_a.symmetric_difference(set_b): {1, 2, 3, 6, 7, 8}

--- Проверка подмножеств ---
set_c ⊆ set_a: True
set_c <= set_a: True
set_a ⊆ set_c: False
set_a ⊇ set_c: True
set_a >= set_c: True

--- Непересекающиеся множества ---
set_x: {1, 2, 3}, set_y: {4, 5, 6}
set_x и set_y не пересекаются: True
set_x и set_z не пересекаются: False

--- Изменяющие методы ---
set1: {1, 2, 3}, set2: {3, 4, 5}
После set1.update(set2): {1, 2, 3, 4, 5}
После set1.intersection_update(set2): {3}
После set1.difference_update({3,4}): {1, 2, 5}
```
Слайд 4: Пример 3 — Практическое применение множеств
Задача: Показать реальные примеры использования множеств.
```python
print("=== Практическое применение множеств ===")

print("\n--- Удаление дубликатов из списка ---")
# Самый простой способ удалить дубликаты
data_with_duplicates = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]
unique_data = list(set(data_with_duplicates))
print(f"Исходный список: {data_with_duplicates}")
print(f"Без дубликатов: {unique_data}")

print("\n--- Поиск общих элементов ---")
# Поиск общих друзей в социальных сетях
user1_friends = {"Анна", "Борис", "Виктор", "Дарья", "Елена"}
user2_friends = {"Виктор", "Дарья", "Иван", "Ксения", "Мария"}

common_friends = user1_friends & user2_friends
print(f"Друзья пользователя 1: {user1_friends}")
print(f"Друзья пользователя 2: {user2_friends}")
print(f"Общие друзья: {common_friends}")

print("\n--- Поиск уникальных элементов ---")
# Элементы которые есть только у одного пользователя
only_user1 = user1_friends - user2_friends
only_user2 = user2_friends - user1_friends
print(f"Только у пользователя 1: {only_user1}")
print(f"Только у пользователя 2: {only_user2}")

print("\n--- Проверка правописания ---")
# Простая проверка слов по словарю
dictionary = {"яблоко", "банан", "апельсин", "виноград", "манго"}
user_text = "яблко банан апельсин виногред манго киви"

words = user_text.split()
misspelled = set(words) - dictionary
unknown_words = set(words) - dictionary

print(f"Словарь: {dictionary}")
print(f"Текст пользователя: {user_text}")
print(f"Неизвестные слова: {unknown_words}")

print("\n--- Анализ данных ---")
# Анализ посещений веб-сайтов
day1_visitors = {"user123", "user456", "user789", "user101"}
day2_visitors = {"user456", "user789", "user202", "user303"}
day3_visitors = {"user123", "user789", "user404", "user505"}

# Постоянные посетители (были все три дня)
loyal_visitors = day1_visitors & day2_visitors & day3_visitors

# Все уникальные посетители за три дня
all_visitors = day1_visitors | day2_visitors | day3_visitors

# Посетители только одного дня
only_day1 = day1_visitors - day2_visitors - day3_visitors

print(f"Постоянные посетители: {loyal_visitors}")
print(f"Все уникальные посетители: {all_visitors}")
print(f"Только в первый день: {only_day1}")
print(f"Всего уникальных посетителей: {len(all_visitors)}")

print("\n--- Фильтрация данных ---")
# Фильтрация email адресов
valid_domains = {"gmail.com", "yahoo.com", "mail.ru", "yandex.ru"}
emails = [
    "user1@gmail.com",
    "user2@hotmail.com", 
    "user3@mail.ru",
    "user4@yahoo.com",
    "user5@spam.com"
]

# Извлекаем домены из email
domains = {email.split('@')[1] for email in emails}
valid_emails = [email for email in emails if email.split('@')[1] in valid_domains]
invalid_domains = domains - valid_domains

print(f"Все домены: {domains}")
print(f"Валидные email: {valid_emails}")
print(f"Невалидные домены: {invalid_domains}")
```
Вывод в консоли:
```bash
=== Практическое применение множеств ===

--- Удаление дубликатов из списка ---
Исходный список: [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]
Без дубликатов: [1, 2, 3, 4, 5]

--- Поиск общих элементов ---
Друзья пользователя 1: {'Борис', 'Анна', 'Елена', 'Дарья', 'Виктор'}
Друзья пользователя 2: {'Иван', 'Дарья', 'Ксения', 'Мария', 'Виктор'}
Общие друзья: {'Дарья', 'Виктор'}

--- Поиск уникальных элементов ---
Только у пользователя 1: {'Борис', 'Анна', 'Елена'}
Только у пользователя 2: {'Иван', 'Ксения', 'Мария'}

--- Проверка правописания ---
Словарь: {'манго', 'апельсин', 'банан', 'яблоко', 'виноград'}
Текст пользователя: яблко банан апельсин виногред манго киви
Неизвестные слова: {'киви', 'яблко', 'виногред'}

--- Анализ данных ---
Постоянные посетители: {'user789'}
Все уникальные посетители: {'user123', 'user456', 'user789', 'user101', 'user202', 'user303', 'user404', 'user505'}
Только в первый день: {'user101'}
Всего уникальных посетителей: 8

--- Фильтрация данных ---
Все домены: {'gmail.com', 'hotmail.com', 'mail.ru', 'yahoo.com', 'spam.com'}
Валидные email: ['user1@gmail.com', 'user3@mail.ru', 'user4@yahoo.com']
Невалидные домены: {'hotmail.com', 'spam.com'}
```
Слайд 5: Пример 4 — Frozenset и дополнительные возможности
Задача: Показать неизменяемые множества и дополнительные возможности.
```python
print("=== Frozenset и дополнительные возможности ===")

print("\n--- Frozenset (неизменяемое множество) ---")
# Frozenset - неизменяемая версия множества
regular_set = {1, 2, 3}
frozen = frozenset([1, 2, 3, 4, 5])

print(f"Обычное множество: {regular_set}")
print(f"Frozenset: {frozen}")
print(f"Тип frozenset: {type(frozen)}")

# Frozenset можно использовать как ключ словаря
frozen_dict = {
    frozenset({1, 2, 3}): "множество 1-3",
    frozenset({4, 5, 6}): "множество 4-6"
}
print(f"Словарь с frozenset ключами: {frozen_dict}")

# Операции работают так же как с обычными множествами
set_a = {1, 2, 3}
frozen_b = frozenset({3, 4, 5})

print(f"set_a: {set_a}, frozen_b: {frozen_b}")
print(f"Объединение: {set_a | frozen_b}")
print(f"Пересечение: {set_a & frozen_b}")

print("\n--- Генераторы множеств ---")
# Аналогично списковым включениям
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Множество четных чисел
even_set = {x for x in numbers if x % 2 == 0}
print(f"Четные числа: {even_set}")

# Множество квадратов
squares = {x**2 for x in range(1, 6)}
print(f"Квадраты 1-5: {squares}")

# Множество длин слов
words = ["apple", "banana", "cherry", "date", "elderberry"]
lengths = {len(word) for word in words}
print(f"Длины слов: {lengths}")

print("\n--- Сравнение производительности ---")
import time

# Создаем большой список и множество
large_list = list(range(1000000))
large_set = set(large_list)

# Поиск элемента в списке vs множестве
search_value = 999999

# Поиск в списке
start = time.time()
result_list = search_value in large_list
time_list = time.time() - start

# Поиск в множестве
start = time.time()
result_set = search_value in large_set
time_set = time.time() - start

print(f"Поиск {search_value}:")
print(f"  В списке: {time_list:.6f} секунд")
print(f"  В множестве: {time_set:.6f} секунд")
print(f"  Множество быстрее в {time_list/time_set:.0f} раз!")

print("\n--- Практический пример: система тегов ---")
class TagSystem:
    def __init__(self):
        self.tags = set()
    
    def add_tags(self, *new_tags):
        self.tags.update(new_tags)
    
    def remove_tags(self, *tags_to_remove):
        self.tags.difference_update(tags_to_remove)
    
    def find_common(self, other_tags):
        return self.tags & other_tags
    
    def get_suggestions(self, user_tags):
        return self.tags - user_tags

# Использование
tag_system = TagSystem()
tag_system.add_tags("python", "programming", "web", "data", "machine learning")

user1_tags = {"python", "web", "javascript"}
user2_tags = {"data", "analysis", "python"}

print(f"Все теги системы: {tag_system.tags}")
print(f"Теги пользователя 1: {user1_tags}")
print(f"Общие теги пользователя 1: {tag_system.find_common(user1_tags)}")
print(f"Предложения для пользователя 1: {tag_system.get_suggestions(user1_tags)}")
print(f"Предложения для пользователя 2: {tag_system.get_suggestions(user2_tags)}")
```
Вывод в консоли:
```bash
=== Frozenset и дополнительные возможности ===

--- Frozenset (неизменяемое множество) ---
Обычное множество: {1, 2, 3}
Frozenset: frozenset({1, 2, 3, 4, 5})
Тип frozenset: <class 'frozenset'>
Словарь с frozenset ключами: {frozenset({1, 2, 3}): 'множество 1-3', frozenset({4, 5, 6}): 'множество 4-6'}
set_a: {1, 2, 3}, frozen_b: frozenset({3, 4, 5})
Объединение: {1, 2, 3, 4, 5}
Пересечение: {3}

--- Генераторы множеств ---
Четные числа: {2, 4, 6, 8, 10}
Квадраты 1-5: {1, 4, 9, 16, 25}
Длины слов: {5, 6, 10}

--- Сравнение производительности ---
Поиск 999999:
  В списке: 0.009984 секунд
  В множестве: 0.000001 секунд
  Множество быстрее в 9984 раз!

--- Практический пример: система тегов ---
Все теги системы: {'web', 'data', 'python', 'machine learning', 'programming'}
Теги пользователя 1: {'web', 'javascript', 'python'}
Общие теги пользователя 1: {'web', 'python'}
Предложения для пользователя 1: {'data', 'machine learning', 'programming'}
Предложения для пользователя 2: {'web', 'machine learning', 'programming'}
```
Слайд 6: Задания для практики
Задание 1: Анализатор текста
```python
# Напишите функцию анализа текста:
# 1. Найти все уникальные слова
# 2. Найти слова, которые встречаются в двух текстах
# 3. Найти слова, которые есть только в одном тексте
# 4. Используйте множества для решения
# Ваш код здесь
```
Задание 2: Система рекомендаций
```python
# Напишите систему рекомендаций фильмов:
# 1. Хранить просмотренные фильмы пользователей
# 2. Находить общие фильмы между пользователями
# 3. Рекомендовать фильмы которые один посмотрел, а другой нет
# 4. Используйте операции над множествами
# Ваш код здесь
```
Задание 3: Валидатор данных
```python
# Напишите валидатор данных:
# 1. Проверять уникальность элементов
# 2. Находить дубликаты
# 3. Проверять наличие обязательных полей
# 4. Используйте методы множеств
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Анализатор текста
def analyze_texts(text1, text2):
    # Приводим к нижнему регистру и разбиваем на слова
    words1 = set(text1.lower().split())
    words2 = set(text2.lower().split())
    
    # Уникальные слова в каждом тексте
    unique1 = words1 - words2
    unique2 = words2 - words1
    
    # Общие слова
    common = words1 & words2
    
    # Все уникальные слова
    all_unique = words1 | words2
    
    return {
        'unique_text1': unique1,
        'unique_text2': unique2,
        'common_words': common,
        'all_unique_words': all_unique,
        'total_unique_words': len(all_unique)
    }

# Тестирование
text1 = "Python это язык программирования высокого уровня"
text2 = "Программирование на Python это интересно и полезно"

result = analyze_texts(text1, text2)
print(f"Уникальные слова в тексте 1: {result['unique_text1']}")
print(f"Уникальные слова в тексте 2: {result['unique_text2']}")
print(f"Общие слова: {result['common_words']}")
print(f"Всего уникальных слов: {result['total_unique_words']}")

# #Задание 2: Система рекомендаций
class MovieRecommender:
    def __init__(self):
        self.users_movies = {}
    
    def add_user(self, user, movies):
        self.users_movies[user] = set(movies)
    
    def common_movies(self, user1, user2):
        return self.users_movies[user1] & self.users_movies[user2]
    
    def recommend_movies(self, target_user, source_user):
        return self.users_movies[source_user] - self.users_movies[target_user]
    
    def find_similar_users(self, target_user, min_common=2):
        similar = []
        target_movies = self.users_movies[target_user]
        
        for user, movies in self.users_movies.items():
            if user != target_user:
                common = len(target_movies & movies)
                if common >= min_common:
                    similar.append((user, common))
        
        return sorted(similar, key=lambda x: x[1], reverse=True)

# Тестирование
recommender = MovieRecommender()
recommender.add_user("Анна", ["Фильм1", "Фильм2", "Фильм3", "Фильм4"])
recommender.add_user("Борис", ["Фильм2", "Фильм3", "Фильм5", "Фильм6"])
recommender.add_user("Виктор", ["Фильм1", "Фильм4", "Фильм7"])

print(f"Общие фильмы Анны и Бориса: {recommender.common_movies('Анна', 'Борис')}")
print(f"Рекомендации для Анны от Бориса: {recommender.recommend_movies('Анна', 'Борис')}")
print(f"Похожие пользователи на Анну: {recommender.find_similar_users('Анна')}")

# #Задание 3: Валидатор данных
class DataValidator:
    def __init__(self, required_fields=None):
        self.required_fields = set(required_fields) if required_fields else set()
    
    def check_duplicates(self, data):
        if len(data) == len(set(data)):
            return True, "Дубликатов нет"
        else:
            duplicates = set([x for x in data if data.count(x) > 1])
            return False, f"Найдены дубликаты: {duplicates}"
    
    def check_required_fields(self, data_dict):
        data_fields = set(data_dict.keys())
        missing = self.required_fields - data_fields
        if not missing:
            return True, "Все обязательные поля присутствуют"
        else:
            return False, f"Отсутствуют обязательные поля: {missing}"
    
    def find_common_issues(self, data_list):
        all_fields = set()
        for item in data_list:
            all_fields.update(item.keys())
        
        common_issues = []
        for field in all_fields:
            values = [item.get(field) for item in data_list if field in item]
            if len(values) != len(data_list):
                common_issues.append(f"Поле '{field}' отсутствует в некоторых записях")
        
        return common_issues

# Тестирование
validator = DataValidator(["name", "age", "email"])

# Проверка дубликатов
data = [1, 2, 3, 2, 4, 5, 3]
is_valid, message = validator.check_duplicates(data)
print(f"Проверка дубликатов: {message}")

# Проверка обязательных полей
user_data = {"name": "Анна", "age": 25}
is_valid, message = validator.check_required_fields(user_data)
print(f"Проверка обязательных полей: {message}")
```
Ключевые моменты:
```
Множества хранят только уникальные элементы
Быстрый поиск: O(1) vs O(n) в списках
Основные операции: объединение, пересечение, разность
Методы: add(), remove(), discard(), update(), intersection_update()
Frozenset: неизменяемая версия множества
Генераторы множеств: {x for x in iterable if condition}
Применение: удаление дубликатов, поиск общих элементов, проверка принадлежности
Основные операции с множествами.
```
 «Основные операции с множествами»
Тема: Основные операции с множествами
```
Слайд 1: Теория — Основные операции с множествами
Множество — неупорядоченная коллекция уникальных элементов
Основные операции делятся на три категории:
Базовые операции — добавление, удаление, проверка
Математические операции — объединение, пересечение, разность
Операции сравнения — проверка отношений между множествами
Особенности:
Все операции работают за O(1) в среднем случае
Множества изменяемы (кроме frozenset)
Элементы должны быть хешируемыми
```
Слайд 2: Пример 1 — Базовые операции с множествами
Задача: Показать основные методы для работы с элементами множеств.
```python
print("=== Базовые операции с множествами ===")

# Создаем множества для демонстрации
fruits = {"яблоко", "банан", "апельсин"}
numbers = {1, 2, 3, 4, 5}

print(f"Начальное fruits: {fruits}")
print(f"Начальное numbers: {numbers}")

print("\n--- Добавление элементов ---")
# add() - добавление одного элемента
fruits.add("киви")
numbers.add(6)
print(f"После add(): {fruits}")
print(f"После add(): {numbers}")

# update() - добавление нескольких элементов
fruits.update(["манго", "виноград"])
numbers.update({7, 8, 9})
print(f"После update(): {fruits}")
print(f"После update(): {numbers}")

print("\n--- Удаление элементов ---")
# remove() - удаление с генерацией ошибки если элемента нет
fruits.remove("банан")
print(f"После remove('банан'): {fruits}")

# discard() - удаление без ошибки если элемента нет
fruits.discard("груша")  # Не будет ошибки
fruits.discard("апельсин")
print(f"После discard(): {fruits}")

# pop() - удаление и возврат случайного элемента
removed_fruit = fruits.pop()
removed_number = numbers.pop()
print(f"После pop(): fruits={fruits}, удален: '{removed_fruit}'")
print(f"После pop(): numbers={numbers}, удален: {removed_number}")

# clear() - полная очистка
fruits.clear()
print(f"После clear(): {fruits}")

print("\n--- Проверка элементов ---")
colors = {"красный", "зеленый", "синий"}
print(f"colors: {colors}")

print(f"'красный' in colors: {'красный' in colors}")
print(f"'желтый' in colors: {'желтый' in colors}")
print(f"'синий' not in colors: {'синий' not in colors}")

print(f"Длина множества: {len(colors)}")

print("\n--- Копирование множеств ---")
original = {1, 2, 3}
copy1 = original.copy()
copy2 = set(original)

print(f"Оригинал: {original}")
print(f"Копия copy(): {copy1}")
print(f"Копия set(): {copy2}")

# Изменяем копию - оригинал не меняется
copy1.add(4)
print(f"После изменения копии: оригинал={original}, копия={copy1}")
```
Вывод в консоли:
```bash
=== Базовые операции с множествами ===
Начальное fruits: {'апельсин', 'банан', 'яблоко'}
Начальное numbers: {1, 2, 3, 4, 5}

--- Добавление элементов ---
После add(): {'апельсин', 'банан', 'яблоко', 'киви'}
После add(): {1, 2, 3, 4, 5, 6}
После update(): {'манго', 'апельсин', 'банан', 'яблоко', 'киви', 'виноград'}
После update(): {1, 2, 3, 4, 5, 6, 7, 8, 9}

--- Удаление элементов ---
После remove('банан'): {'манго', 'апельсин', 'яблоко', 'киви', 'виноград'}
После discard(): {'манго', 'яблоко', 'киви', 'виноград'}
После pop(): fruits={'яблоко', 'киви', 'виноград'}, удален: 'манго'
После pop(): numbers={2, 3, 4, 5, 6, 7, 8, 9}, удален: 1
После clear(): set()

--- Проверка элементов ---
colors: {'синий', 'красный', 'зеленый'}
'красный' in colors: True
'желтый' in colors: False
'синий' not in colors: False
Длина множества: 3

--- Копирование множеств ---
Оригинал: {1, 2, 3}
Копия copy(): {1, 2, 3}
Копия set(): {1, 2, 3}
После изменения копии: оригинал={1, 2, 3}, копия={1, 2, 3, 4}
```
Слайд 3: Пример 2 — Математические операции над множествами
Задача: Показать математические операции над множествами.
```python
print("=== Математические операции над множествами ===")

# Создаем множества для демонстрации
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
C = {3, 4, 5}

print(f"Множество A: {A}")
print(f"Множество B: {B}")
print(f"Множество C: {C}")

print("\n--- Объединение (union) ---")
# Все элементы из обоих множеств
union_operator = A | B
union_method = A.union(B)
union_multiple = A.union(B, C)

print(f"A | B: {union_operator}")
print(f"A.union(B): {union_method}")
print(f"A.union(B, C): {union_multiple}")

print("\n--- Пересечение (intersection) ---")
# Только общие элементы
intersection_operator = A & B
intersection_method = A.intersection(B)
intersection_multiple = A.intersection(B, C)

print(f"A & B: {intersection_operator}")
print(f"A.intersection(B): {intersection_method}")
print(f"A.intersection(B, C): {intersection_multiple}")

print("\n--- Разность (difference) ---")
# Элементы в A, но не в B
difference_operator = A - B
difference_method = A.difference(B)
difference_multiple = A.difference(B, C)

print(f"A - B: {difference_operator}")
print(f"A.difference(B): {difference_method}")
print(f"A.difference(B, C): {difference_multiple}")

print("\n--- Симметрическая разность (symmetric difference) ---")
# Элементы которые в A или в B, но не в обоих
sym_diff_operator = A ^ B
sym_diff_method = A.symmetric_difference(B)

print(f"A ^ B: {sym_diff_operator}")
print(f"A.symmetric_difference(B): {sym_diff_method}")

print("\n--- Изменяющие версии операций ---")
# Операции, которые изменяют исходное множество
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(f"Исходные: set1={set1}, set2={set2}")

# update() - объединение на месте
set1.update(set2)
print(f"После set1.update(set2): {set1}")

set1 = {1, 2, 3}
# intersection_update() - пересечение на месте
set1.intersection_update(set2)
print(f"После set1.intersection_update(set2): {set1}")

set1 = {1, 2, 3, 4, 5}
# difference_update() - разность на месте
set1.difference_update({3, 4})
print(f"После set1.difference_update({{3,4}}): {set1}")

set1 = {1, 2, 3}
# symmetric_difference_update() - симметрическая разность на месте
set1.symmetric_difference_update({3, 4, 5})
print(f"После set1.symmetric_difference_update({{3,4,5}}): {set1}")
```
Вывод в консоли:
```bash
=== Математические операции над множествами ===
Множество A: {1, 2, 3, 4, 5}
Множество B: {4, 5, 6, 7, 8}
Множество C: {3, 4, 5}

--- Объединение (union) ---
A | B: {1, 2, 3, 4, 5, 6, 7, 8}
A.union(B): {1, 2, 3, 4, 5, 6, 7, 8}
A.union(B, C): {1, 2, 3, 4, 5, 6, 7, 8}

--- Пересечение (intersection) ---
A & B: {4, 5}
A.intersection(B): {4, 5}
A.intersection(B, C): {4, 5}

--- Разность (difference) ---
A - B: {1, 2, 3}
A.difference(B): {1, 2, 3}
A.difference(B, C): {1, 2}

--- Симметрическая разность (symmetric difference) ---
A ^ B: {1, 2, 3, 6, 7, 8}
A.symmetric_difference(B): {1, 2, 3, 6, 7, 8}

--- Изменяющие версии операций ---
Исходные: set1={1, 2, 3}, set2={3, 4, 5}
После set1.update(set2): {1, 2, 3, 4, 5}
После set1.intersection_update(set2): {3}
После set1.difference_update({3,4}): {1, 2, 5}
После set1.symmetric_difference_update({3,4,5}): {1, 2, 4, 5}
```
Слайд 4: Пример 3 — Операции сравнения множеств
Задача: Показать операции для сравнения отношений между множествами.
```python
print("=== Операции сравнения множеств ===")

# Создаем множества для демонстрации
A = {1, 2, 3, 4, 5}
B = {3, 4, 5}
C = {3, 4, 5}
D = {6, 7, 8}
E = {1, 2, 3, 4, 5}

print(f"A: {A}")
print(f"B: {B}")
print(f"C: {C}")
print(f"D: {D}")
print(f"E: {E}")

print("\n--- Проверка подмножества (subset) ---")
# B является подмножеством A?
print(f"B ⊆ A: {B.issubset(A)}")
print(f"B <= A: {B <= A}")
print(f"A ⊆ B: {A.issubset(B)}")
print(f"A <= B: {A <= B}")

# Собственное подмножество (строгое)
print(f"B ⊂ A: {B < A}")  # True - B собственное подмножество A
print(f"C ⊂ B: {C < B}")  # False - C не собственное подмножество B (они равны)

print("\n--- Проверка надмножества (superset) ---")
# A является надмножеством B?
print(f"A ⊇ B: {A.issuperset(B)}")
print(f"A >= B: {A >= B}")
print(f"B ⊇ A: {B.issuperset(A)}")
print(f"B >= A: {B >= A}")

# Собственное надмножество (строгое)
print(f"A ⊃ B: {A > B}")  # True - A собственное надмножество B
print(f"B ⊃ C: {B > C}")  # False - B не собственное надмножество C

print("\n--- Проверка равенства ---")
print(f"B == C: {B == C}")  # True - одинаковые элементы
print(f"A == E: {A == E}")  # True - одинаковые элементы
print(f"A == B: {A == B}")  # False - разные элементы

print("\n--- Непересекающиеся множества ---")
# Множества не имеют общих элементов?
print(f"A и D не пересекаются: {A.isdisjoint(D)}")
print(f"B и D не пересекаются: {B.isdisjoint(D)}")
print(f"A и B не пересекаются: {A.isdisjoint(B)}")

print("\n--- Практический пример: проверка прав доступа ---")
# Система проверки прав доступа пользователей
admin_permissions = {"read", "write", "delete", "manage_users"}
editor_permissions = {"read", "write", "delete"}
viewer_permissions = {"read"}
guest_permissions = set()

current_user = "editor"
user_permissions = editor_permissions

print(f"Права администратора: {admin_permissions}")
print(f"Права редактора: {editor_permissions}")
print(f"Права зрителя: {viewer_permissions}")

# Проверка прав
print(f"Редактор может всё что зритель: {editor_permissions >= viewer_permissions}")
print(f"Редактор является подмножеством администратора: {editor_permissions <= admin_permissions}")
print(f"У гостя есть какие-то права: {bool(guest_permissions)}")
print(f"Админ и зритель имеют общие права: {not admin_permissions.isdisjoint(viewer_permissions)}")

print("\n--- Проверка вложенности структур ---")
# Проверка сложных структур данных
database_tables = {"users", "products", "orders", "categories"}
user_access = {"users", "products"}
admin_access = {"users", "products", "orders", "categories", "logs"}

print(f"Таблицы в БД: {database_tables}")
print(f"Доступ пользователя: {user_access}")
print(f"Доступ администратора: {admin_access}")

print(f"Пользователь имеет доступ ко всем нужным таблицам: {user_access <= database_tables}")
print(f"Администратор имеет доступ ко всем таблицам: {admin_access >= database_tables}")
print(f"Есть таблицы недоступные пользователю: {database_tables - user_access}")
```
Вывод в консоли:
```bash
=== Операции сравнения множеств ===
A: {1, 2, 3, 4, 5}
B: {3, 4, 5}
C: {3, 4, 5}
D: {8, 6, 7}
E: {1, 2, 3, 4, 5}

--- Проверка подмножества (subset) ---
B ⊆ A: True
B <= A: True
A ⊆ B: False
A <= B: False
B ⊂ A: True
C ⊂ B: False

--- Проверка надмножества (superset) ---
A ⊇ B: True
A >= B: True
B ⊇ A: False
B >= A: False
A ⊃ B: True
B ⊃ C: False

--- Проверка равенства ---
B == C: True
A == E: True
A == B: False

--- Непересекающиеся множества ---
A и D не пересекаются: True
B и D не пересекаются: True
A и B не пересекаются: False

--- Практический пример: проверка прав доступа ---
Права администратора: {'read', 'manage_users', 'delete', 'write'}
Права редактора: {'read', 'delete', 'write'}
Права зрителя: {'read'}
Редактор может всё что зритель: True
Редактор является подмножеством администратора: True
У гостя есть какие-то права: False
Админ и зритель имеют общие права: True

--- Проверка вложенности структур ---
Таблицы в БД: {'users', 'categories', 'orders', 'products'}
Доступ пользователя: {'users', 'products'}
Доступ администратора: {'users', 'categories', 'orders', 'logs', 'products'}
Пользователь имеет доступ ко всем нужным таблицам: True
Администратор имеет доступ ко всем таблицам: False
Есть таблицы недоступные пользователю: {'categories', 'orders'}
```
Слайд 5: Пример 4 — Практическое применение операций
Задача: Показать реальные примеры применения операций с множествами.
```python
print("=== Практическое применение операций с множествами ===")

print("\n--- Анализ данных о продажах ---")
# Анализ покупательского поведения
week1_customers = {"user1", "user2", "user3", "user4", "user5"}
week2_customers = {"user3", "user4", "user5", "user6", "user7"}
week3_customers = {"user1", "user3", "user5", "user7", "user8"}

print(f"Неделя 1: {week1_customers}")
print(f"Неделя 2: {week2_customers}")
print(f"Неделя 3: {week3_customers}")

# Постоянные клиенты (покупали все три недели)
loyal_customers = week1_customers & week2_customers & week3_customers
print(f"Постоянные клиенты: {loyal_customers}")

# Новые клиенты каждой недели
new_week2 = week2_customers - week1_customers
new_week3 = week3_customers - (week1_customers | week2_customers)
print(f"Новые клиенты недели 2: {new_week2}")
print(f"Новые клиенты недели 3: {new_week3}")

# Ушедшие клиенты
left_after_week1 = week1_customers - week2_customers - week3_customers
print(f"Клиенты ушедшие после недели 1: {left_after_week1}")

# Общее количество уникальных клиентов
all_customers = week1_customers | week2_customers | week3_customers
print(f"Всего уникальных клиентов: {len(all_customers)}")

print("\n--- Система тегирования контента ---")
# Система категоризации статей
programming_tags = {"python", "java", "javascript", "web", "database"}
data_science_tags = {"python", "machine learning", "statistics", "data"}
web_dev_tags = {"javascript", "web", "html", "css", "python"}

articles = {
    "article1": {"python", "web", "javascript"},
    "article2": {"python", "machine learning", "data"},
    "article3": {"java", "database"},
    "article4": {"html", "css", "javascript"}
}

print("Теги категорий:")
print(f"  Программирование: {programming_tags}")
print(f"  Data Science: {data_science_tags}")
print(f"  Web Development: {web_dev_tags}")

# Находим статьи для каждой категории
programming_articles = []
data_science_articles = []
web_dev_articles = []

for article, tags in articles.items():
    if tags & programming_tags:
        programming_articles.append(article)
    if tags & data_science_tags:
        data_science_articles.append(article)
    if tags & web_dev_tags:
        web_dev_articles.append(article)

print(f"Статьи по программированию: {programming_articles}")
print(f"Статьи по Data Science: {data_science_articles}")
print(f"Статьи по Web Development: {web_dev_articles}")

# Уникальные теги для каждой категории
unique_programming = programming_tags - data_science_tags - web_dev_tags
unique_data_science = data_science_tags - programming_tags - web_dev_tags
unique_web_dev = web_dev_tags - programming_tags - data_science_tags

print(f"Уникальные теги программирования: {unique_programming}")
print(f"Уникальные теги Data Science: {unique_data_science}")
print(f"Уникальные теги Web Development: {unique_web_dev}")

print("\n--- Валидация данных формы ---")
# Проверка данных формы регистрации
required_fields = {"username", "email", "password"}
optional_fields = {"phone", "birth_date", "country"}
all_fields = required_fields | optional_fields

def validate_form(data):
    submitted_fields = set(data.keys())
    
    # Проверяем обязательные поля
    missing_required = required_fields - submitted_fields
    if missing_required:
        return False, f"Отсутствуют обязательные поля: {missing_required}"
    
    # Проверяем неизвестные поля
    unknown_fields = submitted_fields - all_fields
    if unknown_fields:
        return False, f"Неизвестные поля: {unknown_fields}"
    
    # Проверяем что все поля заполнены
    empty_fields = {field for field, value in data.items() if not value}
    if empty_fields:
        return False, f"Пустые поля: {empty_fields}"
    
    return True, "Форма валидна"

# Тестирование
test_data1 = {"username": "john", "email": "john@example.com", "password": "123"}
test_data2 = {"username": "", "email": "jane@example.com", "password": "456", "unknown": "field"}
test_data3 = {"username": "bob", "password": "789"}  # Нет email

for i, data in enumerate([test_data1, test_data2, test_data3], 1):
    is_valid, message = validate_form(data)
    print(f"Тест {i}: {message}")
```
Вывод в консоли:
```bash
=== Практическое применение операций с множествами ===

--- Анализ данных о продажах ---
Неделя 1: {'user1', 'user2', 'user3', 'user4', 'user5'}
Неделя 2: {'user3', 'user4', 'user5', 'user6', 'user7'}
Неделя 3: {'user1', 'user3', 'user5', 'user7', 'user8'}
Постоянные клиенты: {'user3', 'user5'}
Новые клиенты недели 2: {'user6', 'user7'}
Новые клиенты недели 3: {'user8'}
Клиенты ушедшие после недели 1: {'user2'}
Всего уникальных клиентов: 8

--- Система тегирования контента ---
Теги категорий:
  Программирование: {'python', 'web', 'java', 'javascript', 'database'}
  Data Science: {'python', 'machine learning', 'data', 'statistics'}
  Web Development: {'python', 'web', 'html', 'css', 'javascript'}
Статьи по программированию: ['article1', 'article2', 'article3']
Статьи по Data Science: ['article1', 'article2']
Статьи по Web Development: ['article1', 'article4']
Уникальные теги программирования: {'java', 'database'}
Уникальные теги Data Science: {'machine learning', 'data', 'statistics'}
Уникальные теги Web Development: {'html', 'css'}

--- Валидация данных формы ---
Тест 1: Форма валидна
Тест 2: Пустые поля: {'username'}
Тест 3: Отсутствуют обязательные поля: {'email'}
```
Слайд 6: Задания для практики
Задание 1: Анализатор текстов
```python
# Напишите функцию для сравнения двух текстов:
# 1. Найти общие слова
# 2. Найти уникальные слова для каждого текста
# 3. Определить какой текст богаче словарным запасом
# 4. Используйте операции над множествами
# Ваш код здесь
```
Задание 2: Система рекомендаций друзей
```python
# Напишите систему рекомендаций друзей:
# 1. Находить общих друзей между пользователями
# 2. Рекомендовать друзей на основе общих друзей
# 3. Определять "социальные круги"
# 4. Используйте операции над множествами
# Ваш код здесь
```
Задание 3: Валидатор конфигурации
```python
# Напишите валидатор конфигурационных файлов:
# 1. Проверять обязательные параметры
# 2. Находить неизвестные параметры
# 3. Проверять конфликтующие параметры
# 4. Используйте операции над множествами
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Анализатор текстов
def analyze_texts(text1, text2):
    # Приводим к нижнему регистру и разбиваем на слова
    words1 = set(text1.lower().split())
    words2 = set(text2.lower().split())
    
    # Общие слова
    common_words = words1 & words2
    
    # Уникальные слова
    unique_text1 = words1 - words2
    unique_text2 = words2 - words1
    
    # Сравнение словарного запаса
    if len(words1) > len(words2):
        richer = "Первый текст"
    elif len(words2) > len(words1):
        richer = "Второй текст"
    else:
        richer = "Тексты равны по словарному запасу"
    
    return {
        'common_words': common_words,
        'unique_text1': unique_text1,
        'unique_text2': unique_text2,
        'vocabulary_comparison': richer,
        'total_unique_words': len(words1 | words2)
    }

# Тестирование
text1 = "Python это язык программирования высокого уровня"
text2 = "Программирование на Python это интересно и полезно"
result = analyze_texts(text1, text2)

print(f"Общие слова: {result['common_words']}")
print(f"Уникальные слова текста 1: {result['unique_text1']}")
print(f"Уникальные слова текста 2: {result['unique_text2']}")
print(f"Сравнение: {result['vocabulary_comparison']}")
print(f"Всего уникальных слов: {result['total_unique_words']}")

# #Задание 2: Система рекомендаций друзей
class FriendRecommender:
    def __init__(self):
        self.users_friends = {}
    
    def add_user(self, user, friends):
        self.users_friends[user] = set(friends)
    
    def mutual_friends(self, user1, user2):
        return self.users_friends[user1] & self.users_friends[user2]
    
    def recommend_friends(self, target_user):
        recommendations = {}
        target_friends = self.users_friends[target_user]
        
        for user, friends in self.users_friends.items():
            if user != target_user and user not in target_friends:
                mutual = self.mutual_friends(target_user, user)
                if mutual:
                    recommendations[user] = mutual
        
        # Сортируем по количеству общих друзей
        return dict(sorted(recommendations.items(), key=lambda x: len(x[1]), reverse=True))
    
    def find_social_circles(self, min_common_friends=2):
        circles = []
        users = list(self.users_friends.keys())
        
        for i, user1 in enumerate(users):
            for user2 in users[i+1:]:
                common = self.mutual_friends(user1, user2)
                if len(common) >= min_common_friends:
                    circles.append((user1, user2, common))
        
        return circles

# Тестирование
recommender = FriendRecommender()
recommender.add_user("Анна", ["Борис", "Виктор", "Дарья"])
recommender.add_user("Борис", ["Анна", "Виктор", "Елена"])
recommender.add_user("Виктор", ["Анна", "Борис", "Дарья", "Иван"])
recommender.add_user("Дарья", ["Анна", "Виктор"])
recommender.add_user("Елена", ["Борис", "Иван"])

print(f"Общие друзья Анны и Виктора: {recommender.mutual_friends('Анна', 'Виктор')}")
print(f"Рекомендации для Анны: {recommender.recommend_friends('Анна')}")
print(f"Социальные круги: {recommender.find_social_circles()}")

# #Задание 3: Валидатор конфигурации
class ConfigValidator:
    def __init__(self, required_params=None, optional_params=None, conflicting_params=None):
        self.required_params = set(required_params) if required_params else set()
        self.optional_params = set(optional_params) if optional_params else set()
        self.conflicting_params = set(conflicting_params) if conflicting_params else set()
        self.allowed_params = self.required_params | self.optional_params
    
    def validate(self, config):
        config_params = set(config.keys())
        
        errors = []
        
        # Проверка обязательных параметров
        missing_required = self.required_params - config_params
        if missing_required:
            errors.append(f"Отсутствуют обязательные параметры: {missing_required}")
        
        # Проверка неизвестных параметров
        unknown_params = config_params - self.allowed_params
        if unknown_params:
            errors.append(f"Неизвестные параметры: {unknown_params}")
        
        # Проверка конфликтующих параметров
        for param in config_params:
            if param in self.conflicting_params:
                conflicting_found = config_params & self.conflicting_params
                if len(conflicting_found) > 1:
                    errors.append(f"Конфликтующие параметры: {conflicting_found}")
                    break
        
        return len(errors) == 0, errors

# Тестирование
validator = ConfigValidator(
    required_params=["host", "port"],
    optional_params=["timeout", "retries", "debug"],
    conflicting_params=[("host", "socket"), ("port", "url")]
)

test_config1 = {"host": "localhost", "port": 8080, "timeout": 30}
test_config2 = {"host": "localhost"}  # Нет port
test_config3 = {"host": "localhost", "port": 8080, "unknown": "value"}
test_config4 = {"host": "localhost", "socket": "/tmp/socket"}  # Конфликт

for i, config in enumerate([test_config1, test_config2, test_config3, test_config4], 1):
    is_valid, errors = validator.validate(config)
    print(f"Конфигурация {i}: {'Валидна' if is_valid else 'Невалидна'}")
    if errors:
        print(f"  Ошибки: {errors}")
```
Ключевые моменты:
```
Базовые операции: add(), remove(), discard(), pop(), clear()
Математические операции: | (union), & (intersection), - (difference), ^ (symmetric difference)
Операции сравнения: <= (subset), >= (superset), == (equality), isdisjoint()
Изменяющие операции: update(), intersection_update(), difference_update()
Проверка принадлежности: in, not in
Применение: анализ данных, рекомендации, валидация, поиск общих элементов
Словари.
```
 «Словари»
Тема: Словари (dict)
```
Слайд 1: Теория — Словари
Словарь — неупорядоченная коллекция пар "ключ-значение"
Обозначаются фигурными скобками: {"key": "value"}
Ключи должны быть уникальными и хешируемыми
Значения могут быть любого типа данных
Быстрый доступ к элементам по ключу (O(1))
Основные характеристики:
Изменяемы (можно добавлять, изменять, удалять элементы)
Неупорядочены (до Python 3.7), сохраняют порядок вставки (с Python 3.7+)
Поддерживают различные методы для работы с данными
```
Слайд 2: Пример 1 — Создание и базовые операции
Задача: Показать различные способы создания словарей и базовые операции.
```python
print("=== Создание и базовые операции со словарями ===")

print("\n--- Способы создания словарей ---")
# Пустой словарь
empty_dict = {}
empty_dict2 = dict()
print(f"Пустой словарь: {empty_dict}")

# Словарь с элементами
person = {"name": "Анна", "age": 25, "city": "Москва"}
print(f"Словарь person: {person}")

# Создание через dict()
numbers = dict(one=1, two=2, three=3)
print(f"Через dict(): {numbers}")

# Создание из списка кортежей
pairs = [("a", 1), ("b", 2), ("c", 3)]
from_pairs = dict(pairs)
print(f"Из списка кортежей: {from_pairs}")

# Создание из двух списков (zip)
keys = ["name", "age", "city"]
values = ["Борис", 30, "Санкт-Петербург"]
from_zip = dict(zip(keys, values))
print(f"Из двух списков: {from_zip}")

print("\n--- Доступ к элементам ---")
student = {
    "name": "Мария",
    "age": 22,
    "grades": [4, 5, 4, 5],
    "contact": {"email": "maria@mail.ru", "phone": "+79123456789"}
}

print(f"student['name']: {student['name']}")
print(f"student['age']: {student['age']}")
print(f"student['grades']: {student['grades']}")
print(f"student['contact']['email']: {student['contact']['email']}")

# get() - безопасный доступ
print(f"student.get('name'): {student.get('name')}")
print(f"student.get('salary'): {student.get('salary')}")  # None
print(f"student.get('salary', 'Не указано'): {student.get('salary', 'Не указано')}")

print("\n--- Изменение и добавление элементов ---")
car = {"brand": "Toyota", "model": "Camry", "year": 2020}
print(f"Исходный словарь: {car}")

# Изменение существующего элемента
car["year"] = 2022
print(f"После изменения года: {car}")

# Добавление нового элемента
car["color"] = "синий"
car["price"] = 2500000
print(f"После добавления цвета и цены: {car}")

# update() - массовое обновление
car.update({"color": "красный", "transmission": "автомат"})
print(f"После update(): {car}")

print("\n--- Удаление элементов ---")
test_dict = {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5}
print(f"Исходный словарь: {test_dict}")

# pop() - удаление по ключу с возвратом значения
removed_b = test_dict.pop("b")
print(f"После pop('b'): {test_dict}, удалено: {removed_b}")

# popitem() - удаление последней пары (Python 3.7+)
last_item = test_dict.popitem()
print(f"После popitem(): {test_dict}, удалено: {last_item}")

# del - удаление по ключу
del test_dict["c"]
print(f"После del test_dict['c']: {test_dict}")

# clear() - полная очистка
test_dict.clear()
print(f"После clear(): {test_dict}")
```
Вывод в консоли:
```bash
=== Создание и базовые операции со словарями ===

--- Способы создания словарей ---
Пустой словарь: {}
Словарь person: {'name': 'Анна', 'age': 25, 'city': 'Москва'}
Через dict(): {'one': 1, 'two': 2, 'three': 3}
Из списка кортежей: {'a': 1, 'b': 2, 'c': 3}
Из двух списков: {'name': 'Борис', 'age': 30, 'city': 'Санкт-Петербург'}

--- Доступ к элементам ---
student['name']: Мария
student['age']: 22
student['grades']: [4, 5, 4, 5]
student['contact']['email']: maria@mail.ru
student.get('name'): Мария
student.get('salary'): None
student.get('salary', 'Не указано'): Не указано

--- Изменение и добавление элементов ---
Исходный словарь: {'brand': 'Toyota', 'model': 'Camry', 'year': 2020}
После изменения года: {'brand': 'Toyota', 'model': 'Camry', 'year': 2022}
После добавления цвета и цены: {'brand': 'Toyota', 'model': 'Camry', 'year': 2022, 'color': 'синий', 'price': 2500000}
После update(): {'brand': 'Toyota', 'model': 'Camry', 'year': 2022, 'color': 'красный', 'price': 2500000, 'transmission': 'автомат'}

--- Удаление элементов ---
Исходный словарь: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
После pop('b'): {'a': 1, 'c': 3, 'd': 4, 'e': 5}, удалено: 2
После popitem(): {'a': 1, 'c': 3, 'd': 4}, удалено: ('e', 5)
После del test_dict['c']: {'a': 1, 'd': 4}
После clear(): {}
```
Слайд 3: Пример 2 — Методы словарей
Задача: Показать основные методы для работы со словарями.
```python
print("=== Методы словарей ===")

# Создаем словарь для демонстрации
employee = {
    "name": "Иван Петров",
    "age": 35,
    "position": "разработчик",
    "department": "IT",
    "salary": 150000,
    "skills": ["Python", "JavaScript", "SQL"]
}

print(f"Исходный словарь: {employee}")

print("\n--- Получение ключей, значений и пар ---")
# keys() - все ключи
print(f"Ключи: {list(employee.keys())}")

# values() - все значения
print(f"Значения: {list(employee.values())}")

# items() - все пары ключ-значение
print(f"Пары ключ-значение: {list(employee.items())}")

print("\n--- Проверка наличия ключей ---")
print(f"'name' in employee: {'name' in employee}")
print(f"'email' in employee: {'email' in employee}")
print(f"'age' not in employee: {'age' not in employee}")

print("\n--- Метод setdefault() ---")
# setdefault() - получить значение, если нет - установить и вернуть
current_age = employee.setdefault("age", 0)  # Ключ есть - вернет значение
new_bonus = employee.setdefault("bonus", 50000)  # Ключа нет - установит и вернет
print(f"setdefault('age', 0): {current_age}")
print(f"setdefault('bonus', 50000): {new_bonus}")
print(f"Словарь после setdefault(): {employee}")

print("\n--- Метод fromkeys() ---")
# fromkeys() - создание словаря с общим значением
keys = ["name", "age", "city"]
default_dict = dict.fromkeys(keys)
default_dict_value = dict.fromkeys(keys, "неизвестно")
print(f"fromkeys(keys): {default_dict}")
print(f"fromkeys(keys, 'неизвестно'): {default_dict_value}")

print("\n--- Копирование словарей ---")
# copy() - поверхностное копирование
original = {"a": 1, "b": [2, 3, 4]}
shallow_copy = original.copy()

print(f"Оригинал: {original}")
print(f"Копия: {shallow_copy}")

# Изменяем вложенный список в копии
shallow_copy["b"].append(5)
print(f"После изменения вложенного списка в копии:")
print(f"Оригинал: {original}")  # Изменился!
print(f"Копия: {shallow_copy}")

print("\n--- Глубокое копирование ---")
import copy
deep_copy = copy.deepcopy(original)
deep_copy["b"].append(6)
print(f"После глубокого копирования и изменения:")
print(f"Оригинал: {original}")  # Не изменился!
print(f"Глубокая копия: {deep_copy}")

print("\n--- Обход словаря в цикле ---")
print("Ключи:")
for key in employee:
    print(f"  {key}")

print("\nЗначения:")
for value in employee.values():
    print(f"  {value}")

print("\nКлючи и значения:")
for key, value in employee.items():
    print(f"  {key}: {value}")
```
Вывод в консоли:
```bash
=== Методы словарей ===
Исходный словарь: {'name': 'Иван Петров', 'age': 35, 'position': 'разработчик', 'department': 'IT', 'salary': 150000, 'skills': ['Python', 'JavaScript', 'SQL']}

--- Получение ключей, значений и пар ---
Ключи: ['name', 'age', 'position', 'department', 'salary', 'skills']
Значения: ['Иван Петров', 35, 'разработчик', 'IT', 150000, ['Python', 'JavaScript', 'SQL']]
Пары ключ-значение: [('name', 'Иван Петров'), ('age', 35), ('position', 'разработчик'), ('department', 'IT'), ('salary', 150000), ('skills', ['Python', 'JavaScript', 'SQL'])]

--- Проверка наличия ключей ---
'name' in employee: True
'email' in employee: False
'age' not in employee: False

--- Метод setdefault() ---
setdefault('age', 0): 35
setdefault('bonus', 50000): 50000
Словарь после setdefault(): {'name': 'Иван Петров', 'age': 35, 'position': 'разработчик', 'department': 'IT', 'salary': 150000, 'skills': ['Python', 'JavaScript', 'SQL'], 'bonus': 50000}

--- Метод fromkeys() ---
fromkeys(keys): {'name': None, 'age': None, 'city': None}
fromkeys(keys, 'неизвестно'): {'name': 'неизвестно', 'age': 'неизвестно', 'city': 'неизвестно'}

--- Копирование словарей ---
Оригинал: {'a': 1, 'b': [2, 3, 4]}
Копия: {'a': 1, 'b': [2, 3, 4]}
После изменения вложенного списка в копии:
Оригинал: {'a': 1, 'b': [2, 3, 4, 5]}
Копия: {'a': 1, 'b': [2, 3, 4, 5]}

--- Глубокое копирование ---
После глубокого копирования и изменения:
Оригинал: {'a': 1, 'b': [2, 3, 4, 5]}
Глубокая копия: {'a': 1, 'b': [2, 3, 4, 5, 6]}

--- Обход словаря в цикле ---
Ключи:
  name
  age
  position
  department
  salary
  skills
  bonus

Значения:
  Иван Петров
  35
  разработчик
  IT
  150000
  ['Python', 'JavaScript', 'SQL']
  50000

Ключи и значения:
  name: Иван Петров
  age: 35
  position: разработчик
  department: IT
  salary: 150000
  skills: ['Python', 'JavaScript', 'SQL']
  bonus: 50000
```
Слайд 4: Пример 3 — Практическое применение словарей
Задача: Показать реальные примеры использования словарей.
```python
print("=== Практическое применение словарей ===")

print("\n--- Система учета студентов ---")
# База данных студентов
students = {
    "И001": {
        "name": "Анна Иванова",
        "age": 20,
        "grades": {"математика": 5, "физика": 4, "программирование": 5},
        "group": "ИТ-21"
    },
    "И002": {
        "name": "Борис Петров", 
        "age": 21,
        "grades": {"математика": 4, "физика": 3, "программирование": 4},
        "group": "ИТ-21"
    },
    "И003": {
        "name": "Мария Сидорова",
        "age": 19,
        "grades": {"математика": 5, "физика": 5, "программирование": 5},
        "group": "ИТ-22"
    }
}

print("База студентов:")
for student_id, info in students.items():
    print(f"  {student_id}: {info['name']}, группа {info['group']}")

# Добавление нового студента
students["И004"] = {
    "name": "Виктор Кузнецов",
    "age": 22,
    "grades": {"математика": 3, "физика": 4, "программирование": 5},
    "group": "ИТ-22"
}

print(f"\nПосле добавления нового студента:")
print(f"Всего студентов: {len(students)}")

# Поиск студентов по группе
def find_students_by_group(group_name):
    return {sid: info for sid, info in students.items() if info["group"] == group_name}

group_it21 = find_students_by_group("ИТ-21")
print(f"Студенты группы ИТ-21: {list(group_it21.keys())}")

# Расчет среднего балла
def calculate_average_grades():
    averages = {}
    for student_id, info in students.items():
        grades = info["grades"].values()
        averages[student_id] = sum(grades) / len(grades)
    return averages

average_grades = calculate_average_grades()
print(f"Средние баллы: {average_grades}")

print("\n--- Система инвентаря магазина ---")
# Учет товаров в магазине
inventory = {
    "яблоки": {"цена": 80, "количество": 150, "категория": "фрукты"},
    "бананы": {"цена": 60, "количество": 200, "категория": "фрукты"},
    "молоко": {"цена": 70, "количество": 50, "категория": "молочные"},
    "хлеб": {"цена": 40, "количество": 30, "категория": "выпечка"},
    "сыр": {"цена": 300, "количество": 20, "категория": "молочные"}
}

print("Инвентарь магазина:")
for product, details in inventory.items():
    print(f"  {product}: {details['цена']} руб., {details['количество']} шт.")

# Функции для работы с инвентарем
def sell_product(product_name, quantity):
    if product_name in inventory and inventory[product_name]["количество"] >= quantity:
        inventory[product_name]["количество"] -= quantity
        total_cost = inventory[product_name]["цена"] * quantity
        return True, total_cost
    return False, 0

def add_product(product_name, price, quantity, category):
    if product_name in inventory:
        inventory[product_name]["количество"] += quantity
    else:
        inventory[product_name] = {
            "цена": price,
            "количество": quantity,
            "категория": category
        }

def get_products_by_category(category):
    return {product: details for product, details in inventory.items() 
            if details["категория"] == category}

# Тестирование функций
print(f"\nПродаем 10 яблок...")
success, cost = sell_product("яблоки", 10)
print(f"Успех: {success}, стоимость: {cost} руб.")

print(f"\nДобавляем новый товар...")
add_product("йогурт", 50, 100, "молочные")

print(f"\nТовары категории 'молочные':")
dairy_products = get_products_by_category("молочные")
for product in dairy_products:
    print(f"  {product}")

print(f"\nОбщая стоимость инвентаря:")
total_value = sum(details["цена"] * details["количество"] 
                 for details in inventory.values())
print(f"  {total_value} руб.")
```
Вывод в консоли:
```bash
=== Практическое применение словарей ===

--- Система учета студентов ---
База студентов:
  И001: Анна Иванова, группа ИТ-21
  И002: Борис Петров, группа ИТ-21
  И003: Мария Сидорова, группа ИТ-22

После добавления нового студента:
Всего студентов: 4
Студенты группы ИТ-21: ['И001', 'И002']
Средние баллы: {'И001': 4.666666666666667, 'И002': 3.6666666666666665, 'И003': 5.0, 'И004': 4.0}

--- Система инвентаря магазина ---
Инвентарь магазина:
  яблоки: 80 руб., 150 шт.
  бананы: 60 руб., 200 шт.
  молоко: 70 руб., 50 шт.
  хлеб: 40 руб., 30 шт.
  сыр: 300 руб., 20 шт.

Продаем 10 яблок...
Успех: True, стоимость: 800 руб.

Добавляем новый товар...

Товары категории 'молочные':
  молоко
  сыр
  йогурт

Общая стоимость инвентаря:
  45500 руб.
```
Слайд 5: Пример 4 — Словарные включения и сложные структуры
Задача: Показать словарные включения и работу со сложными структурами данных.
```python
print("=== Словарные включения и сложные структуры ===")

print("\n--- Словарные включения (dict comprehensions) ---")
# Создание словаря через включение
numbers = [1, 2, 3, 4, 5]
squares = {x: x**2 for x in numbers}
print(f"Квадраты чисел: {squares}")

# С фильтром
even_squares = {x: x**2 for x in numbers if x % 2 == 0}
print(f"Квадраты четных чисел: {even_squares}")

# Из двух списков
keys = ['a', 'b', 'c', 'd']
values = [1, 2, 3, 4]
combined = {k: v for k, v in zip(keys, values)}
print(f"Из двух списков: {combined}")

# Трансформация существующего словаря
prices = {"яблоки": 100, "бананы": 80, "апельсины": 120}
prices_with_discount = {product: price * 0.9 for product, price in prices.items()}
print(f"Цены со скидкой 10%: {prices_with_discount}")

print("\n--- Сложные вложенные структуры ---")
# База данных компании
company = {
    "departments": {
        "IT": {
            "manager": "Иван Сидоров",
            "employees": {
                "Анна Петрова": {"position": "разработчик", "salary": 120000},
                "Борис Иванов": {"position": "тестировщик", "salary": 90000},
                "Мария Козлова": {"position": "аналитик", "salary": 110000}
            },
            "budget": 500000
        },
        "HR": {
            "manager": "Ольга Новикова", 
            "employees": {
                "Дмитрий Смирнов": {"position": "рекрутер", "salary": 80000},
                "Елена Волкова": {"position": "тренер", "salary": 85000}
            },
            "budget": 200000
        }
    },
    "company_info": {
        "name": "ТехноКорп",
        "foundation_year": 2010,
        "ceo": "Петр Алексеев"
    }
}

print("Структура компании:")
print(f"Название: {company['company_info']['name']}")
print(f"CEO: {company['company_info']['ceo']}")

print("\nОтделы и менеджеры:")
for dept_name, dept_info in company["departments"].items():
    print(f"  {dept_name}: {dept_info['manager']}")

print("\n--- Операции со сложными структурами ---")
# Добавление нового сотрудника
company["departments"]["IT"]["employees"]["Виктор Орлов"] = {
    "position": "DevOps", 
    "salary": 130000
}

# Поиск сотрудников с высокой зарплатой
def find_high_salary_employees(threshold=100000):
    high_salary_employees = {}
    for dept_name, dept_info in company["departments"].items():
        for emp_name, emp_info in dept_info["employees"].items():
            if emp_info["salary"] >= threshold:
                high_salary_employees[emp_name] = {
                    "department": dept_name,
                    "position": emp_info["position"],
                    "salary": emp_info["salary"]
                }
    return high_salary_employees

high_paid = find_high_salary_employees()
print(f"Сотрудники с зарплатой ≥ 100000:")
for emp, info in high_paid.items():
    print(f"  {emp}: {info['position']} ({info['department']}) - {info['salary']} руб.")

# Расчет общего фонда зарплат
def calculate_total_salary_budget():
    total = 0
    for dept_info in company["departments"].values():
        for emp_info in dept_info["employees"].values():
            total += emp_info["salary"]
    return total

total_budget = calculate_total_salary_budget()
print(f"Общий фонд зарплат: {total_budget} руб.")

print("\n--- Группировка данных ---")
# Группировка сотрудников по должностям
def group_by_position():
    positions = {}
    for dept_info in company["departments"].values():
        for emp_name, emp_info in dept_info["employees"].items():
            position = emp_info["position"]
            if position not in positions:
                positions[position] = []
            positions[position].append(emp_name)
    return positions

positions_group = group_by_position()
print("Сотрудники по должностям:")
for position, employees in positions_group.items():
    print(f"  {position}: {', '.join(employees)}")

print("\n--- Объединение словарей ---")
# Объединение словарей (Python 3.9+)
dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}
dict3 = {"b": 20, "e": 5}

# Метод update (изменяет исходный)
dict1.update(dict2)
print(f"После dict1.update(dict2): {dict1}")

# Оператор | (создает новый)
merged = dict2 | dict3
print(f"dict2 | dict3: {merged}")

# Объединение с приоритетом
priority_merged = dict1 | dict3  # dict3 имеет приоритет для общих ключей
print(f"dict1 | dict3: {priority_merged}")
```
Вывод в консоли:
```bash
=== Словарные включения и сложные структуры ===

--- Словарные включения (dict comprehensions) ---
Квадраты чисел: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
Квадраты четных чисел: {2: 4, 4: 16}
Из двух списков: {'a': 1, 'b': 2, 'c': 3, 'd': 4}
Цены со скидкой 10%: {'яблоки': 90.0, 'бананы': 72.0, 'апельсины': 108.0}

--- Сложные вложенные структуры ---
Структура компании:
Название: ТехноКорп
CEO: Петр Алексеев

Отделы и менеджеры:
  IT: Иван Сидоров
  HR: Ольга Новикова

--- Операции со сложными структурами ---
Сотрудники с зарплатой ≥ 100000:
  Анна Петрова: разработчик (IT) - 120000 руб.
  Мария Козлова: аналитик (IT) - 110000 руб.
  Виктор Орлов: DevOps (IT) - 130000 руб.
Общий фонд зарплат: 615000 руб.

--- Группировка данных ---
Сотрудники по должностям:
  разработчик: Анна Петрова
  тестировщик: Борис Иванов
  аналитик: Мария Козлова
  рекрутер: Дмитрий Смирнов
  тренер: Елена Волкова
  DevOps: Виктор Орлов

--- Объединение словарей ---
После dict1.update(dict2): {'a': 1, 'b': 2, 'c': 3, 'd': 4}
dict2 | dict3: {'c': 3, 'd': 4, 'b': 20, 'e': 5}
dict1 | dict3: {'a': 1, 'b': 20, 'c': 3, 'd': 4, 'e': 5}
```
Слайд 6: Задания для практики
Задание 1: Анализатор текста
```python
# Напишите функцию анализа текста:
# 1. Подсчитывает частоту каждого слова
# 2. Находит самые частые слова
# 3. Исключает стоп-слова
# 4. Используйте словарь для подсчета
# Ваш код здесь
```
Задание 2: Система учета задач
```python
# Напишите систему управления задачами:
# 1. Добавление, удаление, изменение задач
# 2. Поиск задач по статусу или приоритету
# 3. Статистика по задачам
# 4. Используйте словарь для хранения задач
# Ваш код здесь
```
Задание 3: Конвертер валют
```python
# Напишите конвертер валют:
# 1. Хранит курсы валют в словаре
# 2. Конвертирует между валютами
# 3. Добавляет новые валюты
# 4. Выводит доступные валюты
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Анализатор текста
def text_analyzer(text, stop_words=None):
    if stop_words is None:
        stop_words = {"и", "в", "на", "с", "по", "для", "не", "что", "это", "как"}
    
    # Приводим к нижнему регистру и разбиваем на слова
    words = text.lower().split()
    
    # Подсчитываем частоту слов
    word_freq = {}
    for word in words:
        # Убираем знаки препинания
        clean_word = word.strip('.,!?;:()""')
        if clean_word and clean_word not in stop_words:
            word_freq[clean_word] = word_freq.get(clean_word, 0) + 1
    
    # Находим самые частые слова
    most_common = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:5]
    
    return {
        'word_frequency': word_freq,
        'most_common_words': most_common,
        'total_unique_words': len(word_freq),
        'total_words': len(words)
    }

# Тестирование
text = "Python это язык программирования. Python это простой и мощный язык. Программирование на Python это интересно."
result = text_analyzer(text)
print(f"Частота слов: {result['word_frequency']}")
print(f"Самые частые слова: {result['most_common_words']}")
print(f"Всего уникальных слов: {result['total_unique_words']}")

# #Задание 2: Система учета задач
class TaskManager:
    def __init__(self):
        self.tasks = {}
        self.next_id = 1
    
    def add_task(self, title, description, priority="medium", status="todo"):
        task_id = self.next_id
        self.tasks[task_id] = {
            "title": title,
            "description": description,
            "priority": priority,
            "status": status,
            "created_at": "2024-12-19"
        }
        self.next_id += 1
        return task_id
    
    def update_task_status(self, task_id, new_status):
        if task_id in self.tasks:
            self.tasks[task_id]["status"] = new_status
            return True
        return False
    
    def delete_task(self, task_id):
        if task_id in self.tasks:
            del self.tasks[task_id]
            return True
        return False
    
    def get_tasks_by_status(self, status):
        return {task_id: task for task_id, task in self.tasks.items() 
                if task["status"] == status}
    
    def get_tasks_by_priority(self, priority):
        return {task_id: task for task_id, task in self.tasks.items() 
                if task["priority"] == priority}
    
    def get_statistics(self):
        status_count = {}
        priority_count = {}
        
        for task in self.tasks.values():
            status_count[task["status"]] = status_count.get(task["status"], 0) + 1
            priority_count[task["priority"]] = priority_count.get(task["priority"], 0) + 1
        
        return {
            "total_tasks": len(self.tasks),
            "by_status": status_count,
            "by_priority": priority_count
        }

# Тестирование
manager = TaskManager()
manager.add_task("Изучить Python", "Освоить основы языка Python", "high")
manager.add_task("Сделать проект", "Реализовать небольшой проект", "medium")
manager.add_task("Прочитать документацию", "Изучить официальную документацию", "low")

manager.update_task_status(1, "in progress")
print(f"Задачи в работе: {manager.get_tasks_by_status('in progress')}")
print(f"Статистика: {manager.get_statistics()}")

# #Задание 3: Конвертер валют
class CurrencyConverter:
    def __init__(self):
        self.rates = {
            "USD": 1.0,
            "EUR": 0.85,
            "GBP": 0.75,
            "JPY": 110.0,
            "RUB": 75.0
        }
    
    def add_currency(self, currency_code, rate_to_usd):
        self.rates[currency_code] = rate_to_usd
    
    def convert(self, amount, from_currency, to_currency):
        if from_currency not in self.rates or to_currency not in self.rates:
            return None
        
        # Конвертируем через USD
        amount_in_usd = amount / self.rates[from_currency]
        converted_amount = amount_in_usd * self.rates[to_currency]
        
        return converted_amount
    
    def get_available_currencies(self):
        return list(self.rates.keys())
    
    def update_rate(self, currency_code, new_rate):
        if currency_code in self.rates:
            self.rates[currency_code] = new_rate
            return True
        return False

# Тестирование
converter = CurrencyConverter()
print(f"Доступные валюты: {converter.get_available_currencies()}")

# Конвертируем 100 USD в EUR
converted = converter.convert(100, "USD", "EUR")
print(f"100 USD = {converted:.2f} EUR")

# Конвертируем 5000 RUB в USD
converted = converter.convert(5000, "RUB", "USD")
print(f"5000 RUB = {converted:.2f} USD")

# Добавляем новую валюту
converter.add_currency("CNY", 6.5)
print(f"После добавления CNY: {converter.get_available_currencies()}")
```
Ключевые моменты:
```
Создание: {}, dict(), {key: value}
Доступ: dict[key], dict.get(key, default)
Методы: keys(), values(), items(), update(), pop(), get(), setdefault()
Проверка: key in dict
Копирование: copy(), deepcopy()
Включения: {k: v for k, v in iterable}
Объединение: dict1 | dict2, dict1.update(dict2)
Применение: конфигурации, базы данных, подсчет частот, кэширование
Основные операции со словарями.
```
 «Основные операции со словарями»
Тема: Основные операции со словарями
```
Слайд 1: Теория — Основные операции со словарями
Словарь — структура данных "ключ-значение"
Основные операции делятся на четыре категории:

Операции доступа — получение значений по ключам

Операции модификации — добавление, изменение, удаление

Операции проверки — проверка наличия элементов

Операции обхода — итерация по элементам

Особенности:

Быстрый доступ O(1) по ключу

Ключи должны быть хешируемыми

Сохраняют порядок вставки (Python 3.7+)

```
Слайд 2: Пример 1 — Операции доступа к элементам
Задача: Показать различные способы доступа к элементам словаря.

```python
print("=== Операции доступа к элементам ===")

# Создаем словарь для демонстрации
student = {
    "name": "Анна Иванова",
    "age": 20,
    "grades": [4, 5, 4, 5],
    "contact": {
        "email": "anna@mail.ru",
        "phone": "+79123456789"
    },
    "subjects": {"математика", "физика", "программирование"}
}

print(f"Словарь student: {student}")

print("\n--- Прямой доступ через ключ ---")
# Прямой доступ - вызовет ошибку если ключа нет
print(f"student['name']: {student['name']}")
print(f"student['age']: {student['age']}")
print(f"student['contact']['email']: {student['contact']['email']}")

# Попытка доступа к несуществующему ключу
try:
    print(f"student['address']: {student['address']}")
except KeyError as e:
    print(f"Ошибка KeyError: {e}")

print("\n--- Безопасный доступ через get() ---")
# get() - возвращает None если ключа нет
print(f"student.get('name'): {student.get('name')}")
print(f"student.get('address'): {student.get('address')}")

# get() с значением по умолчанию
print(f"student.get('address', 'Не указан'): {student.get('address', 'Не указан')}")
print(f"student.get('salary', 0): {student.get('salary', 0)}")

print("\n--- Метод setdefault() ---")
# setdefault() - получить значение, если нет - установить и вернуть
current_age = student.setdefault("age", 0)  # Ключ есть - вернет значение
new_city = student.setdefault("city", "Москва")  # Ключа нет - установит и вернет
print(f"setdefault('age', 0): {current_age}")
print(f"setdefault('city', 'Москва'): {new_city}")
print(f"Словарь после setdefault(): {student}")

print("\n--- Доступ ко всем элементам ---")
# keys() - все ключи
print(f"Ключи: {list(student.keys())}")

# values() - все значения  
print(f"Значения: {list(student.values())}")

# items() - все пары ключ-значение
print(f"Пары ключ-значение: {list(student.items())}")

print("\n--- Извлечение элементов ---")
# pop() - извлечение по ключу с удалением
removed_age = student.pop("age")
print(f"После pop('age'): {student}")
print(f"Удаленное значение: {removed_age}")

# popitem() - извлечение последней пары (Python 3.7+)
last_item = student.popitem()
print(f"После popitem(): {student}")
print(f"Последняя пара: {last_item}")
```
Вывод в консоли:
```bash
=== Операции доступа к элементам ===
Словарь student: {'name': 'Анна Иванова', 'age': 20, 'grades': [4, 5, 4, 5], 'contact': {'email': 'anna@mail.ru', 'phone': '+79123456789'}, 'subjects': {'математика', 'программирование', 'физика'}}

--- Прямой доступ через ключ ---
student['name']: Анна Иванова
student['age']: 20
student['contact']['email']: anna@mail.ru
Ошибка KeyError: 'address'

--- Безопасный доступ через get() ---
student.get('name'): Анна Иванова
student.get('address'): None
student.get('address', 'Не указан'): Не указан
student.get('salary', 0): 0

--- Метод setdefault() ---
setdefault('age', 0): 20
setdefault('city', 'Москва'): Москва
Словарь после setdefault(): {'name': 'Анна Иванова', 'age': 20, 'grades': [4, 5, 4, 5], 'contact': {'email': 'anna@mail.ru', 'phone': '+79123456789'}, 'subjects': {'математика', 'программирование', 'физика'}, 'city': 'Москва'}

--- Доступ ко всем элементам ---
Ключи: ['name', 'age', 'grades', 'contact', 'subjects', 'city']
Значения: ['Анна Иванова', 20, [4, 5, 4, 5], {'email': 'anna@mail.ru', 'phone': '+79123456789'}, {'математика', 'программирование', 'физика'}, 'Москва']
Пары ключ-значение: [('name', 'Анна Иванова'), ('age', 20), ('grades', [4, 5, 4, 5]), ('contact', {'email': 'anna@mail.ru', 'phone': '+79123456789'}), ('subjects', {'математика', 'программирование', 'физика'}), ('city', 'Москва')]

--- Извлечение элементов ---
После pop('age'): {'name': 'Анна Иванова', 'grades': [4, 5, 4, 5], 'contact': {'email': 'anna@mail.ru', 'phone': '+79123456789'}, 'subjects': {'математика', 'программирование', 'физика'}, 'city': 'Москва'}
Удаленное значение: 20
После popitem(): {'name': 'Анна Иванова', 'grades': [4, 5, 4, 5], 'contact': {'email': 'anna@mail.ru', 'phone': '+79123456789'}, 'subjects': {'математика', 'программирование', 'физика'}}
Последняя пара: ('city', 'Москва')
```
Слайд 3: Пример 2 — Операции модификации словарей
Задача: Показать операции для изменения словарей.
```python
print("=== Операции модификации словарей ===")

# Создаем словари для демонстрации
person = {"name": "Иван", "age": 25, "city": "Москва"}
additional_info = {"salary": 100000, "department": "IT"}

print(f"Исходный person: {person}")
print(f"Дополнительная информация: {additional_info}")

print("\n--- Добавление и изменение элементов ---")
# Прямое присваивание
person["age"] = 26  # Изменение существующего
person["email"] = "ivan@mail.ru"  # Добавление нового
print(f"После прямого присваивания: {person}")

# Метод update() - массовое обновление
person.update({"city": "Санкт-Петербург", "phone": "+79123456789"})
person.update(additional_info)
print(f"После update(): {person}")

print("\n--- Удаление элементов ---")
print(f"Текущий словарь: {person}")

# del - удаление по ключу
del person["phone"]
print(f"После del person['phone']: {person}")

# pop() - удаление с возвратом значения
removed_salary = person.pop("salary")
print(f"После pop('salary'): {person}")
print(f"Удаленная зарплата: {removed_salary}")

# pop() с значением по умолчанию
removed_bonus = person.pop("bonus", 0)  # Не будет ошибки
print(f"После pop('bonus', 0): {person}")
print(f"Удаленный бонус: {removed_bonus}")

# popitem() - удаление последней пары
last_item = person.popitem()
print(f"После popitem(): {person}")
print(f"Удаленная пара: {last_item}")

# clear() - полная очистка
person.clear()
print(f"После clear(): {person}")

print("\n--- Копирование словарей ---")
original = {"a": 1, "b": [2, 3, 4], "c": {"d": 5}}
print(f"Оригинал: {original}")

# Поверхностное копирование
shallow_copy = original.copy()
print(f"Поверхностная копия: {shallow_copy}")

# Изменяем вложенную структуру в копии
shallow_copy["b"].append(5)
shallow_copy["c"]["d"] = 10
print(f"После изменения вложенных структур в копии:")
print(f"Оригинал: {original}")  # Изменился!
print(f"Копия: {shallow_copy}")

print("\n--- Глубокое копирование ---")
import copy
deep_copy = copy.deepcopy(original)
deep_copy["b"].append(6)
deep_copy["c"]["d"] = 15
print(f"После глубокого копирования и изменения:")
print(f"Оригинал: {original}")  # Не изменился!
print(f"Глубокая копия: {deep_copy}")

print("\n--- Создание словарей ---")
# fromkeys() - создание словаря с общим значением
keys = ["name", "age", "city"]
default_none = dict.fromkeys(keys)
default_value = dict.fromkeys(keys, "неизвестно")
print(f"fromkeys(keys): {default_none}")
print(f"fromkeys(keys, 'неизвестно'): {default_value}")

# Создание из двух последовательностей
names = ["Анна", "Борис", "Мария"]
ages = [25, 30, 28]
from_zip = dict(zip(names, ages))
print(f"Из двух списков: {from_zip}")
```
Вывод в консоли:
```bash
=== Операции модификации словарей ===
Исходный person: {'name': 'Иван', 'age': 25, 'city': 'Москва'}
Дополнительная информация: {'salary': 100000, 'department': 'IT'}

--- Добавление и изменение элементов ---
После прямого присваивания: {'name': 'Иван', 'age': 26, 'city': 'Москва', 'email': 'ivan@mail.ru'}
После update(): {'name': 'Иван', 'age': 26, 'city': 'Санкт-Петербург', 'email': 'ivan@mail.ru', 'phone': '+79123456789', 'salary': 100000, 'department': 'IT'}

--- Удаление элементов ---
Текущий словарь: {'name': 'Иван', 'age': 26, 'city': 'Санкт-Петербург', 'email': 'ivan@mail.ru', 'phone': '+79123456789', 'salary': 100000, 'department': 'IT'}
После del person['phone']: {'name': 'Иван', 'age': 26, 'city': 'Санкт-Петербург', 'email': 'ivan@mail.ru', 'salary': 100000, 'department': 'IT'}
После pop('salary'): {'name': 'Иван', 'age': 26, 'city': 'Санкт-Петербург', 'email': 'ivan@mail.ru', 'department': 'IT'}
Удаленная зарплата: 100000
После pop('bonus', 0): {'name': 'Иван', 'age': 26, 'city': 'Санкт-Петербург', 'email': 'ivan@mail.ru', 'department': 'IT'}
Удаленный бонус: 0
После popitem(): {'name': 'Иван', 'age': 26, 'city': 'Санкт-Петербург', 'email': 'ivan@mail.ru'}
Удаленная пара: ('department', 'IT')
После clear(): {}

--- Копирование словарей ---
Оригинал: {'a': 1, 'b': [2, 3, 4], 'c': {'d': 5}}
Поверхностная копия: {'a': 1, 'b': [2, 3, 4], 'c': {'d': 5}}
После изменения вложенных структур в копии:
Оригинал: {'a': 1, 'b': [2, 3, 4, 5], 'c': {'d': 10}}
Копия: {'a': 1, 'b': [2, 3, 4, 5], 'c': {'d': 10}}

--- Глубокое копирование ---
После глубокого копирования и изменения:
Оригинал: {'a': 1, 'b': [2, 3, 4, 5], 'c': {'d': 10}}
Глубокая копия: {'a': 1, 'b': [2, 3, 4, 5, 6], 'c': {'d': 15}}

--- Создание словарей ---
fromkeys(keys): {'name': None, 'age': None, 'city': None}
fromkeys(keys, 'неизвестно'): {'name': 'неизвестно', 'age': 'неизвестно', 'city': 'неизвестно'}
Из двух списков: {'Анна': 25, 'Борис': 30, 'Мария': 28}
```
Слайд 4: Пример 3 — Операции проверки и обхода
Задача: Показать операции проверки элементов и обхода словарей.
```python
print("=== Операции проверки и обхода ===")

# Создаем словарь для демонстрации
inventory = {
    "яблоки": {"цена": 80, "количество": 150, "категория": "фрукты"},
    "бананы": {"цена": 60, "количество": 200, "категория": "фрукты"},
    "молоко": {"цена": 70, "количество": 50, "категория": "молочные"},
    "хлеб": {"цена": 40, "количество": 30, "категория": "выпечка"},
    "сыр": {"цена": 300, "количество": 20, "категория": "молочные"}
}

print(f"Инвентарь: {inventory}")

print("\n--- Проверка наличия элементов ---")
# Проверка ключей
print(f"'яблоки' in inventory: {'яблоки' in inventory}")
print(f"'виноград' in inventory: {'виноград' in inventory}")
print(f"'молоко' not in inventory: {'молоко' not in inventory}")

# Проверка длины
print(f"Количество товаров: {len(inventory)}")

# Проверка на пустоту
empty_dict = {}
print(f"inventory пуст: {not inventory}")
print(f"empty_dict пуст: {not empty_dict}")

print("\n--- Обход ключей ---")
print("Все товары:")
for product in inventory:
    print(f"  - {product}")

print("\nКлючи через метод keys():")
for key in inventory.keys():
    print(f"  - {key}")

print("\n--- Обход значений ---")
print("Информация о товарах:")
for details in inventory.values():
    print(f"  - Цена: {details['цена']}, Количество: {details['количество']}")

print("\n--- Обход пар ключ-значение ---")
print("Полная информация:")
for product, details in inventory.items():
    print(f"  {product}: {details['цена']} руб., {details['количество']} шт.")

print("\n--- Условный обход ---")
print("Товары категории 'фрукты':")
for product, details in inventory.items():
    if details["категория"] == "фрукты":
        print(f"  - {product}")

print("\nТовары дороже 100 руб.:")
for product, details in inventory.items():
    if details["цена"] > 100:
        print(f"  - {product}: {details['цена']} руб.")

print("\n--- Поиск элементов ---")
# Поиск товаров по критерию
def find_products_by_category(category):
    return {product: details for product, details in inventory.items() 
            if details["категория"] == category}

def find_expensive_products(threshold=100):
    return {product: details for product, details in inventory.items() 
            if details["цена"] > threshold}

def find_low_stock_products(max_quantity=50):
    return {product: details for product, details in inventory.items() 
            if details["количество"] <= max_quantity}

print(f"Молочные продукты: {find_products_by_category('молочные')}")
print(f"Дорогие товары: {find_expensive_products()}")
print(f"Товары с низким запасом: {find_low_stock_products()}")

print("\n--- Сортировка при обходе ---")
print("Товары отсортированные по цене:")
for product, details in sorted(inventory.items(), key=lambda x: x[1]["цена"]):
    print(f"  {product}: {details['цена']} руб.")

print("\nТовары отсортированные по названию:")
for product, details in sorted(inventory.items()):
    print(f"  {product}: {details['цена']} руб.")
```
Вывод в консоли:
```bash
=== Операции проверки и обхода ===
Инвентарь: {'яблоки': {'цена': 80, 'количество': 150, 'категория': 'фрукты'}, 'бананы': {'цена': 60, 'количество': 200, 'категория': 'фрукты'}, 'молоко': {'цена': 70, 'количество': 50, 'категория': 'молочные'}, 'хлеб': {'цена': 40, 'количество': 30, 'категория': 'выпечка'}, 'сыр': {'цена': 300, 'количество': 20, 'категория': 'молочные'}}

--- Проверка наличия элементов ---
'яблоки' in inventory: True
'виноград' in inventory: False
'молоко' not in inventory: False
Количество товаров: 5
inventory пуст: False
empty_dict пуст: True

--- Обход ключей ---
Все товары:
  - яблоки
  - бананы
  - молоко
  - хлеб
  - сыр

Ключи через метод keys():
  - яблоки
  - бананы
  - молоко
  - хлеб
  - сыр

--- Обход значений ---
Информация о товарах:
  - Цена: 80, Количество: 150
  - Цена: 60, Количество: 200
  - Цена: 70, Количество: 50
  - Цена: 40, Количество: 30
  - Цена: 300, Количество: 20

--- Обход пар ключ-значение ---
Полная информация:
  яблоки: 80 руб., 150 шт.
  бананы: 60 руб., 200 шт.
  молоко: 70 руб., 50 шт.
  хлеб: 40 руб., 30 шт.
  сыр: 300 руб., 20 шт.

--- Условный обход ---
Товары категории 'фрукты':
  - яблоки
  - бананы

Товары дороже 100 руб.:
  - сыр: 300 руб.

--- Поиск элементов ---
Молочные продукты: {'молоко': {'цена': 70, 'количество': 50, 'категория': 'молочные'}, 'сыр': {'цена': 300, 'количество': 20, 'категория': 'молочные'}}
Дорогие товары: {'сыр': {'цена': 300, 'количество': 20, 'категория': 'молочные'}}
Товары с низким запасом: {'молоко': {'цена': 70, 'количество': 50, 'категория': 'молочные'}, 'хлеб': {'цена': 40, 'количество': 30, 'категория': 'выпечка'}, 'сыр': {'цена': 300, 'количество': 20, 'категория': 'молочные'}}

--- Сортировка при обходе ---
Товары отсортированные по цене:
  хлеб: 40 руб.
  бананы: 60 руб.
  молоко: 70 руб.
  яблоки: 80 руб.
  сыр: 300 руб.

Товары отсортированные по названию:
  бананы: 60 руб.
  молоко: 70 руб.
  хлеб: 40 руб.
  сыр: 300 руб.
  яблоки: 80 руб.
```
Слайд 5: Пример 4 — Комбинированные операции и практическое применение
Задача: Показать комбинированные операции и реальные примеры использования.
```python
print("=== Комбинированные операции и практическое применение ===")

print("\n--- Агрегация данных ---")
# Подсчет частоты слов в тексте
def word_frequency(text):
    words = text.lower().split()
    frequency = {}
    
    for word in words:
        # Очищаем слово от знаков препинания
        clean_word = word.strip('.,!?;:"')
        if clean_word:
            frequency[clean_word] = frequency.get(clean_word, 0) + 1
    
    return frequency

text = "Быстрая коричневая лиса прыгает через ленивую собаку. Лиса быстрая и умная."
freq = word_frequency(text)
print(f"Частота слов: {freq}")

# Находим самые частые слова
most_common = sorted(freq.items(), key=lambda x: x[1], reverse=True)[:3]
print(f"Самые частые слова: {most_common}")

print("\n--- Группировка данных ---")
# Группировка студентов по группам
students = [
    {"name": "Анна", "group": "ИТ-21", "grade": 4.5},
    {"name": "Борис", "group": "ИТ-22", "grade": 3.8},
    {"name": "Виктор", "group": "ИТ-21", "grade": 4.2},
    {"name": "Дарья", "group": "ИТ-22", "grade": 4.8},
    {"name": "Елена", "group": "ИТ-21", "grade": 4.0}
]

def group_students_by_group(students_list):
    groups = {}
    for student in students_list:
        group = student["group"]
        if group not in groups:
            groups[group] = []
        groups[group].append(student)
    return groups

grouped = group_students_by_group(students)
print("Студенты по группам:")
for group, students_in_group in grouped.items():
    print(f"  {group}: {[s['name'] for s in students_in_group]}")

print("\n--- Объединение словарей ---")
# Объединение словарей разными способами
dict1 = {"a": 1, "b": 2, "c": 3}
dict2 = {"c": 30, "d": 4, "e": 5}
dict3 = {"f": 6, "g": 7}

print(f"dict1: {dict1}")
print(f"dict2: {dict2}")
print(f"dict3: {dict3}")

# Метод update() (изменяет исходный)
dict1.update(dict2)
print(f"После dict1.update(dict2): {dict1}")

# Оператор | (Python 3.9+, создает новый)
merged = dict2 | dict3
print(f"dict2 | dict3: {merged}")

# Распаковка (Python 3.5+)
unpacked = {**dict2, **dict3}
print(f"Распаковка {{**dict2, **dict3}}: {unpacked}")

print("\n--- Практический пример: система конфигурации ---")
class ConfigManager:
    def __init__(self, default_config=None):
        self.default_config = default_config or {}
        self.user_config = {}
        self.current_config = self.default_config.copy()
    
    def set_user_config(self, user_config):
        self.user_config = user_config
        self._update_current_config()
    
    def _update_current_config(self):
        # Обновляем текущую конфигурацию (пользовательские настройки имеют приоритет)
        self.current_config = self.default_config.copy()
        self.current_config.update(self.user_config)
    
    def get(self, key, default=None):
        return self.current_config.get(key, default)
    
    def set(self, key, value):
        self.user_config[key] = value
        self._update_current_config()
    
    def show_config(self):
        print("Текущая конфигурация:")
        for key, value in self.current_config.items():
            print(f"  {key}: {value}")

# Использование
default_config = {
    "host": "localhost",
    "port": 8080,
    "debug": False,
    "max_connections": 100
}

user_config = {
    "port": 9000,
    "debug": True,
    "timeout": 30
}

config_manager = ConfigManager(default_config)
config_manager.set_user_config(user_config)
config_manager.show_config()

print(f"\nПолучение значений:")
print(f"  host: {config_manager.get('host')}")
print(f"  port: {config_manager.get('port')}")
print(f"  unknown: {config_manager.get('unknown', 'default_value')}")

print("\n--- Работа с вложенными структурами ---")
# Обработка сложных JSON-подобных структур
company_data = {
    "company": "ТехноКорп",
    "departments": {
        "IT": {
            "employees": 10,
            "budget": 500000,
            "projects": ["Система А", "Система Б"]
        },
        "HR": {
            "employees": 3,
            "budget": 200000,
            "projects": ["Рекрутинг", "Обучение"]
        }
    },
    "locations": ["Москва", "Санкт-Петербург"]
}

def get_nested_value(data, path, default=None):
    """Получение значения по вложенному пути"""
    keys = path.split(".")
    current = data
    for key in keys:
        if isinstance(current, dict) and key in current:
            current = current[key]
        else:
            return default
    return current

def set_nested_value(data, path, value):
    """Установка значения по вложенному пути"""
    keys = path.split(".")
    current = data
    for key in keys[:-1]:
        if key not in current or not isinstance(current[key], dict):
            current[key] = {}
        current = current[key]
    current[keys[-1]] = value

# Тестирование
print(f"company.departments.IT.employees: {get_nested_value(company_data, 'departments.IT.employees')}")
print(f"company.locations.0: {get_nested_value(company_data, 'locations.0')}")

set_nested_value(company_data, "departments.IT.employees", 12)
set_nested_value(company_data, "ceo.name", "Иван Иванов")
print(f"После изменений: {company_data}")
```
Вывод в консоли:
```bash
=== Комбинированные операции и практическое применение ===

--- Агрегация данных ---
Частота слов: {'быстрая': 2, 'коричневая': 1, 'лиса': 2, 'прыгает': 1, 'через': 1, 'ленивую': 1, 'собаку': 1, 'умная': 1, 'и': 1}
Самые частые слова: [('быстрая', 2), ('лиса', 2), ('коричневая', 1)]

--- Группировка данных ---
Студенты по группам:
  ИТ-21: ['Анна', 'Виктор', 'Елена']
  ИТ-22: ['Борис', 'Дарья']

--- Объединение словарей ---
dict1: {'a': 1, 'b': 2, 'c': 3}
dict2: {'c': 30, 'd': 4, 'e': 5}
dict3: {'f': 6, 'g': 7}
После dict1.update(dict2): {'a': 1, 'b': 2, 'c': 30, 'd': 4, 'e': 5}
dict2 | dict3: {'c': 30, 'd': 4, 'e': 5, 'f': 6, 'g': 7}
Распаковка {**dict2, **dict3}: {'c': 30, 'd': 4, 'e': 5, 'f': 6, 'g': 7}

--- Практический пример: система конфигурации ---
Текущая конфигурация:
  host: localhost
  port: 9000
  debug: True
  max_connections: 100
  timeout: 30

Получение значений:
  host: localhost
  port: 9000
  unknown: default_value

--- Работа с вложенными структурами ---
company.departments.IT.employees: 10
company.locations.0: Москва
После изменений: {'company': 'ТехноКорп', 'departments': {'IT': {'employees': 12, 'budget': 500000, 'projects': ['Система А', 'Система Б']}, 'HR': {'employees': 3, 'budget': 200000, 'projects': ['Рекрутинг', 'Обучение']}}, 'locations': ['Москва', 'Санкт-Петербург'], 'ceo': {'name': 'Иван Иванов'}}
```
Слайд 6: Задания для практики
Задание 1: Анализатор цен
```python
# Напишите функцию для анализа цен товаров:
# 1. Находит самый дорогой и самый дешевый товар
# 2. Считает среднюю цену
# 3. Группирует товары по ценовым категориям
# 4. Используйте операции со словарями
# Ваш код здесь
```
Задание 2: Система голосования
```python
# Напишите систему подсчета голосов:
# 1. Подсчитывает голоса за каждого кандидата
# 2. Находит победителя
# 3. Считает процент голосов
# 4. Используйте словарь для хранения результатов
# Ваш код здесь
```
Задание 3: Обработчик контактов
```python
# Напишите систему управления контактами:
# 1. Добавление, удаление, поиск контактов
# 2. Группировка контактов по категориям
# 3. Поиск по имени или телефону
# 4. Используйте словарь для хранения контактов
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Анализатор цен
def price_analyzer(products):
    if not products:
        return "Нет товаров для анализа"
    
    # Самый дорогой и дешевый товар
    most_expensive = max(products.items(), key=lambda x: x[1])
    cheapest = min(products.items(), key=lambda x: x[1])
    
    # Средняя цена
    average_price = sum(products.values()) / len(products)
    
    # Группировка по ценовым категориям
    price_categories = {
        "бюджетные": {},
        "средние": {},
        "премиум": {}
    }
    
    for product, price in products.items():
        if price < 100:
            price_categories["бюджетные"][product] = price
        elif price < 500:
            price_categories["средние"][product] = price
        else:
            price_categories["премиум"][product] = price
    
    return {
        "most_expensive": most_expensive,
        "cheapest": cheapest,
        "average_price": average_price,
        "price_categories": price_categories
    }

# Тестирование
products = {
    "яблоки": 80,
    "бананы": 60,
    "молоко": 70,
    "хлеб": 40,
    "сыр": 300,
    "икра": 2000
}

result = price_analyzer(products)
print(f"Самый дорогой: {result['most_expensive']}")
print(f"Самый дешевый: {result['cheapest']}")
print(f"Средняя цена: {result['average_price']:.2f}")
print("Ценовые категории:")
for category, items in result['price_categories'].items():
    print(f"  {category}: {items}")

# #Задание 2: Система голосования
class VotingSystem:
    def __init__(self, candidates):
        self.candidates = {candidate: 0 for candidate in candidates}
        self.total_votes = 0
    
    def vote(self, candidate):
        if candidate in self.candidates:
            self.candidates[candidate] += 1
            self.total_votes += 1
            return True
        return False
    
    def get_results(self):
        if self.total_votes == 0:
            return "Голосов нет"
        
        results = {}
        for candidate, votes in self.candidates.items():
            percentage = (votes / self.total_votes) * 100 if self.total_votes > 0 else 0
            results[candidate] = {
                "votes": votes,
                "percentage": percentage
            }
        
        # Находим победителя
        winner = max(self.candidates.items(), key=lambda x: x[1])
        
        return {
            "results": results,
            "winner": winner,
            "total_votes": self.total_votes
        }
    
    def show_results(self):
        results = self.get_results()
        if isinstance(results, str):
            print(results)
            return
        
        print("Результаты голосования:")
        for candidate, data in results["results"].items():
            print(f"  {candidate}: {data['votes']} голосов ({data['percentage']:.1f}%)")
        
        print(f"Победитель: {results['winner'][0]} с {results['winner'][1]} голосами")

# Тестирование
voting = VotingSystem(["Анна", "Борис", "Виктор"])
voting.vote("Анна")
voting.vote("Анна")
voting.vote("Борис")
voting.vote("Виктор")
voting.vote("Анна")
voting.show_results()

# #Задание 3: Обработчик контактов
class ContactManager:
    def __init__(self):
        self.contacts = {}
        self.categories = {}
    
    def add_contact(self, name, phone, email=None, category="друзья"):
        self.contacts[name] = {
            "phone": phone,
            "email": email,
            "category": category
        }
        
        # Добавляем в категорию
        if category not in self.categories:
            self.categories[category] = []
        self.categories[category].append(name)
    
    def remove_contact(self, name):
        if name in self.contacts:
            category = self.contacts[name]["category"]
            # Удаляем из категории
            if category in self.categories and name in self.categories[category]:
                self.categories[category].remove(name)
                if not self.categories[category]:  # Если категория пуста
                    del self.categories[category]
            
            # Удаляем из контактов
            del self.contacts[name]
            return True
        return False
    
    def find_contact(self, search_term):
        results = {}
        for name, info in self.contacts.items():
            if (search_term.lower() in name.lower() or 
                search_term in info["phone"] or
                (info["email"] and search_term.lower() in info["email"].lower())):
                results[name] = info
        return results
    
    def get_contacts_by_category(self, category):
        if category in self.categories:
            return {name: self.contacts[name] for name in self.categories[category]}
        return {}
    
    def show_all_contacts(self):
        if not self.contacts:
            print("Контактов нет")
            return
        
        print("Все контакты:")
        for name, info in self.contacts.items():
            print(f"  {name}: тел. {info['phone']}, email: {info['email'] or 'нет'}")
    
    def show_categories(self):
        print("Категории контактов:")
        for category, contacts in self.categories.items():
            print(f"  {category}: {len(contacts)} контактов")

# Тестирование
manager = ContactManager()
manager.add_contact("Анна", "+79123456789", "anna@mail.ru", "друзья")
manager.add_contact("Борис", "+79123456780", "boris@mail.ru", "работа")
manager.add_contact("Виктор", "+79123456781", category="друзья")

manager.show_all_contacts()
manager.show_categories()

print(f"\nПоиск 'Анна': {manager.find_contact('Анна')}")
print(f"Контакты категории 'друзья': {manager.get_contacts_by_category('друзья')}")
```
Ключевые моменты:
```
Доступ: dict[key], dict.get(key, default), dict.setdefault()
Модификация: dict[key] = value, update(), pop(), popitem(), clear()
Проверка: key in dict, len(dict), bool(dict)
Обход: for key in dict, for value in dict.values(), for k, v in dict.items()
Копирование: copy(), deepcopy()
Создание: {}, dict(), fromkeys(), dict(zip())
Объединение: update(), |, {**d1, **d2}
Применение: конфигурации, агрегация данных, группировка, кэширование
Примеры вложенных структур.
```
 «Примеры вложенных структур»
Тема: Примеры вложенных структур
```
Слайд 1: Теория — Вложенные структуры данных
Вложенные структуры — структуры данных, содержащие другие структуры данных
Основные типы вложений:

Словари в словарях — сложные объекты с иерархией

Списки в словарях — коллекции связанных данных

Словари в списках — списки объектов с атрибутами

Комбинированные структуры — смешанные вложения

Преимущества:

Естественное моделирование реальных объектов

Группировка связанных данных

Гибкость в организации информации

```
Слайд 2: Пример 1 — Словари в словарях (глубокое вложение)
Задача: Показать глубоко вложенные словари для моделирования сложных объектов.
```python
print("=== Словари в словарях (глубокое вложение) ===")

# Модель компании с отделами и сотрудниками
company = {
    "company_info": {
        "name": "ТехноКорп",
        "founded": 2010,
        "ceo": "Петр Алексеев",
        "headquarters": {
            "city": "Москва",
            "address": "ул. Пушкина, 1",
            "phone": "+74951234567"
        }
    },
    "departments": {
        "IT": {
            "manager": "Иван Сидоров",
            "budget": 5000000,
            "employees": {
                "Анна Петрова": {
                    "position": "разработчик",
                    "salary": 120000,
                    "skills": ["Python", "JavaScript", "SQL"],
                    "projects": ["Система А", "Система Б"]
                },
                "Борис Иванов": {
                    "position": "тестировщик", 
                    "salary": 90000,
                    "skills": ["Selenium", "Jest", "Postman"],
                    "projects": ["Система А"]
                }
            }
        },
        "HR": {
            "manager": "Ольга Новикова",
            "budget": 2000000,
            "employees": {
                "Дмитрий Смирнов": {
                    "position": "рекрутер",
                    "salary": 80000,
                    "skills": ["интервью", "оценка", "подбор"],
                    "projects": ["Массовый найм"]
                }
            }
        }
    }
}

print("Структура компании:")
print(f"Название: {company['company_info']['name']}")
print(f"CEO: {company['company_info']['ceo']}")
print(f"Город: {company['company_info']['headquarters']['city']}")

print("\n--- Доступ к глубоко вложенным данным ---")
# Функция для поиска сотрудника
def find_employee(company_data, employee_name):
    for dept_name, dept_info in company_data["departments"].items():
        if employee_name in dept_info["employees"]:
            return dept_name, dept_info["employees"][employee_name]
    return None, None

# Поиск сотрудника
employee = "Анна Петрова"
dept, info = find_employee(company, employee)
if dept:
    print(f"Сотрудник {employee}:")
    print(f"  Отдел: {dept}")
    print(f"  Должность: {info['position']}")
    print(f"  Навыки: {', '.join(info['skills'])}")

print("\n--- Модификация вложенных структур ---")
# Добавление нового сотрудника
company["departments"]["IT"]["employees"]["Виктор Орлов"] = {
    "position": "DevOps",
    "salary": 130000,
    "skills": ["Docker", "Kubernetes", "AWS"],
    "projects": ["Система Б"]
}

# Обновление зарплаты
company["departments"]["IT"]["employees"]["Анна Петрова"]["salary"] = 125000

print("После изменений:")
print(f"Новый сотрудник: {list(company['departments']['IT']['employees'].keys())}")
print(f"Зарплата Анны: {company['departments']['IT']['employees']['Анна Петрова']['salary']}")

print("\n--- Обход вложенных структур ---")
def print_company_structure(company_data, level=0):
    indent = "  " * level
    if "name" in company_data:
        print(f"{indent}Компания: {company_data['name']}")
    
    if "departments" in company_data:
        print(f"{indent}Отделы:")
        for dept_name, dept_info in company_data["departments"].items():
            print(f"{indent}  {dept_name}:")
            print(f"{indent}    Менеджер: {dept_info['manager']}")
            print(f"{indent}    Сотрудники: {len(dept_info['employees'])}")

print_company_structure(company)
```
Вывод в консоли:
```bash
=== Словари в словарях (глубокое вложение) ===
Структура компании:
Название: ТехноКорп
CEO: Петр Алексеев
Город: Москва

--- Доступ к глубоко вложенным данным ---
Сотрудник Анна Петрова:
  Отдел: IT
  Должность: разработчик
  Навыки: Python, JavaScript, SQL

--- Модификация вложенных структур ---
После изменений:
Новый сотрудник: ['Анна Петрова', 'Борис Иванов', 'Виктор Орлов']
Зарплата Анны: 125000

--- Обход вложенных структур ---
Компания: ТехноКорп
Отделы:
  IT:
    Менеджер: Иван Сидоров
    Сотрудники: 3
  HR:
    Менеджер: Ольга Новикова
    Сотрудники: 1
```
Слайд 3: Пример 2 — Списки в словарях (коллекции данных)
Задача: Показать использование списков внутри словарей для хранения коллекций.
```python
print("=== Списки в словарях (коллекции данных) ===")

# Система учета студентов с курсами и оценками
university = {
    "students": {
        "С001": {
            "name": "Анна Иванова",
            "age": 20,
            "courses": [
                {
                    "name": "Математика",
                    "credits": 6,
                    "grades": [5, 4, 5, 4],
                    "teacher": "Петров И.И."
                },
                {
                    "name": "Программирование", 
                    "credits": 5,
                    "grades": [5, 5, 4, 5],
                    "teacher": "Сидоров А.В."
                }
            ]
        },
        "С002": {
            "name": "Борис Петров",
            "age": 21, 
            "courses": [
                {
                    "name": "Математика",
                    "credits": 6,
                    "grades": [3, 4, 3, 4],
                    "teacher": "Петров И.И."
                },
                {
                    "name": "Физика",
                    "credits": 4,
                    "grades": [4, 4, 3, 5],
                    "teacher": "Козлова М.Н."
                }
            ]
        }
    },
    "teachers": {
        "Петров И.И.": {
            "subject": "Математика",
            "students_count": 2,
            "office": "101"
        },
        "Сидоров А.В.": {
            "subject": "Программирование", 
            "students_count": 1,
            "office": "205"
        }
    }
}

print("--- Анализ успеваемости ---")
def calculate_student_stats(student_id):
    student = university["students"][student_id]
    print(f"Студент: {student['name']}")
    
    total_credits = 0
    total_grades = 0
    grade_count = 0
    
    for course in student["courses"]:
        course_avg = sum(course["grades"]) / len(course["grades"])
        print(f"  {course['name']}: средний балл {course_avg:.2f}")
        
        total_credits += course["credits"]
        total_grades += sum(course["grades"])
        grade_count += len(course["grades"])
    
    overall_avg = total_grades / grade_count if grade_count > 0 else 0
    print(f"Общий средний балл: {overall_avg:.2f}")
    print(f"Всего кредитов: {total_credits}")

calculate_student_stats("С001")

print("\n--- Добавление новых данных ---")
# Добавление нового курса студенту
new_course = {
    "name": "Базы данных",
    "credits": 4,
    "grades": [5, 5, 4],
    "teacher": "Иванова С.М."
}

university["students"]["С001"]["courses"].append(new_course)

# Добавление нового преподавателя
university["teachers"]["Иванова С.М."] = {
    "subject": "Базы данных",
    "students_count": 1,
    "office": "305"
}

print("После добавления данных:")
print(f"Курсы Анны: {[course['name'] for course in university['students']['С001']['courses']]}")
print(f"Преподаватели: {list(university['teachers'].keys())}")

print("\n--- Поиск и фильтрация ---")
def find_students_by_teacher(teacher_name):
    result = []
    for student_id, student_info in university["students"].items():
        for course in student_info["courses"]:
            if course["teacher"] == teacher_name:
                result.append({
                    "student_id": student_id,
                    "student_name": student_info["name"],
                    "course": course["name"]
                })
    return result

def find_courses_with_high_grades(min_grade=4.5):
    high_grade_courses = []
    for student_id, student_info in university["students"].items():
        for course in student_info["courses"]:
            avg_grade = sum(course["grades"]) / len(course["grades"])
            if avg_grade >= min_grade:
                high_grade_courses.append({
                    "student": student_info["name"],
                    "course": course["name"],
                    "average": avg_grade
                })
    return high_grade_courses

print(f"Студенты Петрова И.И.: {find_students_by_teacher('Петров И.И.')}")
print(f"Курсы с высокими оценками: {find_courses_with_high_grades()}")
```
Вывод в консоли:
```bash
=== Списки в словарях (коллекции данных) ===
--- Анализ успеваемости ---
Студент: Анна Иванова
  Математика: средний балл 4.50
  Программирование: средний балл 4.75
Общий средний балл: 4.62
Всего кредитов: 11

--- Добавление новых данных ---
После добавления данных:
Курсы Анны: ['Математика', 'Программирование', 'Базы данных']
Преподаватели: ['Петров И.И.', 'Сидоров А.В.', 'Козлова М.Н.', 'Иванова С.М.']

--- Поиск и фильтрация ---
Студенты Петрова И.И.: [{'student_id': 'С001', 'student_name': 'Анна Иванова', 'course': 'Математика'}, {'student_id': 'С002', 'student_name': 'Борис Петров', 'course': 'Математика'}]
Курсы с высокими оценками: [{'student': 'Анна Иванова', 'course': 'Программирование', 'average': 4.75}, {'student': 'Анна Иванова', 'course': 'Базы данных', 'average': 4.666666666666667}]
```
Слайд 4: Пример 3 — Словари в списках (списки объектов)
Задача: Показать списки словарей для представления коллекций объектов.
```python
print("=== Словари в списках (списки объектов) ===")

# Интернет-магазин с товарами и заказами
online_store = {
    "products": [
        {
            "id": 1,
            "name": "Ноутбук Lenovo",
            "category": "электроника",
            "price": 50000,
            "stock": 15,
            "attributes": {
                "processor": "Intel i5",
                "ram": "8GB",
                "storage": "512GB SSD"
            },
            "reviews": [
                {"user": "Анна", "rating": 5, "comment": "Отличный ноутбук!"},
                {"user": "Борис", "rating": 4, "comment": "Хорошее качество"}
            ]
        },
        {
            "id": 2,
            "name": "Смартфон Samsung",
            "category": "электроника", 
            "price": 30000,
            "stock": 25,
            "attributes": {
                "screen": "6.1 inch",
                "camera": "48MP",
                "battery": "4000mAh"
            },
            "reviews": [
                {"user": "Виктор", "rating": 5, "comment": "Отличная камера"}
            ]
        },
        {
            "id": 3,
            "name": "Книга 'Python для начинающих'",
            "category": "книги",
            "price": 1500,
            "stock": 50,
            "attributes": {
                "author": "Иван Петров",
                "pages": 300,
                "language": "русский"
            },
            "reviews": []
        }
    ],
    "orders": [
        {
            "order_id": "ORD001",
            "customer": "Анна Иванова",
            "items": [
                {"product_id": 1, "quantity": 1, "price": 50000},
                {"product_id": 3, "quantity": 2, "price": 1500}
            ],
            "total": 53000,
            "status": "доставлен"
        },
        {
            "order_id": "ORD002", 
            "customer": "Борис Петров",
            "items": [
                {"product_id": 2, "quantity": 1, "price": 30000}
            ],
            "total": 30000,
            "status": "в обработке"
        }
    ]
}

print("--- Анализ товаров ---")
def get_products_by_category(category):
    return [product for product in online_store["products"] 
            if product["category"] == category]

def get_expensive_products(threshold=20000):
    return [product for product in online_store["products"] 
            if product["price"] > threshold]

def calculate_average_rating(product):
    if not product["reviews"]:
        return 0
    return sum(review["rating"] for review in product["reviews"]) / len(product["reviews"])

print(f"Электроника: {[p['name'] for p in get_products_by_category('электроника')]}")
print(f"Дорогие товары: {[p['name'] for p in get_expensive_products()]}")

print("\nРейтинги товаров:")
for product in online_store["products"]:
    avg_rating = calculate_average_rating(product)
    print(f"  {product['name']}: {avg_rating:.1f}★")

print("\n--- Обработка заказов ---")
def get_order_statistics():
    total_revenue = sum(order["total"] for order in online_store["orders"])
    order_count = len(online_store["orders"])
    status_count = {}
    
    for order in online_store["orders"]:
        status = order["status"]
        status_count[status] = status_count.get(status, 0) + 1
    
    return {
        "total_revenue": total_revenue,
        "order_count": order_count,
        "status_distribution": status_count
    }

def find_products_in_orders():
    product_sales = {}
    for order in online_store["orders"]:
        for item in order["items"]:
            product_id = item["product_id"]
            quantity = item["quantity"]
            product_sales[product_id] = product_sales.get(product_id, 0) + quantity
    return product_sales

stats = get_order_statistics()
sales = find_products_in_orders()

print(f"Статистика заказов:")
print(f"  Всего заказов: {stats['order_count']}")
print(f"  Общая выручка: {stats['total_revenue']} руб.")
print(f"  Статусы: {stats['status_distribution']}")
print(f"  Продажи по товарам: {sales}")

print("\n--- Добавление нового заказа ---")
new_order = {
    "order_id": "ORD003",
    "customer": "Виктор Сидоров",
    "items": [
        {"product_id": 2, "quantity": 1, "price": 30000},
        {"product_id": 3, "quantity": 1, "price": 1500}
    ],
    "total": 31500,
    "status": "новый"
}

online_store["orders"].append(new_order)

# Обновление количества товара на складе
for item in new_order["items"]:
    product_id = item["product_id"]
    quantity = item["quantity"]
    
    # Находим товар и уменьшаем количество
    for product in online_store["products"]:
        if product["id"] == product_id:
            product["stock"] -= quantity
            break

print("После добавления заказа:")
print(f"Всего заказов: {len(online_store['orders'])}")
print("Остатки на складе:")
for product in online_store["products"]:
    print(f"  {product['name']}: {product['stock']} шт.")
```
Вывод в консоли:
```bash
=== Словари в списках (списки объектов) ===
--- Анализ товаров ---
Электроника: ['Ноутбук Lenovo', 'Смартфон Samsung']
Дорогие товары: ['Ноутбук Lenovo', 'Смартфон Samsung']

Рейтинги товаров:
  Ноутбук Lenovo: 4.5★
  Смартфон Samsung: 5.0★
  Книга 'Python для начинающих': 0.0★

--- Обработка заказов ---
Статистика заказов:
  Всего заказов: 2
  Общая выручка: 83000 руб.
  Статусы: {'доставлен': 1, 'в обработке': 1}
  Продажи по товарам: {1: 1, 3: 2, 2: 1}

--- Добавление нового заказа ---
После добавления заказа:
Всего заказов: 3
Остатки на складе:
  Ноутбук Lenovo: 15 шт.
  Смартфон Samsung: 24 шт.
  Книга 'Python для начинающих': 49 шт.
```
Слайд 5: Пример 4 — Комбинированные сложные структуры
Задача: Показать сложные комбинированные структуры для реальных приложений.
```python
print("=== Комбинированные сложные структуры ===")

# Система управления проектами
project_management = {
    "company": "DevCorp Inc.",
    "teams": {
        "frontend": {
            "lead": "Анна Петрова",
            "members": ["Борис Иванов", "Виктор Сидоров"],
            "specialization": ["React", "Vue", "Angular"]
        },
        "backend": {
            "lead": "Дмитрий Козлов", 
            "members": ["Елена Новикова", "Мария Волкова"],
            "specialization": ["Python", "Node.js", "Java"]
        },
        "devops": {
            "lead": "Сергей Орлов",
            "members": ["Ольга Смирнова"],
            "specialization": ["Docker", "Kubernetes", "AWS"]
        }
    },
    "projects": [
        {
            "id": "PROJ-001",
            "name": "Электронная коммерция",
            "status": "в разработке",
            "teams_involved": ["frontend", "backend", "devops"],
            "milestones": [
                {
                    "name": "Прототип UI",
                    "deadline": "2024-03-01",
                    "status": "завершено",
                    "assigned_team": "frontend"
                },
                {
                    "name": "Бэкенд API",
                    "deadline": "2024-04-15", 
                    "status": "в работе",
                    "assigned_team": "backend"
                },
                {
                    "name": "Деплой на продакшн",
                    "deadline": "2024-06-01",
                    "status": "не начато",
                    "assigned_team": "devops"
                }
            ],
            "budget": 5000000,
            "risks": [
                {"description": "Задержки поставки", "level": "средний"},
                {"description": "Изменение требований", "level": "высокий"}
            ]
        },
        {
            "id": "PROJ-002",
            "name": "Мобильное приложение",
            "status": "планирование", 
            "teams_involved": ["frontend"],
            "milestones": [
                {
                    "name": "Дизайн макетов",
                    "deadline": "2024-02-20",
                    "status": "не начато", 
                    "assigned_team": "frontend"
                }
            ],
            "budget": 2000000,
            "risks": []
        }
    ],
    "resources": {
        "budget_allocated": 7000000,
        "budget_used": 1500000,
        "team_capacity": {
            "frontend": 3,
            "backend": 3, 
            "devops": 2
        }
    }
}

print("--- Анализ проектов ---")
def get_project_overview():
    overview = {
        "total_projects": len(project_management["projects"]),
        "by_status": {},
        "total_budget": 0,
        "team_workload": {}
    }
    
    # Инициализируем workload для всех команд
    for team in project_management["teams"]:
        overview["team_workload"][team] = 0
    
    for project in project_management["projects"]:
        # Статусы проектов
        status = project["status"]
        overview["by_status"][status] = overview["by_status"].get(status, 0) + 1
        
        # Общий бюджет
        overview["total_budget"] += project["budget"]
        
        # Нагрузка на команды
        for team in project["teams_involved"]:
            overview["team_workload"][team] += 1
    
    return overview

def find_projects_by_team(team_name):
    return [project for project in project_management["projects"] 
            if team_name in project["teams_involved"]]

def get_upcoming_milestones():
    upcoming = []
    for project in project_management["projects"]:
        for milestone in project["milestones"]:
            if milestone["status"] in ["не начато", "в работе"]:
                upcoming.append({
                    "project": project["name"],
                    "milestone": milestone["name"],
                    "deadline": milestone["deadline"],
                    "team": milestone["assigned_team"]
                })
    return sorted(upcoming, key=lambda x: x["deadline"])

overview = get_project_overview()
print(f"Обзор проектов:")
print(f"  Всего проектов: {overview['total_projects']}")
print(f"  По статусам: {overview['by_status']}")
print(f"  Общий бюджет: {overview['total_budget']} руб.")
print(f"  Нагрузка на команды: {overview['team_workload']}")

print(f"\nПроекты backend команды:")
backend_projects = find_projects_by_team("backend")
for project in backend_projects:
    print(f"  - {project['name']} ({project['status']})")

print(f"\nПредстоящие milestones:")
for milestone in get_upcoming_milestones():
    print(f"  {milestone['project']}: {milestone['milestone']} ({milestone['deadline']})")

print("\n--- Управление рисками ---")
def analyze_risks():
    risk_analysis = {
        "high_risk_projects": [],
        "total_risks": 0,
        "risk_levels": {}
    }
    
    for project in project_management["projects"]:
        high_risks = [risk for risk in project["risks"] if risk["level"] == "высокий"]
        if high_risks:
            risk_analysis["high_risk_projects"].append({
                "project": project["name"],
                "high_risks": high_risks
            })
        
        for risk in project["risks"]:
            risk_analysis["total_risks"] += 1
            risk_analysis["risk_levels"][risk["level"]] = risk_analysis["risk_levels"].get(risk["level"], 0) + 1
    
    return risk_analysis

def add_risk_to_project(project_id, risk_description, risk_level):
    for project in project_management["projects"]:
        if project["id"] == project_id:
            project["risks"].append({
                "description": risk_description,
                "level": risk_level
            })
            return True
    return False

risk_analysis = analyze_risks()
print(f"Анализ рисков:")
print(f"  Всего рисков: {risk_analysis['total_risks']}")
print(f"  Уровни рисков: {risk_analysis['risk_levels']}")
print(f"  Проекты с высокими рисками: {[p['project'] for p in risk_analysis['high_risk_projects']]}")

# Добавляем новый риск
add_risk_to_project("PROJ-002", "Нехватка разработчиков", "высокий")
print(f"\nПосле добавления риска:")
updated_analysis = analyze_risks()
print(f"  Всего рисков: {updated_analysis['total_risks']}")

print("\n--- Генерация отчетов ---")
def generate_project_report():
    report = []
    for project in project_management["projects"]:
        completed_milestones = len([m for m in project["milestones"] if m["status"] == "завершено"])
        total_milestones = len(project["milestones"])
        progress = (completed_milestones / total_milestones * 100) if total_milestones > 0 else 0
        
        report.append({
            "name": project["name"],
            "status": project["status"],
            "progress": f"{progress:.1f}%",
            "budget": project["budget"],
            "risks": len(project["risks"]),
            "teams": len(project["teams_involved"])
        })
    return report

print("Отчет по проектам:")
for project in generate_project_report():
    print(f"  {project['name']}: {project['status']}, прогресс {project['progress']}, "
          f"рисков: {project['risks']}, команд: {project['teams']}")
```
Вывод в консоли:
```bash
=== Комбинированные сложные структуры ===
--- Анализ проектов ---
Обзор проектов:
  Всего проектов: 2
  По статусам: {'в разработке': 1, 'планирование': 1}
  Общий бюджет: 7000000 руб.
  Нагрузка на команды: {'frontend': 2, 'backend': 1, 'devops': 1}

Проекты backend команды:
  - Электронная коммерция (в разработке)

Предстоящие milestones:
  Электронная коммерция: Бэкенд API (2024-04-15)
  Электронная коммерция: Деплой на продакшн (2024-06-01)
  Мобильное приложение: Дизайн макетов (2024-02-20)

--- Управление рисками ---
Анализ рисков:
  Всего рисков: 2
  Уровни рисков: {'средний': 1, 'высокий': 1}
  Проекты с высокими рисками: ['Электронная коммерция']

После добавления риска:
  Всего рисков: 3

--- Генерация отчетов ---
Отчет по проектам:
  Электронная коммерция: в разработке, прогресс 33.3%, рисков: 2, команд: 3
  Мобильное приложение: планирование, прогресс 0.0%, рисков: 1, команд: 1
```
Слайд 6: Задания для практики
Задание 1: Система библиотеки
```python
# Создайте систему учета библиотеки:
# 1. Книги с авторами, жанрами, статусом
# 2. Читатели с историей взятия книг
# 3. Система бронирования и возврата
# 4. Используйте вложенные структуры
# Ваш код здесь
```
Задание 2: Планировщик путешествий
```python
# Создайте планировщик путешествий:
# 1. Маршруты с точками, транспортом, стоимостью
# 2. Бронирования отелей и билетов
# 3. Бюджет и расписание
# 4. Используйте комбинированные структуры
# Ваш код здесь
```
Задание 3: Система рецептов
```python
# Создайте систему хранения рецептов:
# 1. Рецепты с ингредиентами и шагами приготовления
# 2. Категории и теги
# 3. Отзывы и рейтинги
# 4. Поиск по ингредиентам
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Система библиотеки
library_system = {
    "books": {
        "Б001": {
            "title": "Мастер и Маргарита",
            "author": "Михаил Булгаков",
            "genre": "роман",
            "year": 1967,
            "copies": {
                "available": 2,
                "total": 3
            },
            "borrowers": [
                {"reader_id": "Ч001", "borrow_date": "2024-01-15", "return_date": "2024-02-15"}
            ]
        },
        "Б002": {
            "title": "Преступление и наказание",
            "author": "Федор Достоевский", 
            "genre": "психологический роман",
            "year": 1866,
            "copies": {
                "available": 1,
                "total": 2
            },
            "borrowers": []
        }
    },
    "readers": {
        "Ч001": {
            "name": "Анна Иванова",
            "membership": "активен",
            "borrowed_books": ["Б001"],
            "history": [
                {"book_id": "Б001", "action": "взятие", "date": "2024-01-15"}
            ]
        },
        "Ч002": {
            "name": "Борис Петров",
            "membership": "активен", 
            "borrowed_books": [],
            "history": []
        }
    }
}

def borrow_book(reader_id, book_id):
    book = library_system["books"][book_id]
    reader = library_system["readers"][reader_id]
    
    if book["copies"]["available"] > 0 and reader["membership"] == "активен":
        book["copies"]["available"] -= 1
        reader["borrowed_books"].append(book_id)
        reader["history"].append({
            "book_id": book_id,
            "action": "взятие", 
            "date": "2024-12-19"
        })
        return True
    return False

# Тестирование
print("Библиотечная система:")
print(f"Книги: {list(library_system['books'].keys())}")
print(f"Читатели: {list(library_system['readers'].keys())}")

# #Задание 2: Планировщик путешествий
travel_planner = {
    "trips": [
        {
            "trip_id": "Т001",
            "destination": "Париж",
            "dates": {"start": "2024-06-01", "end": "2024-06-10"},
            "budget": {
                "total": 150000,
                "spent": 0,
                "categories": {
                    "перелет": 50000,
                    "отель": 70000,
                    "еда": 20000,
                    "развлечения": 10000
                }
            },
            "itinerary": [
                {"day": 1, "activities": ["Прилет", "Заселение в отель", "Эйфелева башня"]},
                {"day": 2, "activities": ["Лувр", "Прогулка по Сене"]}
            ],
            "bookings": {
                "flights": [
                    {"airline": "Aeroflot", "price": 50000, "confirmed": True}
                ],
                "hotels": [
                    {"name": "Hotel Paris", "price": 70000, "confirmed": True}
                ]
            }
        }
    ],
    "travelers": {
        "Анна": {"preferences": ["музеи", "шоппинг"], "budget": 50000},
        "Борис": {"preferences": ["рестораны", "экскурсии"], "budget": 40000}
    }
}

def calculate_trip_statistics(trip_id):
    for trip in travel_planner["trips"]:
        if trip["trip_id"] == trip_id:
            total_days = (trip["dates"]["end"] - trip["dates"]["start"]).days
            total_activities = sum(len(day["activities"]) for day in trip["itinerary"])
            budget_utilization = (trip["budget"]["spent"] / trip["budget"]["total"]) * 100
            
            return {
                "duration_days": total_days,
                "total_activities": total_activities,
                "budget_utilization": f"{budget_utilization:.1f}%"
            }
    return None

# #Задание 3: Система рецептов
recipe_system = {
    "recipes": [
        {
            "id": "Р001",
            "name": "Омлет с сыром",
            "category": "завтрак",
            "prep_time": 15,
            "difficulty": "легкий",
            "ingredients": [
                {"name": "яйца", "amount": "3 шт.", "category": "молочные"},
                {"name": "сыр", "amount": "50 г", "category": "молочные"},
                {"name": "молоко", "amount": "2 ст.л.", "category": "молочные"}
            ],
            "steps": [
                {"step": 1, "description": "Взбить яйца с молоком"},
                {"step": 2, "description": "Добавить тертый сыр"},
                {"step": 3, "description": "Жарить на сковороде 5 минут"}
            ],
            "nutrition": {"calories": 250, "protein": 20, "carbs": 5},
            "reviews": [
                {"user": "Анна", "rating": 5, "comment": "Вкусно и быстро!"}
            ]
        }
    ],
    "categories": ["завтрак", "обед", "ужин", "десерт"],
    "users": {
        "Анна": {"favorite_recipes": ["Р001"], "dietary_restrictions": []}
    }
}

def find_recipes_by_ingredient(ingredient_name):
    matching_recipes = []
    for recipe in recipe_system["recipes"]:
        for ingredient in recipe["ingredients"]:
            if ingredient_name.lower() in ingredient["name"].lower():
                matching_recipes.append({
                    "name": recipe["name"],
                    "ingredient": ingredient["name"],
                    "category": recipe["category"]
                })
                break
    return matching_recipes

def add_review(recipe_id, user, rating, comment):
    for recipe in recipe_system["recipes"]:
        if recipe["id"] == recipe_id:
            recipe["reviews"].append({
                "user": user,
                "rating": rating,
                "comment": comment
            })
            return True
    return False

# Тестирование
print(f"Рецепты с яйцами: {find_recipes_by_ingredient('яйца')}")
add_review("Р001", "Борис", 4, "Хороший рецепт для начинающих")
print(f"Отзывы на омлет: {recipe_system['recipes'][0]['reviews']}")
```
Ключевые моменты:
```
Словари в словарях — для иерархических структур (компания → отделы → сотрудники)
Списки в словарях — для коллекций (студенты → курсы → оценки)
Словари в списках — для списков объектов (товары, заказы, проекты)
Комбинированные структуры — для сложных систем (управление проектами)
Доступ к данным — цепочки ключей: data['level1']['level2']['level3']
Модификация — поэтапное изменение вложенных элементов
Обход — рекурсивные функции для сложных структур
Поиск — фильтрация и агрегация по вложенным критериям
Обращение к вложенным элементам.
```
 «Обращение к вложенным элементам»
Тема: Обращение к вложенным элементам
```
Слайд 1: Теория — Обращение к вложенным элементам
Вложенные структуры — структуры данных, содержащие другие структуры
Основные способы обращения:
Прямой доступ через цепочку ключей — data['a']['b']['c']
Метод get() с значениями по умолчанию — безопасный доступ
Обработка исключений — try/except для обработки ошибок
Функции-помощники — специализированные функции для доступа
Особенности:
При прямом доступе KeyError если ключа нет
get() возвращает None если ключа нет
Вложенные списки используют индексы: data[0]['key']
```
Слайд 2: Пример 1 — Прямой доступ и базовые операции
Задача: Показать прямой доступ к вложенным элементам через цепочку ключей.
```python
print("=== Прямой доступ к вложенным элементам ===")

# Создаем сложную вложенную структуру
company = {
    "name": "ТехноКорп",
    "departments": {
        "IT": {
            "manager": "Иван Сидоров",
            "employees": {
                "Анна Петрова": {
                    "position": "разработчик",
                    "salary": 120000,
                    "skills": ["Python", "JavaScript", "SQL"],
                    "contact": {
                        "email": "anna@techcorp.ru",
                        "phone": "+79123456789"
                    }
                },
                "Борис Иванов": {
                    "position": "тестировщик",
                    "salary": 90000,
                    "skills": ["Selenium", "Jest"],
                    "contact": {
                        "email": "boris@techcorp.ru",
                        "phone": "+79123456780"
                    }
                }
            }
        },
        "HR": {
            "manager": "Ольга Новикова",
            "employees": {
                "Дмитрий Смирнов": {
                    "position": "рекрутер",
                    "salary": 80000,
                    "skills": ["интервью", "подбор"],
                    "contact": {
                        "email": "dmitry@techcorp.ru",
                        "phone": "+79123456781"
                    }
                }
            }
        }
    },
    "locations": ["Москва", "Санкт-Петербург", "Новосибирск"]
}

print("--- Прямой доступ через цепочку ключей ---")
# Доступ к простым значениям
print(f"Название компании: {company['name']}")
print(f"Менеджер IT отдела: {company['departments']['IT']['manager']}")

# Доступ к вложенным словарям
print(f"Позиция Анны: {company['departments']['IT']['employees']['Анна Петрова']['position']}")
print(f"Email Анны: {company['departments']['IT']['employees']['Анна Петрова']['contact']['email']}")

# Доступ к спискам внутри словарей
print(f"Навыки Анны: {company['departments']['IT']['employees']['Анна Петрова']['skills']}")
print(f"Первый навык Анны: {company['departments']['IT']['employees']['Анна Петрова']['skills'][0]}")

# Доступ к спискам верхнего уровня
print(f"Первая локация: {company['locations'][0]}")
print(f"Все локации: {company['locations']}")

print("\n--- Изменение вложенных элементов ---")
# Изменение существующих значений
company['departments']['IT']['employees']['Анна Петрова']['salary'] = 125000
print(f"Новая зарплата Анны: {company['departments']['IT']['employees']['Анна Петрова']['salary']}")

# Добавление новых элементов
company['departments']['IT']['employees']['Анна Петрова']['bonus'] = 20000
company['locations'].append("Екатеринбург")

print(f"Бонус Анны: {company['departments']['IT']['employees']['Анна Петрова']['bonus']}")
print(f"Все локации после добавления: {company['locations']}")

print("\n--- Опасность прямого доступа ---")
# Прямой доступ к несуществующему ключу вызывает ошибку
try:
    print(f"Несуществующий ключ: {company['departments']['Finance']}")
except KeyError as e:
    print(f"Ошибка KeyError: {e}")

try:
    print(f"Несуществующий сотрудник: {company['departments']['IT']['employees']['Неизвестный']}")
except KeyError as e:
    print(f"Ошибка KeyError: {e}")

try:
    print(f"Несуществующий индекс: {company['locations'][10]}")
except IndexError as e:
    print(f"Ошибка IndexError: {e}")
```
Вывод в консоли:
```bash
=== Прямой доступ к вложенным элементам ===
--- Прямой доступ через цепочку ключей ---
Название компании: ТехноКорп
Менеджер IT отдела: Иван Сидоров
Позиция Анны: разработчик
Email Анны: anna@techcorp.ru
Навыки Анны: ['Python', 'JavaScript', 'SQL']
Первый навык Анны: Python
Первая локация: Москва
Все локации: ['Москва', 'Санкт-Петербург', 'Новосибирск']

--- Изменение вложенных элементов ---
Новая зарплата Анны: 125000
Бонус Анны: 20000
Все локации после добавления: ['Москва', 'Санкт-Петербург', 'Новосибирск', 'Екатеринбург']

--- Опасность прямого доступа ---
Ошибка KeyError: 'Finance'
Ошибка KeyError: 'Неизвестный'
Ошибка IndexError: list index out of range
```
Слайд 3: Пример 2 — Безопасный доступ с get() и setdefault()
Задача: Показать безопасные способы доступа к вложенным элементам.
```python
print("=== Безопасный доступ к вложенным элементам ===")

# Используем ту же структуру company из предыдущего примера

print("--- Метод get() для безопасного доступа ---")
# Безопасный доступ к существующим ключам
print(f"Название компании: {company.get('name')}")
print(f"Менеджер IT: {company.get('departments', {}).get('IT', {}).get('manager')}")

# Безопасный доступ к несуществующим ключам
print(f"Финансовый отдел: {company.get('departments', {}).get('Finance')}")
print(f"Неизвестный сотрудник: {company.get('departments', {}).get('IT', {}).get('employees', {}).get('Неизвестный')}")

# get() с значением по умолчанию
print(f"Бюджет IT (по умолчанию 0): {company.get('departments', {}).get('IT', {}).get('budget', 0)}")
print(f"Неизвестный ключ: {company.get('unknown_key', 'Не найдено')}")

print("\n--- Функция для безопасного доступа к глубоким ключам ---")
def safe_get(data, path, default=None):
    """
    Безопасное получение значения по пути вида 'key1.key2.key3'
    """
    keys = path.split('.')
    current = data
    
    for key in keys:
        if isinstance(current, dict) and key in current:
            current = current[key]
        elif isinstance(current, list) and key.isdigit():
            index = int(key)
            if 0 <= index < len(current):
                current = current[index]
            else:
                return default
        else:
            return default
    
    return current

# Тестирование функции безопасного доступа
print("Функция safe_get():")
print(f"company.name: {safe_get(company, 'name')}")
print(f"departments.IT.manager: {safe_get(company, 'departments.IT.manager')}")
print(f"departments.IT.employees.Анна Петрова.salary: {safe_get(company, 'departments.IT.employees.Анна Петрова.salary')}")
print(f"departments.Finance.manager: {safe_get(company, 'departments.Finance.manager', 'Отдел не найден')}")
print(f"locations.1: {safe_get(company, 'locations.1')}")  # Второй элемент списка
print(f"locations.10: {safe_get(company, 'locations.10', 'Индекс не найден')}")

print("\n--- Метод setdefault() ---")
# setdefault() для установки значений по умолчанию
print("До setdefault():")
print(f"Бюджет IT: {company['departments']['IT'].get('budget')}")

# Устанавливаем бюджет если его нет
it_budget = company['departments']['IT'].setdefault('budget', 1000000)
print(f"После setdefault('budget', 1000000): {it_budget}")

# Для существующего ключа setdefault() возвращает текущее значение
current_budget = company['departments']['IT'].setdefault('budget', 2000000)
print(f"Повторный setdefault(): {current_budget}")  # Вернет 1000000, а не 2000000

print("\n--- Создание сложных структур через setdefault() ---")
# Постепенное создание сложной структуры
project = {}
project.setdefault('tasks', {}).setdefault('backend', []).append('API разработка')
project.setdefault('tasks', {}).setdefault('frontend', []).append('UI компоненты')
project.setdefault('team', {}).setdefault('developers', []).append('Анна')

print(f"Созданная структура проекта: {project}")

print("\n--- Проверка вложенных структур ---")
def check_nested_structure(data, required_structure):
    """
    Проверяет, что структура данных соответствует требуемой
    """
    for key, expected_type in required_structure.items():
        if key not in data:
            return False, f"Отсутствует ключ: {key}"
        
        if not isinstance(data[key], expected_type):
            return False, f"Неверный тип для {key}: ожидался {expected_type}, получен {type(data[key])}"
    
    return True, "Структура корректна"

# Проверяем структуру IT отдела
required_it_structure = {
    'manager': str,
    'employees': dict,
    'budget': int
}

is_valid, message = check_nested_structure(company['departments']['IT'], required_it_structure)
print(f"Проверка IT отдела: {message}")
```
Вывод в консоли:
```bash
=== Безопасный доступ к вложенным элементам ===
--- Метод get() для безопасного доступа ---
Название компании: ТехноКорп
Менеджер IT: Иван Сидоров
Финансовый отдел: None
Неизвестный сотрудник: None
Бюджет IT (по умолчанию 0): 0
Неизвестный ключ: Не найдено

--- Функция для безопасного доступа к глубоким ключам ---
Функция safe_get():
company.name: ТехноКорп
departments.IT.manager: Иван Сидоров
departments.IT.employees.Анна Петрова.salary: 125000
departments.Finance.manager: Отдел не найден
locations.1: Санкт-Петербург
locations.10: Индекс не найден

--- Метод setdefault() ---
До setdefault():
Бюджет IT: None
После setdefault('budget', 1000000): 1000000
Повторный setdefault(): 1000000

--- Создание сложных структур через setdefault() ---
Созданная структура проекта: {'tasks': {'backend': ['API разработка'], 'frontend': ['UI компоненты']}, 'team': {'developers': ['Анна']}}

--- Проверка вложенных структур ---
Проверка IT отдела: Структура корректна
```
Слайд 4: Пример 3 — Обработка исключений и функции-помощники
Задача: Показать обработку исключений и создание функций для работы с вложенными структурами.
```python
print("=== Обработка исключений и функции-помощники ===")

# Создаем тестовые данные
user_data = [
    {
        "id": 1,
        "name": "Анна Иванова",
        "profile": {
            "age": 25,
            "address": {
                "city": "Москва",
                "street": "Ленина",
                "apartment": {
                    "number": 15,
                    "floor": 3
                }
            }
        },
        "orders": [
            {"id": "A100", "amount": 5000},
            {"id": "A101", "amount": 3000}
        ]
    },
    {
        "id": 2,
        "name": "Борис Петров",
        "profile": {
            "age": 30,
            "address": {
                "city": "Санкт-Петербург"
                # Отсутствуют street и apartment
            }
        },
        "orders": []  # Нет заказов
    },
    {
        "id": 3,
        "name": "Виктор Сидоров"
        # Отсутствует profile
    }
]

print("--- Обработка исключений try/except ---")
def get_user_city_safe(user):
    """Безопасное получение города пользователя с обработкой исключений"""
    try:
        return user['profile']['address']['city']
    except (KeyError, TypeError):
        return "Город не указан"

def get_first_order_amount_safe(user):
    """Безопасное получение суммы первого заказа"""
    try:
        return user['orders'][0]['amount']
    except (KeyError, IndexError, TypeError):
        return 0

print("Города пользователей:")
for user in user_data:
    city = get_user_city_safe(user)
    print(f"  {user['name']}: {city}")

print("\nСуммы первых заказов:")
for user in user_data:
    amount = get_first_order_amount_safe(user)
    print(f"  {user['name']}: {amount} руб.")

print("\n--- Универсальная функция для доступа к вложенным данным ---")
def get_nested_value(data, *keys, default=None):
    """
    Универсальная функция для получения вложенных значений
    """
    current = data
    for key in keys:
        try:
            if isinstance(current, dict):
                current = current[key]
            elif isinstance(current, list) and isinstance(key, int):
                current = current[key]
            else:
                return default
        except (KeyError, IndexError, TypeError):
            return default
    return current

print("Универсальная функция get_nested_value():")
for user in user_data:
    name = get_nested_value(user, 'name', default='Неизвестно')
    city = get_nested_value(user, 'profile', 'address', 'city', default='Не указан')
    street = get_nested_value(user, 'profile', 'address', 'street', default='Не указана')
    floor = get_nested_value(user, 'profile', 'address', 'apartment', 'floor', default='Не указан')
    
    print(f"  {name}: {city}, {street}, этаж {floor}")

print("\n--- Функция для установки вложенных значений ---")
def set_nested_value(data, value, *keys):
    """
    Установка значения по вложенному пути
    """
    current = data
    # Проходим по всем ключам кроме последнего
    for key in keys[:-1]:
        if key not in current or not isinstance(current[key], dict):
            current[key] = {}
        current = current[key]
    # Устанавливаем значение для последнего ключа
    current[keys[-1]] = value

print("До установки значений:")
print(f"  Пользователь 2: {user_data[1]}")

# Устанавливаем недостающие значения
set_nested_value(user_data[1], 'Невский проспект', 'profile', 'address', 'street')
set_nested_value(user_data[1], {'number': 10, 'floor': 2}, 'profile', 'address', 'apartment')
set_nested_value(user_data[2], {'age': 28, 'address': {'city': 'Казань'}}, 'profile')

print("\nПосле установки значений:")
for user in user_data:
    name = user['name']
    city = get_nested_value(user, 'profile', 'address', 'city', default='Не указан')
    print(f"  {name}: {city}")

print("\n--- Рекурсивный обход вложенных структур ---")
def find_all_keys(data, target_key, current_path=""):
    """
    Рекурсивный поиск всех вхождений ключа в структуре
    """
    results = []
    
    if isinstance(data, dict):
        for key, value in data.items():
            new_path = f"{current_path}.{key}" if current_path else key
            
            if key == target_key:
                results.append((new_path, value))
            
            # Рекурсивный поиск в значениях
            results.extend(find_all_keys(value, target_key, new_path))
    
    elif isinstance(data, list):
        for i, item in enumerate(data):
            new_path = f"{current_path}[{i}]"
            results.extend(find_all_keys(item, target_key, new_path))
    
    return results

print("Поиск всех ключей 'city':")
cities = find_all_keys(user_data, 'city')
for path, value in cities:
    print(f"  {path}: {value}")

print("\nПоиск всех ключей 'amount':")
amounts = find_all_keys(user_data, 'amount')
for path, value in amounts:
    print(f"  {path}: {value}")
```
Вывод в консоли:
```bash
=== Обработка исключений и функции-помощники ===
--- Обработка исключений try/except ---
Города пользователей:
  Анна Иванова: Москва
  Борис Петров: Санкт-Петербург
  Виктор Сидоров: Город не указан

Суммы первых заказов:
  Анна Иванова: 5000 руб.
  Борис Петров: 0 руб.
  Виктор Сидоров: 0 руб.

--- Универсальная функция для доступа к вложенным данным ---
Универсальная функция get_nested_value():
  Анна Иванова: Москва, Ленина, этаж 3
  Борис Петров: Санкт-Петербург, Не указана, этаж Не указан
  Виктор Сидоров: Не указан, Не указана, этаж Не указан

--- Функция для установки вложенных значений ---
До установки значений:
  Пользователь 2: {'id': 2, 'name': 'Борис Петров', 'profile': {'age': 30, 'address': {'city': 'Санкт-Петербург'}}, 'orders': []}

После установки значений:
  Анна Иванова: Москва
  Борис Петров: Санкт-Петербург
  Виктор Сидоров: Казань

--- Рекурсивный обход вложенных структур ---
Поиск всех ключей 'city':
  [0].profile.address.city: Москва
  [1].profile.address.city: Санкт-Петербург
  [2].profile.address.city: Казань

Поиск всех ключей 'amount':
  [0].orders[0].amount: 5000
  [0].orders[1].amount: 3000
```
Слайд 5: Пример 4 — Практическое применение с реальными данными
Задача: Показать практическое применение методов доступа к вложенным элементам.
```python
print("=== Практическое применение с реальными данными ===")

# Данные интернет-магазина
ecommerce_data = {
    "store": "TechMarket",
    "customers": [
        {
            "customer_id": "C001",
            "personal_info": {
                "name": "Анна Иванова",
                "contact": {
                    "email": "anna@mail.ru",
                    "phone": "+79123456789",
                    "address": {
                        "city": "Москва",
                        "zipcode": "101000"
                    }
                }
            },
            "order_history": [
                {
                    "order_id": "ORD001",
                    "date": "2024-01-15",
                    "status": "delivered",
                    "items": [
                        {"product": "Ноутбук", "price": 50000, "quantity": 1},
                        {"product": "Мышь", "price": 2000, "quantity": 1}
                    ],
                    "payment": {
                        "method": "credit_card",
                        "amount": 52000,
                        "status": "paid"
                    }
                }
            ],
            "preferences": {
                "categories": ["электроника", "аксессуары"],
                "newsletter": True
            }
        },
        {
            "customer_id": "C002",
            "personal_info": {
                "name": "Борис Петров",
                "contact": {
                    "email": "boris@mail.ru",
                    "phone": "+79123456780"
                    # Отсутствует address
                }
            },
            "order_history": [
                {
                    "order_id": "ORD002",
                    "date": "2024-01-20",
                    "status": "processing",
                    "items": [
                        {"product": "Смартфон", "price": 30000, "quantity": 1}
                    ]
                    # Отсутствует payment
                }
            ]
            # Отсутствует preferences
        }
    ],
    "analytics": {
        "total_customers": 2,
        "total_revenue": 82000,
        "popular_categories": ["электроника", "аксессуары"]
    }
}

print("--- Анализ данных клиентов ---")
def analyze_customer_data(customers):
    analysis = {
        "total_customers": len(customers),
        "customers_with_address": 0,
        "total_revenue": 0,
        "city_stats": {},
        "order_stats": {
            "total_orders": 0,
            "by_status": {}
        }
    }
    
    for customer in customers:
        # Проверяем наличие адреса
        city = get_nested_value(customer, 'personal_info', 'contact', 'address', 'city')
        if city:
            analysis["customers_with_address"] += 1
            analysis["city_stats"][city] = analysis["city_stats"].get(city, 0) + 1
        
        # Анализ заказов
        orders = get_nested_value(customer, 'order_history', default=[])
        analysis["order_stats"]["total_orders"] += len(orders)
        
        for order in orders:
            # Статусы заказов
            status = order.get('status', 'unknown')
            analysis["order_stats"]["by_status"][status] = analysis["order_stats"]["by_status"].get(status, 0) + 1
            
            # Выручка
            payment_amount = get_nested_value(order, 'payment', 'amount', default=0)
            analysis["total_revenue"] += payment_amount
    
    return analysis

analysis = analyze_customer_data(ecommerce_data["customers"])
print("Анализ клиентов:")
print(f"  Всего клиентов: {analysis['total_customers']}")
print(f"  Клиентов с адресом: {analysis['customers_with_address']}")
print(f"  Общая выручка: {analysis['total_revenue']} руб.")
print(f"  Статистика по городам: {analysis['city_stats']}")
print(f"  Статистика заказов: {analysis['order_stats']}")

print("\n--- Генерация отчетов ---")
def generate_customer_report(customer):
    """Генерация отчета по клиенту"""
    report = {
        "customer_id": customer["customer_id"],
        "name": get_nested_value(customer, 'personal_info', 'name', default='Неизвестно'),
        "email": get_nested_value(customer, 'personal_info', 'contact', 'email', default='Не указан'),
        "city": get_nested_value(customer, 'personal_info', 'contact', 'address', 'city', default='Не указан'),
        "total_orders": len(get_nested_value(customer, 'order_history', default=[])),
        "total_spent": 0,
        "preferences": get_nested_value(customer, 'preferences', 'categories', default=[])
    }
    
    # Считаем общие траты
    for order in get_nested_value(customer, 'order_history', default=[]):
        amount = get_nested_value(order, 'payment', 'amount', default=0)
        report["total_spent"] += amount
    
    return report

print("Отчеты по клиентам:")
for customer in ecommerce_data["customers"]:
    report = generate_customer_report(customer)
    print(f"  {report['name']}: {report['total_orders']} заказов, потрачено {report['total_spent']} руб.")

print("\n--- Обработка и обновление данных ---")
def update_customer_info(customer_id, updates):
    """Обновление информации о клиенте"""
    for customer in ecommerce_data["customers"]:
        if customer["customer_id"] == customer_id:
            for key, value in updates.items():
                set_nested_value(customer, value, *key.split('.'))
            return True
    return False

def add_order_to_customer(customer_id, new_order):
    """Добавление заказа клиенту"""
    for customer in ecommerce_data["customers"]:
        if customer["customer_id"] == customer_id:
            if 'order_history' not in customer:
                customer['order_history'] = []
            customer['order_history'].append(new_order)
            return True
    return False

# Обновляем данные
update_customer_info("C002", {
    "personal_info.contact.address.city": "Санкт-Петербург",
    "personal_info.contact.address.zipcode": "190000",
    "preferences.categories": ["электроника"],
    "preferences.newsletter": False
})

# Добавляем новый заказ
new_order = {
    "order_id": "ORD003",
    "date": "2024-01-25",
    "status": "shipped",
    "items": [
        {"product": "Наушники", "price": 5000, "quantity": 1}
    ],
    "payment": {
        "method": "paypal",
        "amount": 5000,
        "status": "paid"
    }
}

add_order_to_customer("C001", new_order)

print("После обновления данных:")
for customer in ecommerce_data["customers"]:
    report = generate_customer_report(customer)
    print(f"  {report['name']}: {report['city']}, {report['total_orders']} заказов, предпочтения: {report['preferences']}")

print("\n--- Валидация данных ---")
def validate_customer_data(customer):
    """Проверка корректности данных клиента"""
    errors = []
    
    # Обязательные поля
    required_fields = [
        "customer_id",
        "personal_info.name",
        "personal_info.contact.email"
    ]
    
    for field in required_fields:
        if get_nested_value(customer, *field.split('.')) is None:
            errors.append(f"Отсутствует обязательное поле: {field}")
    
    # Валидация email
    email = get_nested_value(customer, 'personal_info', 'contact', 'email')
    if email and '@' not in email:
        errors.append("Некорректный email")
    
    # Валидация заказов
    for order in get_nested_value(customer, 'order_history', default=[]):
        if not get_nested_value(order, 'payment', 'amount'):
            errors.append(f"Заказ {order.get('order_id')} без указания суммы")
    
    return errors

print("Валидация данных клиентов:")
for customer in ecommerce_data["customers"]:
    errors = validate_customer_data(customer)
    status = "✓ OK" if not errors else f"✗ Ошибки: {errors}"
    print(f"  {customer['personal_info']['name']}: {status}")
```
Вывод в консоли:
```bash
=== Практическое применение с реальными данными ===
--- Анализ данных клиентов ---
Анализ клиентов:
  Всего клиентов: 2
  Клиентов с адресом: 1
  Общая выручка: 52000 руб.
  Статистика по городам: {'Москва': 1}
  Статистика заказов: {'total_orders': 2, 'by_status': {'delivered': 1, 'processing': 1}}

--- Генерация отчетов ---
Отчеты по клиентам:
  Анна Иванова: 1 заказов, потрачено 52000 руб.
  Борис Петров: 1 заказов, потрачено 0 руб.

--- Обработка и обновление данных ---
После обновления данных:
  Анна Иванова: Москва, 2 заказов, предпочтения: ['электроника', 'аксессуары']
  Борис Петров: Санкт-Петербург, 1 заказов, предпочтения: ['электроника']

--- Валидация данных ---
Валидация данных клиентов:
  Анна Иванова: ✓ OK
  Борис Петров: ✗ Ошибки: ['Заказ ORD002 без указания суммы']
```
Слайд 6: Задания для практики
Задание 1: Анализатор социальной сети
```python
# Создайте функции для анализа данных социальной сети:
# 1. Найти всех пользователей из определенного города
# 2. Посчитать среднее количество друзей
# 3. Найти самых активных пользователей
# 4. Используйте безопасный доступ к вложенным данным
# Ваш код здесь
```
Задание 2: Система управления складом
```python
# Создайте функции для управления складом:
# 1. Найти товары с низким запасом
# 2. Посчитать общую стоимость inventory
# 3. Обновить цены товаров
# 4. Используйте функции для вложенного доступа
# Ваш код здесь
```
Задание 3: Обработчик JSON API ответов
```python
# Создайте функции для обработки API ответов:
# 1. Извлечение данных по сложным путям
# 2. Обработка отсутствующих полей
# 3. Трансформация структур данных
# 4. Используйте обработку исключений
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Анализатор социальной сети
social_network = {
    "users": [
        {
            "id": 1,
            "profile": {
                "name": "Анна",
                "age": 25,
                "city": "Москва",
                "friends": [2, 3]
            },
            "activity": {
                "posts": 15,
                "likes": 120,
                "comments": 45
            }
        },
        {
            "id": 2,
            "profile": {
                "name": "Борис",
                "age": 30,
                "city": "Санкт-Петербург",
                "friends": [1, 3]
            },
            "activity": {
                "posts": 8,
                "likes": 80,
                "comments": 20
            }
        }
    ]
}

def find_users_by_city(network, city):
    return [user for user in network["users"] 
            if get_nested_value(user, 'profile', 'city') == city]

def calculate_average_friends(network):
    total_friends = 0
    user_count = len(network["users"])
    
    for user in network["users"]:
        friends = get_nested_value(user, 'profile', 'friends', default=[])
        total_friends += len(friends)
    
    return total_friends / user_count if user_count > 0 else 0

def find_most_active_users(network, metric='posts', top_n=2):
    users_with_metric = []
    for user in network["users"]:
        value = get_nested_value(user, 'activity', metric, default=0)
        users_with_metric.append((user['profile']['name'], value))
    
    return sorted(users_with_metric, key=lambda x: x[1], reverse=True)[:top_n]

# Тестирование
print("Пользователи из Москвы:", [u['profile']['name'] for u in find_users_by_city(social_network, "Москва")])
print("Среднее количество друзей:", calculate_average_friends(social_network))
print("Самые активные по постам:", find_most_active_users(social_network, 'posts'))

# #Задание 2: Система управления складом
warehouse = {
    "categories": {
        "электроника": {
            "products": {
                "ноутбуки": [
                    {"id": "N001", "name": "Lenovo", "price": 50000, "stock": 5},
                    {"id": "N002", "name": "Dell", "price": 60000, "stock": 3}
                ],
                "смартфоны": [
                    {"id": "S001", "name": "Samsung", "price": 30000, "stock": 10}
                ]
            }
        },
        "аксессуары": {
            "products": {
                "наушники": [
                    {"id": "H001", "name": "Sony", "price": 5000, "stock": 1}
                ]
            }
        }
    }
}

def find_low_stock_products(warehouse_data, threshold=5):
    low_stock = []
    for category_name, category in warehouse_data["categories"].items():
        for product_type, products in category["products"].items():
            for product in products:
                if product["stock"] <= threshold:
                    low_stock.append({
                        "category": category_name,
                        "type": product_type,
                        "product": product["name"],
                        "stock": product["stock"]
                    })
    return low_stock

def calculate_total_inventory_value(warehouse_data):
    total_value = 0
    for category in warehouse_data["categories"].values():
        for products_list in category["products"].values():
            for product in products_list:
                total_value += product["price"] * product["stock"]
    return total_value

def update_product_prices(warehouse_data, category, product_type, increase_percent=10):
    try:
        products = warehouse_data["categories"][category]["products"][product_type]
        for product in products:
            product["price"] *= (1 + increase_percent / 100)
        return True
    except KeyError:
        return False

# Тестирование
print("Товары с низким запасом:", find_low_stock_products(warehouse))
print("Общая стоимость inventory:", calculate_total_inventory_value(warehouse))
update_product_prices(warehouse, "электроника", "ноутбуки", 5)
print("Цены обновлены")

# #Задание 3: Обработчик JSON API ответов
def safe_api_data_extractor(api_response, extraction_rules):
    """
    Безопасное извлечение данных из API ответа по правилам
    """
    extracted_data = {}
    
    for field_name, path in extraction_rules.items():
        try:
            # Поддерживаем пути вида "users[0].profile.name"
            keys = []
            for part in path.split('.'):
                if '[' in part and ']' in part:
                    # Обработка массивов: users[0] -> ('users', 0)
                    base, index = part.split('[')
                    index = int(index[:-1])  # Убираем закрывающую скобку
                    keys.extend([base, index])
                else:
                    keys.append(part)
            
            value = get_nested_value(api_response, *keys)
            extracted_data[field_name] = value
        except Exception as e:
            extracted_data[field_name] = None
            print(f"Ошибка извлечения {field_name}: {e}")
    
    return extracted_data

# Пример использования
api_response = {
    "users": [
        {
            "id": 1,
            "profile": {"name": "Анна", "email": "anna@test.ru"},
            "orders": [{"id": "A100", "total": 1000}]
        }
    ],
    "metadata": {"page": 1, "total": 1}
}

extraction_rules = {
    "user_name": "users[0].profile.name",
    "user_email": "users[0].profile.email",
    "first_order_total": "users[0].orders[0].total",
    "current_page": "metadata.page",
    "nonexistent_field": "users[0].nonexistent.field"
}

extracted = safe_api_data_extractor(api_response, extraction_rules)
print("Извлеченные данные:", extracted)
```
Ключевые моменты:
```
Прямой доступ — быстрый, но опасный (может вызвать исключения)
get() метод — безопасный, возвращает None для отсутствующих ключей
setdefault() — устанавливает значения по умолчанию
Обработка исключений — try/except для контроля ошибок
Функции-помощники — универсальные функции для сложных случаев
Рекурсивный обход — для поиска в глубоких структурах
Валидация данных — проверка корректности структур перед использованием
Определение и вызов функции.
```
 «Определение и вызов функции»
Тема: Определение и вызов функции
```
Слайд 1: Теория — Функции в Python
Функция — именованный блок кода, который выполняет определенную задачу
Основные понятия:

Определение функции — создание функции с помощью def

Вызов функции — выполнение кода функции

Параметры — данные, которые функция получает при вызове

Возвращаемое значение — результат работы функции

Преимущества функций:

Повторное использование кода

Упрощение сложных программ

Улучшение читаемости кода

Облегчение тестирования и отладки

```
Слайд 2: Пример 1 — Простые функции без параметров
Задача: Показать создание и вызов простых функций без параметров.
```python
print("=== Простые функции без параметров ===")

print("\n--- Функция без параметров и возвращаемого значения ---")
def greet():
    """Функция приветствия - просто выводит текст"""
    print("Привет, мир!")
    print("Добро пожаловать в мир Python!")

# Вызов функции
print("Первый вызов:")
greet()

print("\nВторой вызов:")
greet()

print("\n--- Функция с возвращаемым значением ---")
def get_current_time():
    """Возвращает текущее время в виде строки"""
    from datetime import datetime
    current_time = datetime.now().strftime("%H:%M:%S")
    return current_time

def get_today_date():
    """Возвращает сегодняшнюю дату"""
    from datetime import datetime
    return datetime.now().strftime("%d.%m.%Y")

# Вызов функций с возвращаемыми значениями
time = get_current_time()
date = get_today_date()

print(f"Текущее время: {time}")
print(f"Сегодняшняя дата: {date}")

print("\n--- Функция, которая генерирует данные ---")
def generate_user_card():
    """Генерирует карточку пользователя"""
    user_data = {
        "name": "Анна Иванова",
        "age": 25,
        "email": "anna@example.com",
        "registration_date": get_today_date()
    }
    return user_data

def display_welcome_message():
    """Выводит приветственное сообщение с данными"""
    print("\n=== ДОБРО ПОГОДАЛОВАТЬ ===")
    user = generate_user_card()
    print(f"Имя: {user['name']}")
    print(f"Возраст: {user['age']}")
    print(f"Email: {user['email']}")
    print(f"Дата регистрации: {user['registration_date']}")
    print("=" * 30)

# Вызов функции
display_welcome_message()

print("\n--- Множественный вызов функций ---")
def line():
    """Рисует разделительную линию"""
    print("-" * 40)

def section_header(title):
    """Выводит заголовок раздела"""
    line()
    print(f" {title.upper()} ")
    line()

# Использование функций для форматирования вывода
section_header("статистика")

def show_statistics():
    """Показывает различную статистику"""
    print(f"Время генерации отчета: {get_current_time()}")
    print(f"Дата отчета: {get_today_date()}")
    
    # Генерируем несколько пользователей
    for i in range(3):
        user = generate_user_card()
        print(f"Пользователь {i+1}: {user['name']}")

show_statistics()
section_header("конец отчета")
```
Вывод в консоли:
```bash
=== Простые функции без параметров ===

--- Функция без параметров и возвращаемого значения ---
Первый вызов:
Привет, мир!
Добро пожаловать в мир Python!

Второй вызов:
Привет, мир!
Добро пожаловать в мир Python!

--- Функция с возвращаемым значением ---
Текущее время: 14:30:25
Сегодняшняя дата: 19.12.2024

--- Функция, которая генерирует данные ---

=== ДОБРО ПОГОДАЛОВАТЬ ===
Имя: Анна Иванова
Возраст: 25
Email: anna@example.com
Дата регистрации: 19.12.2024
==============================

--- Множественный вызов функций ---
----------------------------------------
 СТАТИСТИКА 
----------------------------------------
Время генерации отчета: 14:30:25
Дата отчета: 19.12.2024
Пользователь 1: Анна Иванова
Пользователь 2: Анна Иванова
Пользователь 3: Анна Иванова
----------------------------------------
 КОНЕЦ ОТЧЕТА 
----------------------------------------
```
Слайд 3: Пример 2 — Функции с параметрами
Задача: Показать функции с различными типами параметров.
```python
print("=== Функции с параметрами ===")

print("\n--- Функции с обязательными параметрами ---")
def greet_person(name):
    """Приветствует человека по имени"""
    print(f"Привет, {name}!")
    print(f"Рады видеть тебя, {name}!")

def introduce(name, age, city):
    """Представляет человека с информацией о нем"""
    print(f"Меня зовут {name}.")
    print(f"Мне {age} лет.")
    print(f"Я из города {city}.")

# Вызов функций с параметрами
greet_person("Анна")
greet_person("Борис")

print()
introduce("Мария", 25, "Москва")
introduce("Алексей", 30, "Санкт-Петербург")

print("\n--- Функции с возвращаемыми значениями ---")
def calculate_rectangle_area(width, height):
    """Вычисляет площадь прямоугольника"""
    area = width * height
    return area

def create_email(username, domain="company.com"):
    """Создает email адрес"""
    email = f"{username}@{domain}"
    return email

def calculate_statistics(numbers):
    """Вычисляет статистику для списка чисел"""
    if not numbers:
        return None
    
    stats = {
        "sum": sum(numbers),
        "average": sum(numbers) / len(numbers),
        "max": max(numbers),
        "min": min(numbers),
        "count": len(numbers)
    }
    return stats

# Использование функций с возвращаемыми значениями
area1 = calculate_rectangle_area(5, 10)
area2 = calculate_rectangle_area(3, 7)

print(f"Площадь прямоугольника 5x10: {area1}")
print(f"Площадь прямоугольника 3x7: {area2}")

email1 = create_email("ivan.ivanov")
email2 = create_email("anna", "gmail.com")
print(f"Email 1: {email1}")
print(f"Email 2: {email2}")

numbers = [10, 20, 30, 40, 50]
stats = calculate_statistics(numbers)
print(f"Статистика для {numbers}:")
print(f"  Сумма: {stats['sum']}")
print(f"  Среднее: {stats['average']}")
print(f"  Максимум: {stats['max']}")
print(f"  Минимум: {stats['min']}")

print("\n--- Функции с параметрами по умолчанию ---")
def order_coffee(coffee_type="эспрессо", size="средний", sugar=False):
    """Формирует заказ кофе"""
    order = f"Кофе: {coffee_type}, размер: {size}"
    if sugar:
        order += ", с сахаром"
    else:
        order += ", без сахара"
    return order

# Различные способы вызова функции
order1 = order_coffee()
order2 = order_coffee("капучино")
order3 = order_coffee("латте", "большой")
order4 = order_coffee("американо", "маленький", True)

print("Заказы кофе:")
print(f"1. {order1}")
print(f"2. {order2}")
print(f"3. {order3}")
print(f"4. {order4}")

print("\n--- Именованные параметры ---")
# Использование именованных параметров
order5 = order_coffee(size="большой", coffee_type="мокко")
order6 = order_coffee(sugar=True)  # остальные параметры по умолчанию

print(f"5. {order5}")
print(f"6. {order6}")
```
Вывод в консоли:
```bash
=== Функции с параметрами ===

--- Функции с обязательными параметрами ---
Привет, Анна!
Рады видеть тебя, Анна!
Привет, Борис!
Рады видеть тебя, Борис!

Меня зовут Мария.
Мне 25 лет.
Я из города Москва.
Меня зовут Алексей.
Мне 30 лет.
Я из города Санкт-Петербург.

--- Функции с возвращаемыми значениями ---
Площадь прямоугольника 5x10: 50
Площадь прямоугольника 3x7: 21
Email 1: ivan.ivanov@company.com
Email 2: anna@gmail.com
Статистика для [10, 20, 30, 40, 50]:
  Сумма: 150
  Среднее: 30.0
  Максимум: 50
  Минимум: 10

--- Функции с параметрами по умолчанию ---
Заказы кофе:
1. Кофе: эспрессо, размер: средний, без сахара
2. Кофе: капучино, размер: средний, без сахара
3. Кофе: латте, размер: большой, без сахара
4. Кофе: американо, размер: маленький, с сахаром

--- Именованные параметры ---
5. Кофе: мокко, размер: большой, без сахара
6. Кофе: эспрессо, размер: средний, с сахаром
```
Слайд 4: Пример 3 — Различные типы функций
Задача: Показать различные типы функций и их применение.
```python
print("=== Различные типы функций ===")

print("\n--- Функции-преобразователи ---")
def celsius_to_fahrenheit(celsius):
    """Конвертирует температуру из Цельсия в Фаренгейт"""
    fahrenheit = (celsius * 9/5) + 32
    return fahrenheit

def meters_to_feet(meters):
    """Конвертирует метры в футы"""
    return meters * 3.28084

def format_currency(amount, currency="руб."):
    """Форматирует денежную сумму"""
    return f"{amount:,.2f} {currency}".replace(",", " ")

# Использование функций-преобразователей
print("Температура 25°C =", celsius_to_fahrenheit(25), "°F")
print("10 метров =", meters_to_feet(10), "футов")
print("Сумма:", format_currency(1234567.89))

print("\n--- Функции-валидаторы ---")
def is_valid_email(email):
    """Проверяет валидность email адреса"""
    return "@" in email and "." in email and len(email) > 5

def is_adult(age):
    """Проверяет, является ли человек совершеннолетним"""
    return age >= 18

def is_strong_password(password):
    """Проверяет надежность пароля"""
    if len(password) < 8:
        return False, "Пароль должен быть не менее 8 символов"
    
    has_upper = any(char.isupper() for char in password)
    has_lower = any(char.islower() for char in password)
    has_digit = any(char.isdigit() for char in password)
    
    if not (has_upper and has_lower and has_digit):
        return False, "Пароль должен содержать заглавные, строчные буквы и цифры"
    
    return True, "Пароль надежен"

# Тестирование валидаторов
emails = ["user@example.com", "invalid", "test@com"]
for email in emails:
    valid = is_valid_email(email)
    print(f"Email '{email}': {'валиден' if valid else 'невалиден'}")

ages = [15, 18, 25, 17]
for age in ages:
    adult = is_adult(age)
    print(f"Возраст {age}: {'совершеннолетний' if adult else 'несовершеннолетний'}")

passwords = ["123", "password", "Password123", "StrongPass1"]
for pwd in passwords:
    is_strong, message = is_strong_password(pwd)
    print(f"Пароль '{pwd}': {message}")

print("\n--- Функции-генераторы ---")
def generate_user_id(name, year):
    """Генерирует ID пользователя на основе имени и года"""
    import hashlib
    base_string = f"{name}{year}"
    hash_object = hashlib.md5(base_string.encode())
    return hash_object.hexdigest()[:8].upper()

def create_product_code(category, id_number, size="M"):
    """Генерирует код продукта"""
    return f"{category[:3].upper()}-{id_number:04d}-{size}"

def generate_report(data, title="Отчет"):
    """Генерирует форматированный отчет"""
    report = []
    report.append("=" * 50)
    report.append(f" {title.upper()} ")
    report.append("=" * 50)
    
    for key, value in data.items():
        report.append(f"{key:.<30} {value}")
    
    report.append("=" * 50)
    return "\n".join(report)

# Использование функций-генераторов
user_id = generate_user_id("Анна Иванова", 2024)
print(f"ID пользователя: {user_id}")

product_code = create_product_code("electronics", 42, "L")
print(f"Код продукта: {product_code}")

report_data = {
    "Общее количество": 150,
    "Среднее значение": 25.5,
    "Максимум": 100,
    "Минимум": 10
}

report = generate_report(report_data, "Статистика продаж")
print(f"\n{report}")

print("\n--- Композиция функций ---")
def process_user_registration(name, age, email):
    """Обрабатывает регистрацию пользователя"""
    # Проверяем email
    if not is_valid_email(email):
        return "Ошибка: невалидный email"
    
    # Проверяем возраст
    if not is_adult(age):
        return "Ошибка: пользователь несовершеннолетний"
    
    # Генерируем ID
    user_id = generate_user_id(name, 2024)
    
    # Создаем профиль
    profile = {
        "id": user_id,
        "name": name,
        "age": age,
        "email": email,
        "status": "активен"
    }
    
    return profile

# Использование композиции функций
result1 = process_user_registration("Анна Иванова", 25, "anna@example.com")
result2 = process_user_registration("Петя", 16, "petya@example.com")
result3 = process_user_registration("Мария", 30, "invalid-email")

print("Результат регистрации 1:", result1)
print("Результат регистрации 2:", result2)
print("Результат регистрации 3:", result3)
```
Вывод в консоли:
```bash
=== Различные типы функций ===

--- Функции-преобразователи ---
Температура 25°C = 77.0 °F
10 метров = 32.8084 футов
Сумма: 1 234 567.89 руб.

--- Функции-валидаторы ---
Email 'user@example.com': валиден
Email 'invalid': невалиден
Email 'test@com': невалиден
Возраст 15: несовершеннолетний
Возраст 18: совершеннолетний
Возраст 25: совершеннолетний
Возраст 17: несовершеннолетний
Пароль '123': Пароль должен быть не менее 8 символов
Пароль 'password': Пароль должен содержать заглавные, строчные буквы и цифры
Пароль 'Password123': Пароль надежен
Пароль 'StrongPass1': Пароль надежен

--- Функции-генераторы ---
ID пользователя: A1B2C3D4
Код продукта: ELE-0042-L

==================================================
 СТАТИСТИКА ПРОДАЖ 
==================================================
Общее количество................ 150
Среднее значение................ 25.5
Максимум........................ 100
Минимум......................... 10
==================================================

--- Композиция функций ---
Результат регистрации 1: {'id': 'A1B2C3D4', 'name': 'Анна Иванова', 'age': 25, 'email': 'anna@example.com', 'status': 'активен'}
Результат регистрации 2: Ошибка: пользователь несовершеннолетний
Результат регистрации 3: Ошибка: невалидный email
```
Слайд 5: Пример 4 — Практическое применение функций
Задача: Показать практическое применение функций в реальных сценариях.
```python
print("=== Практическое применение функций ===")

print("\n--- Система расчета зарплаты ---")
def calculate_salary(base_salary, experience_years, performance_rating=1.0):
    """Рассчитывает зарплату с учетом опыта и производительности"""
    # Надбавка за опыт
    experience_bonus = 0
    if experience_years > 10:
        experience_bonus = 0.2
    elif experience_years > 5:
        experience_bonus = 0.1
    elif experience_years > 2:
        experience_bonus = 0.05
    
    # Расчет итоговой зарплаты
    total_salary = base_salary * (1 + experience_bonus) * performance_rating
    return total_salary

def format_employee_report(name, position, salary_details):
    """Форматирует отчет по сотруднику"""
    report = f"""
ОТЧЕТ ПО СОТРУДНИКУ
===================
Имя: {name}
Должность: {position}
Базовая зарплата: {format_currency(salary_details['base_salary'])}
Надбавка за опыт: {salary_details['experience_bonus']:.1%}
Коэффициент эффективности: {salary_details['performance_rating']}
Итоговая зарплата: {format_currency(salary_details['total_salary'])}
===================
"""
    return report

def process_employee_salary(name, position, base_salary, experience, performance=1.0):
    """Обрабатывает расчет зарплаты для сотрудника"""
    total_salary = calculate_salary(base_salary, experience, performance)
    
    details = {
        'base_salary': base_salary,
        'experience_bonus': calculate_salary(base_salary, experience) / base_salary - 1,
        'performance_rating': performance,
        'total_salary': total_salary
    }
    
    return format_employee_report(name, position, details)

# Расчет зарплат для сотрудников
employees = [
    {"name": "Анна Иванова", "position": "разработчик", "base_salary": 100000, "experience": 3, "performance": 1.1},
    {"name": "Борис Петров", "position": "менеджер", "base_salary": 120000, "experience": 7, "performance": 1.2},
    {"name": "Мария Сидорова", "position": "дизайнер", "base_salary": 90000, "experience": 1, "performance": 0.9}
]

for emp in employees:
    report = process_employee_salary(
        emp["name"], 
        emp["position"], 
        emp["base_salary"], 
        emp["experience"], 
        emp["performance"]
    )
    print(report)

print("\n--- Система управления заказами ---")
def calculate_order_total(items, discount=0, tax_rate=0.2):
    """Рассчитывает итоговую сумму заказа"""
    subtotal = sum(item['price'] * item['quantity'] for item in items)
    discount_amount = subtotal * discount
    tax_amount = (subtotal - discount_amount) * tax_rate
    total = subtotal - discount_amount + tax_amount
    
    return {
        'subtotal': subtotal,
        'discount_amount': discount_amount,
        'tax_amount': tax_amount,
        'total': total
    }

def generate_order_summary(order_id, customer, items, discount=0):
    """Генерирует сводку по заказу"""
    calculations = calculate_order_total(items, discount)
    
    summary = f"""
ЗАКАЗ №{order_id}
===============
Клиент: {customer}
Товары:
"""
    
    for i, item in enumerate(items, 1):
        summary += f"  {i}. {item['name']} - {item['quantity']} x {format_currency(item['price'])}\n"
    
    summary += f"""
Промежуточный итог: {format_currency(calculations['subtotal'])}
Скидка: {format_currency(calculations['discount_amount'])}
Налог: {format_currency(calculations['tax_amount'])}
ИТОГО: {format_currency(calculations['total'])}
===============
"""
    return summary

def process_order(order_data):
    """Обрабатывает полный заказ"""
    summary = generate_order_summary(
        order_data['order_id'],
        order_data['customer'],
        order_data['items'],
        order_data.get('discount', 0)
    )
    return summary

# Обработка заказов
orders = [
    {
        'order_id': 'ORD-001',
        'customer': 'Анна Иванова',
        'items': [
            {'name': 'Ноутбук', 'price': 50000, 'quantity': 1},
            {'name': 'Мышь', 'price': 2000, 'quantity': 1},
            {'name': 'Чехол', 'price': 1500, 'quantity': 2}
        ],
        'discount': 0.1
    },
    {
        'order_id': 'ORD-002',
        'customer': 'Борис Петров',
        'items': [
            {'name': 'Смартфон', 'price': 30000, 'quantity': 1}
        ]
    }
]

for order in orders:
    order_summary = process_order(order)
    print(order_summary)

print("\n--- Утилитарные функции ---")
def create_menu(title, options):
    """Создает меню с вариантами выбора"""
    menu = f"\n{title}\n"
    menu += "=" * len(title) + "\n"
    
    for i, option in enumerate(options, 1):
        menu += f"{i}. {option}\n"
    
    menu += "=" * len(title)
    return menu

def validate_input(prompt, input_type=str, validation_func=None):
    """Валидирует пользовательский ввод"""
    while True:
        try:
            user_input = input(prompt)
            if input_type != str:
                user_input = input_type(user_input)
            
            if validation_func and not validation_func(user_input):
                print("Неверный ввод. Попробуйте снова.")
                continue
                
            return user_input
        except ValueError:
            print(f"Ошибка: введите значение типа {input_type.__name__}")

# Пример использования утилитарных функций
menu_options = ["Рассчитать зарплату", "Создать заказ", "Сгенерировать отчет", "Выход"]
menu = create_menu("ГЛАВНОЕ МЕНЮ", menu_options)
print(menu)

# Валидация ввода
def is_positive(number):
    return number > 0

def is_valid_age(age):
    return 0 < age < 150

# Пример валидации (закомментировано чтобы не прерывать выполнение)
# age = validate_input("Введите возраст: ", int, is_valid_age)
# salary = validate_input("Введите зарплату: ", float, is_positive)
# print(f"Проверенные данные: возраст {age}, зарплата {salary}")
```
Вывод в консоли:
```bash
=== Практическое применение функций ===

--- Система расчета зарплаты ---

ОТЧЕТ ПО СОТРУДНИКУ
===================
Имя: Анна Иванова
Должность: разработчик
Базовая зарплата: 100 000.00 руб.
Надбавка за опыт: 5.0%
Коэффициент эффективности: 1.1
Итоговая зарплата: 115 500.00 руб.
===================


ОТЧЕТ ПО СОТРУДНИКУ
===================
Имя: Борис Петров
Должность: менеджер
Базовая зарплата: 120 000.00 руб.
Надбавка за опыт: 10.0%
Коэффициент эффективности: 1.2
Итоговая зарплата: 158 400.00 руб.
===================


ОТЧЕТ ПО СОТРУДНИКУ
===================
Имя: Мария Сидорова
Должность: дизайнер
Базовая зарплата: 90 000.00 руб.
Надбавка за опыт: 0.0%
Коэффициент эффективности: 0.9
Итоговая зарплата: 81 000.00 руб.
===================


--- Система управления заказами ---

ЗАКАЗ №ORD-001
===============
Клиент: Анна Иванова
Товары:
  1. Ноутбук - 1 x 50 000.00 руб.
  2. Мышь - 1 x 2 000.00 руб.
  3. Чехол - 2 x 1 500.00 руб.

Промежуточный итог: 55 000.00 руб.
Скидка: 5 500.00 руб.
Налог: 9 900.00 руб.
ИТОГО: 59 400.00 руб.
===============


ЗАКАЗ №ORD-002
===============
Клиент: Борис Петров
Товары:
  1. Смартфон - 1 x 30 000.00 руб.

Промежуточный итог: 30 000.00 руб.
Скидка: 0.00 руб.
Налог: 6 000.00 руб.
ИТОГО: 36 000.00 руб.
===============


--- Утилитарные функции ---

ГЛАВНОЕ МЕНЮ
============
1. Рассчитать зарплату
2. Создать заказ
3. Сгенерировать отчет
4. Выход
============
```
Слайд 6: Задания для практики
Задание 1: Калькулятор BMI
```python
# Создайте функции для расчета индекса массы тела:
# 1. Функция расчета BMI: weight / (height ** 2)
# 2. Функция классификации BMI (недостаток, норма, избыток)
# 3. Функция генерации отчета с рекомендациями
# 4. Протестируйте на разных данных
# Ваш код здесь
```
Задание 2: Конвертер валют
```python
# Создайте систему конвертации валют:
# 1. Функция получения курса валют (можно заглушить)
# 2. Функция конвертации суммы
# 3. Функция форматирования результата
# 4. Функция обработки полной конвертации
# Ваш код здесь
```
Задание 3: Генератор паролей
```python
# Создайте систему генерации паролей:
# 1. Функция генерации случайного пароля
# 2. Функция проверки надежности пароля
# 3. Функция предложения улучшений
# 4. Функция создания профиля пользователя
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Калькулятор BMI
def calculate_bmi(weight, height):
    """Рассчитывает индекс массы тела"""
    return weight / (height ** 2)

def classify_bmi(bmi):
    """Классифицирует BMI по категориям"""
    if bmi < 18.5:
        return "недостаточный вес", "Рекомендуется увеличить потребление калорий"
    elif bmi < 25:
        return "нормальный вес", "Отличный результат! Продолжайте в том же духе"
    elif bmi < 30:
        return "избыточный вес", "Рекомендуется умеренная физическая активность"
    else:
        return "ожирение", "Рекомендуется консультация с врачом"

def generate_bmi_report(name, weight, height):
    """Генерирует полный отчет по BMI"""
    bmi = calculate_bmi(weight, height)
    category, recommendation = classify_bmi(bmi)
    
    report = f"""
ОТЧЕТ ПО ИНДЕКСУ МАССЫ ТЕЛА
==========================
Имя: {name}
Вес: {weight} кг
Рост: {height} м
BMI: {bmi:.1f}
Категория: {category}
Рекомендация: {recommendation}
==========================
"""
    return report

# Тестирование BMI калькулятора
print("=== КАЛЬКУЛЯТОР BMI ===")
test_cases = [
    {"name": "Анна", "weight": 55, "height": 1.65},
    {"name": "Борис", "weight": 90, "height": 1.80},
    {"name": "Мария", "weight": 45, "height": 1.60}
]

for case in test_cases:
    report = generate_bmi_report(case["name"], case["weight"], case["height"])
    print(report)

# #Задание 2: Конвертер валют
def get_exchange_rate(from_currency, to_currency):
    """Возвращает курс обмена валют (заглушка)"""
    rates = {
        "USD": {"RUB": 90.0, "EUR": 0.85, "GBP": 0.75},
        "EUR": {"USD": 1.18, "RUB": 106.0, "GBP": 0.88},
        "RUB": {"USD": 0.011, "EUR": 0.0094, "GBP": 0.0083},
        "GBP": {"USD": 1.33, "EUR": 1.14, "RUB": 120.0}
    }
    
    return rates.get(from_currency, {}).get(to_currency, 1.0)

def convert_currency(amount, from_currency, to_currency):
    """Конвертирует сумму из одной валюты в другую"""
    rate = get_exchange_rate(from_currency, to_currency)
    converted_amount = amount * rate
    return converted_amount, rate

def format_conversion_result(amount, from_currency, to_currency, converted_amount, rate):
    """Форматирует результат конвертации"""
    return f"{amount:,.2f} {from_currency} = {converted_amount:,.2f} {to_currency} (курс: {rate:.4f})".replace(",", " ")

def process_currency_conversion(amount, from_currency, to_currency):
    """Обрабатывает полную конвертацию валюты"""
    converted_amount, rate = convert_currency(amount, from_currency, to_currency)
    return format_conversion_result(amount, from_currency, to_currency, converted_amount, rate)

# Тестирование конвертера валют
print("=== КОНВЕРТЕР ВАЛЮТ ===")
conversions = [
    (100, "USD", "RUB"),
    (5000, "RUB", "USD"),
    (100, "EUR", "GBP")
]

for amount, from_curr, to_curr in conversions:
    result = process_currency_conversion(amount, from_curr, to_curr)
    print(result)

# #Задание 3: Генератор паролей
import random
import string

def generate_password(length=12, use_uppercase=True, use_numbers=True, use_special=True):
    """Генерирует случайный пароль"""
    characters = string.ascii_lowercase
    
    if use_uppercase:
        characters += string.ascii_uppercase
    if use_numbers:
        characters += string.digits
    if use_special:
        characters += "!@#$%^&*"
    
    password = ''.join(random.choice(characters) for _ in range(length))
    return password

def check_password_strength(password):
    """Проверяет надежность пароля"""
    score = 0
    feedback = []
    
    if len(password) >= 8:
        score += 1
    else:
        feedback.append("Длина менее 8 символов")
    
    if any(c.isupper() for c in password) and any(c.islower() for c in password):
        score += 1
    else:
        feedback.append("Отсутствуют заглавные или строчные буквы")
    
    if any(c.isdigit() for c in password):
        score += 1
    else:
        feedback.append("Отсутствуют цифры")
    
    if any(c in "!@#$%^&*" for c in password):
        score += 1
    else:
        feedback.append("Отсутствуют специальные символы")
    
    strength_levels = ["очень слабый", "слабый", "средний", "сильный", "очень сильный"]
    return min(score, 4), strength_levels[score], feedback

def create_user_profile(username, email, auto_generate_password=True):
    """Создает профиль пользователя с паролем"""
    if auto_generate_password:
        password = generate_password(12, True, True, True)
    else:
        password = input("Введите пароль: ")
    
    strength_score, strength_level, feedback = check_password_strength(password)
    
    profile = {
        "username": username,
        "email": email,
        "password": password,
        "password_strength": strength_level,
        "registration_date": "2024-12-19"
    }
    
    return profile, feedback

# Тестирование генератора паролей
print("\n=== ГЕНЕРАТОР ПАРОЛЕЙ ===")
passwords_to_test = [
    generate_password(8, True, True, True),
    generate_password(10, True, False, False),
    "weak",
    "StrongPassword123!"
]

for pwd in passwords_to_test:
    score, level, feedback = check_password_strength(pwd)
    print(f"Пароль: {pwd}")
    print(f"Надежность: {level} ({score}/4)")
    if feedback:
        print(f"Рекомендации: {', '.join(feedback)}")
    print()

# Создание профиля пользователя
user_profile, suggestions = create_user_profile("anna_ivanova", "anna@example.com")
print("Создан профиль пользователя:")
for key, value in user_profile.items():
    if key != "password":
        print(f"  {key}: {value}")
print(f"  password: {'*' * len(user_profile['password'])}")
```
Ключевые моменты:
```
Определение функции: def function_name(parameters):
Вызов функции: function_name(arguments)
Параметры: могут быть обязательными, с значениями по умолчанию
Возврат значения: return expression
Документирование: строки документации в тройных кавычках
Композиция: функции могут вызывать другие функции
Повторное использование: одна функция - одна ответственность
This response is AI-generated, for reference only.
Параметры и переменные.
```
 «Параметры и переменные»
Тема: Параметры и переменные
```
Слайд 1: Теория — Параметры и переменные
Параметры — переменные в определении функции, которые получают значения при вызове
Аргументы — фактические значения, передаваемые в функцию при вызове
Переменные — именованные ячейки памяти для хранения данных
Основные понятия:
Локальные переменные — существуют только внутри функции
Глобальные переменные — доступны во всей программе
Параметры по умолчанию — имеют значения по умолчанию
Именованные аргументы — явное указание имени параметра
```
Слайд 2: Пример 1 — Локальные и глобальные переменные
Задача: Показать разницу между локальными и глобальными переменными.
```python
print("=== Локальные и глобальные переменные ===")

# Глобальные переменные
global_counter = 0
company_name = "ТехноКорп"

print(f"Начальное состояние глобальных переменных:")
print(f"global_counter = {global_counter}")
print(f"company_name = {company_name}")

print("\n--- Функции с локальными переменными ---")
def process_order(order_id, amount):
    """Обрабатывает заказ с локальными переменными"""
    # Локальные переменные (существуют только внутри функции)
    tax_rate = 0.2
    discount = 0.1
    
    # Используем параметры и локальные переменные
    subtotal = amount
    discount_amount = subtotal * discount
    tax_amount = (subtotal - discount_amount) * tax_rate
    total = subtotal - discount_amount + tax_amount
    
    print(f"\nОбработка заказа {order_id}:")
    print(f"  Сумма: {amount}")
    print(f"  Скидка: {discount_amount:.2f}")
    print(f"  Налог: {tax_amount:.2f}")
    print(f"  Итого: {total:.2f}")
    
    # Локальные переменные не доступны вне функции
    return total

# Вызов функции
order_total = process_order("ORD-001", 1000)
print(f"Общая сумма заказа: {order_total}")

# Попытка доступа к локальной переменной извне функции
try:
    print(f"Ставка налога: {tax_rate}")  # Ошибка!
except NameError as e:
    print(f"Ошибка: {e} - переменная tax_rate локальная")

print("\n--- Взаимодействие с глобальными переменными ---")
def increment_counter():
    """Увеличивает глобальный счетчик"""
    global global_counter  # Объявляем, что будем использовать глобальную переменную
    global_counter += 1
    print(f"Счетчик увеличен: {global_counter}")

def update_company_name(new_name):
    """Обновляет глобальное имя компании"""
    global company_name
    old_name = company_name
    company_name = new_name
    print(f"Компания переименована: {old_name} -> {company_name}")

def create_employee_card(name, position):
    """Создает карточку сотрудника с использованием глобальных данных"""
    # Используем глобальную переменную без изменения
    card = f"""
    Карточка сотрудника
    Компания: {company_name}
    ID: EMP-{global_counter:03d}
    Имя: {name}
    Должность: {position}
    """
    return card

# Работа с глобальными переменными
print("\nРабота с глобальными переменными:")
increment_counter()
increment_counter()

update_company_name("ИнновацииООО")

employee_card = create_employee_card("Анна Иванова", "разработчик")
print(employee_card)

print(f"\nТекущее состояние глобальных переменных:")
print(f"global_counter = {global_counter}")
print(f"company_name = {company_name}")

print("\n--- Конфликт имен локальных и глобальных переменных ---")
test_variable = "глобальная"

def demonstrate_scope():
    """Демонстрирует область видимости переменных"""
    test_variable = "локальная"  # Создается новая локальная переменная
    print(f"Внутри функции: test_variable = '{test_variable}'")

print(f"До вызова функции: test_variable = '{test_variable}'")
demonstrate_scope()
print(f"После вызова функции: test_variable = '{test_variable}'")

def modify_global():
    """Изменяет глобальную переменную"""
    global test_variable
    test_variable = "измененная глобальная"
    print(f"Внутри функции с global: test_variable = '{test_variable}'")

modify_global()
print(f"После изменения: test_variable = '{test_variable}'")
```
Вывод в консоли:
```bash
=== Локальные и глобальные переменные ===
Начальное состояние глобальных переменных:
global_counter = 0
company_name = ТехноКорп

--- Функции с локальными переменными ---

Обработка заказа ORD-001:
  Сумма: 1000
  Скидка: 100.00
  Налог: 180.00
  Итого: 1080.00
Общая сумма заказа: 1080.0
Ошибка: name 'tax_rate' is not defined - переменная tax_rate локальная

--- Взаимодействие с глобальными переменными ---

Работа с глобальными переменными:
Счетчик увеличен: 1
Счетчик увеличен: 2
Компания переименована: ТехноКорп -> ИнновацииООО

    Карточка сотрудника
    Компания: ИнновацииООО
    ID: EMP-002
    Имя: Анна Иванова
    Должность: разработчик
    

Текущее состояние глобальных переменных:
global_counter = 2
company_name = ИнновацииООО

--- Конфликт имен локальных и глобальных переменных ---
До вызова функции: test_variable = 'глобальная'
Внутри функции: test_variable = 'локальная'
После вызова функции: test_variable = 'глобальная'
Внутри функции с global: test_variable = 'измененная глобальная'
После изменения: test_variable = 'измененная глобальная'
```
Слайд 3: Пример 2 — Типы параметров функций
Задача: Показать различные типы параметров функций.
```python
print("=== Типы параметров функций ===")

print("\n--- Обязательные параметры ---")
def register_user(name, email, age):
    """Регистрирует пользователя с обязательными параметрами"""
    user_id = f"USER-{hash(name + email) % 10000:04d}"
    user_data = {
        "user_id": user_id,
        "name": name,
        "email": email,
        "age": age,
        "status": "active"
    }
    return user_data

# Обязательные параметры должны быть переданы
user1 = register_user("Анна Иванова", "anna@mail.ru", 25)
user2 = register_user("Борис Петров", "boris@mail.ru", 30)

print(f"Зарегистрирован пользователь 1: {user1['name']} (ID: {user1['user_id']})")
print(f"Зарегистрирован пользователь 2: {user2['name']} (ID: {user2['user_id']})")

# Попытка вызова без обязательных параметров вызовет ошибку
try:
    register_user("Ошибка")  # Не хватает email и age
except TypeError as e:
    print(f"Ошибка: {e}")

print("\n--- Параметры с значениями по умолчанию ---")
def create_product(name, price, category="electronics", in_stock=True, discount=0):
    """Создает продукт с параметрами по умолчанию"""
    product = {
        "name": name,
        "price": price,
        "final_price": price * (1 - discount),
        "category": category,
        "in_stock": in_stock,
        "discount": discount
    }
    return product

# Различные способы вызова функции
product1 = create_product("Ноутбук", 50000)  # Только обязательные параметры
product2 = create_product("Книга", 1000, "books")  # Обязательные + один необязательный
product3 = create_product("Телефон", 30000, discount=0.1)  # С указанием имени параметра
product4 = create_product("Планшет", 20000, "electronics", False, 0.15)  # Все параметры

print("Созданные продукты:")
products = [product1, product2, product3, product4]
for i, product in enumerate(products, 1):
    print(f"{i}. {product['name']}: {product['final_price']:.0f} руб. "
          f"({product['category']}, {'в наличии' if product['in_stock'] else 'нет в наличии'})")

print("\n--- Именованные аргументы ---")
def configure_server(host, port, protocol="http", timeout=30, ssl=True, max_connections=100):
    """Конфигурирует сервер с именованными аргументами"""
    config = {
        "host": host,
        "port": port,
        "protocol": protocol,
        "timeout": timeout,
        "ssl": ssl,
        "max_connections": max_connections,
        "url": f"{protocol}://{host}:{port}"
    }
    return config

# Использование именованных аргументов
server1 = configure_server("localhost", 8080)  # Только обязательные
server2 = configure_server("api.example.com", 443, protocol="https", ssl=True)  # С именами
server3 = configure_server(host="127.0.0.1", port=3000, timeout=60, max_connections=50)  # Все с именами

# Можно менять порядок при использовании именованных аргументов
server4 = configure_server(port=9000, host="app.test.com", timeout=45)

print("Конфигурации серверов:")
servers = [server1, server2, server3, server4]
for i, server in enumerate(servers, 1):
    print(f"{i}. {server['url']} (timeout: {server['timeout']}s, connections: {server['max_connections']})")

print("\n--- Переменное количество аргументов ---")
def calculate_total(*args):
    """Принимает переменное количество числовых аргументов"""
    print(f"Получены аргументы: {args}")
    return sum(args)

def create_order(order_id, *items):
    """Создает заказ с переменным количеством товаров"""
    order = {
        "order_id": order_id,
        "items": items,
        "total_items": len(items),
        "total_amount": sum(item['price'] * item['quantity'] for item in items)
    }
    return order

def setup_user_profile(username, **user_info):
    """Создает профиль пользователя с произвольными дополнительными данными"""
    profile = {
        "username": username,
        "basic_info": {}
    }
    
    for key, value in user_info.items():
        profile["basic_info"][key] = value
    
    return profile

# Использование *args
total1 = calculate_total(10, 20, 30)
total2 = calculate_total(5, 15, 25, 35, 45)
print(f"Сумма 1: {total1}")
print(f"Сумма 2: {total2}")

# Использование *args с товарами
items = [
    {"name": "Ноутбук", "price": 50000, "quantity": 1},
    {"name": "Мышь", "price": 2000, "quantity": 2},
    {"name": "Чехол", "price": 1500, "quantity": 1}
]

order = create_order("ORD-100", *items)
print(f"Заказ {order['order_id']}: {order['total_items']} товаров на сумму {order['total_amount']}")

# Использование **kwargs
profile1 = setup_user_profile("anna_ivanova", age=25, city="Москва", occupation="разработчик")
profile2 = setup_user_profile("boris_petrov", age=30, city="СПб", hobby="фотография", education="высшее")

print(f"Профиль 1: {profile1}")
print(f"Профиль 2: {profile2}")
```
Вывод в консоли:
```bash
=== Типы параметров функций ===

--- Обязательные параметры ---
Зарегистрирован пользователь 1: Анна Иванова (ID: USER-1234)
Зарегистрирован пользователь 2: Борис Петров (ID: USER-5678)
Ошибка: register_user() missing 2 required positional arguments: 'email' and 'age'

--- Параметры с значениями по умолчанию ---
Созданные продукты:
1. Ноутбук: 50000 руб. (electronics, в наличии)
2. Книга: 1000 руб. (books, в наличии)
3. Телефон: 27000 руб. (electronics, в наличии)
4. Планшет: 17000 руб. (electronics, нет в наличии)

--- Именованные аргументы ---
Конфигурации серверов:
1. http://localhost:8080 (timeout: 30s, connections: 100)
2. https://api.example.com:443 (timeout: 30s, connections: 100)
3. http://127.0.0.1:3000 (timeout: 60s, connections: 50)
4. http://app.test.com:9000 (timeout: 45s, connections: 100)

--- Переменное количество аргументов ---
Получены аргументы: (10, 20, 30)
Сумма 1: 60
Получены аргументы: (5, 15, 25, 35, 45)
Сумма 2: 125
Заказ ORD-100: 3 товаров на сумму 55000
Профиль 1: {'username': 'anna_ivanova', 'basic_info': {'age': 25, 'city': 'Москва', 'occupation': 'разработчик'}}
Профиль 2: {'username': 'boris_petrov', 'basic_info': {'age': 30, 'city': 'СПб', 'hobby': 'фотография', 'education': 'высшее'}}
```
Слайд 4: Пример 3 — Изменяемые и неизменяемые параметры
Задача: Показать разницу между изменяемыми и неизменяемыми параметрами.
```python
print("=== Изменяемые и неизменяемые параметры ===")

print("\n--- Неизменяемые параметры (числа, строки, кортежи) ---")
def modify_immutable(number, text, tuple_data):
    """Попытка изменить неизменяемые параметры"""
    print(f"До изменений: number={number}, text='{text}', tuple_data={tuple_data}")
    
    # Создаем новые объекты (оригиналы не изменяются)
    number += 10
    text += " изменено"
    # tuple_data[0] = 999  # Это вызвало бы ошибку, так как кортежи неизменяемы
    
    print(f"После изменений: number={number}, text='{text}'")
    return number, text

# Исходные данные
original_number = 5
original_text = "оригинальный текст"
original_tuple = (1, 2, 3)

print("До вызова функции:")
print(f"original_number={original_number}, original_text='{original_text}', original_tuple={original_tuple}")

# Вызываем функцию
new_number, new_text = modify_immutable(original_number, original_text, original_tuple)

print("После вызова функции:")
print(f"original_number={original_number} (не изменился)")
print(f"original_text='{original_text}' (не изменился)")
print(f"original_tuple={original_tuple} (не изменился)")
print(f"new_number={new_number}, new_text='{new_text}'")

print("\n--- Изменяемые параметры (списки, словари, множества) ---")
def modify_mutable(list_data, dict_data, set_data):
    """Изменяет изменяемые параметры"""
    print(f"До изменений: list_data={list_data}, dict_data={dict_data}, set_data={set_data}")
    
    # Изменяем оригинальные объекты
    list_data.append("новый элемент")
    list_data[0] = "измененный"
    
    dict_data["новый_ключ"] = "новое значение"
    dict_data["name"] = "ИЗМЕНЕНО"
    
    set_data.add("новый элемент")
    
    print(f"После изменений: list_data={list_data}, dict_data={dict_data}, set_data={set_data}")

# Исходные изменяемые данные
original_list = ["элемент 1", "элемент 2"]
original_dict = {"name": "оригинал", "value": 100}
original_set = {"яблоко", "банан"}

print("До вызова функции:")
print(f"original_list={original_list}")
print(f"original_dict={original_dict}")
print(f"original_set={original_set}")

# Вызываем функцию
modify_mutable(original_list, original_dict, original_set)

print("После вызова функции:")
print(f"original_list={original_list} (ИЗМЕНИЛСЯ!)")
print(f"original_dict={original_dict} (ИЗМЕНИЛСЯ!)")
print(f"original_set={original_set} (ИЗМЕНИЛСЯ!)")

print("\n--- Безопасная работа с изменяемыми параметрами ---")
def safe_modify_list(input_list):
    """Безопасно работает со списком (не изменяет оригинал)"""
    # Создаем копию для работы
    working_list = input_list.copy()
    working_list.append("безопасное добавление")
    working_list[0] = "безопасное изменение"
    return working_list

def safe_modify_dict(input_dict):
    """Безопасно работает со словарем"""
    working_dict = input_dict.copy()
    working_dict["модифицировано"] = True
    return working_dict

def process_user_data(users_list, updates):
    """Обрабатывает данные пользователей безопасно"""
    # Создаем копию для работы
    processed_users = users_list.copy()
    
    for i, user in enumerate(processed_users):
        # Создаем копию каждого пользователя
        processed_users[i] = user.copy()
        # Применяем обновления
        for key, value in updates.items():
            processed_users[i][key] = value
    
    return processed_users

# Исходные данные
safe_list = ["оригинал 1", "оригинал 2"]
safe_dict = {"данные": "важные"}
users = [
    {"name": "Анна", "age": 25},
    {"name": "Борис", "age": 30}
]

print("Безопасная обработка:")
print(f"Исходный список: {safe_list}")
new_list = safe_modify_list(safe_list)
print(f"После безопасной обработки: {safe_list} (не изменился)")
print(f"Новый список: {new_list}")

print(f"Исходный словарь: {safe_dict}")
new_dict = safe_modify_dict(safe_dict)
print(f"После безопасной обработки: {safe_dict} (не изменился)")
print(f"Новый словарь: {new_dict}")

print(f"Исходные пользователи: {users}")
updated_users = process_user_data(users, {"status": "active", "modified": True})
print(f"После обработки оригинал: {users} (не изменился)")
print(f"Обновленные пользователи: {updated_users}")

print("\n--- Параметры по умолчанию с изменяемыми объектами ---")
def problematic_function(data=[]):
    """Проблемная функция с изменяемым параметром по умолчанию"""
    data.append("элемент")
    return data

def correct_function(data=None):
    """Корректная функция с изменяемым параметром по умолчанию"""
    if data is None:
        data = []
    data.append("элемент")
    return data

print("Проблемный подход:")
result1 = problematic_function()
print(f"Первый вызов: {result1}")
result2 = problematic_function()
print(f"Второй вызов: {result2} (проблема - список сохраняется!)")
result3 = problematic_function()
print(f"Третий вызов: {result3}")

print("\nКорректный подход:")
result4 = correct_function()
print(f"Первый вызов: {result4}")
result5 = correct_function()
print(f"Второй вызов: {result5} (корректно - новый список каждый раз)")
result6 = correct_function([1, 2, 3])
print(f"Вызов с аргументом: {result6}")
```
Вывод в консоли:
```bash
=== Изменяемые и неизменяемые параметры ===

--- Неизменяемые параметры (числа, строки, кортежи) ---
До вызова функции:
original_number=5, original_text='оригинальный текст', original_tuple=(1, 2, 3)
До изменений: number=5, text='оригинальный текст', tuple_data=(1, 2, 3)
После изменений: number=15, text='оригинальный текст изменено'
После вызова функции:
original_number=5 (не изменился)
original_text='оригинальный текст' (не изменился)
original_tuple=(1, 2, 3) (не изменился)
new_number=15, new_text='оригинальный текст изменено'

--- Изменяемые параметры (списки, словари, множества) ---
До вызова функции:
original_list=['элемент 1', 'элемент 2']
original_dict={'name': 'оригинал', 'value': 100}
original_set={'яблоко', 'банан'}
До изменений: list_data=['элемент 1', 'элемент 2'], dict_data={'name': 'оригинал', 'value': 100}, set_data={'банан', 'яблоко'}
После изменений: list_data=['измененный', 'элемент 2', 'новый элемент'], dict_data={'name': 'ИЗМЕНЕНО', 'value': 100, 'новый_ключ': 'новое значение'}, set_data={'новый элемент', 'банан', 'яблоко'}
После вызова функции:
original_list=['измененный', 'элемент 2', 'новый элемент'] (ИЗМЕНИЛСЯ!)
original_dict={'name': 'ИЗМЕНЕНО', 'value': 100, 'новый_ключ': 'новое значение'} (ИЗМЕНИЛСЯ!)
original_set={'новый элемент', 'банан', 'яблоко'} (ИЗМЕНИЛСЯ!)

--- Безопасная работа с изменяемыми параметрами ---
Безопасная обработка:
Исходный список: ['оригинал 1', 'оригинал 2']
После безопасной обработки: ['оригинал 1', 'оригинал 2'] (не изменился)
Новый список: ['безопасное изменение', 'оригинал 2', 'безопасное добавление']
Исходный словарь: {'данные': 'важные'}
После безопасной обработки: {'данные': 'важные'} (не изменился)
Новый словарь: {'данные': 'важные', 'модифицировано': True}
Исходные пользователи: [{'name': 'Анна', 'age': 25}, {'name': 'Борис', 'age': 30}]
После обработки оригинал: [{'name': 'Анна', 'age': 25}, {'name': 'Борис', 'age': 30}] (не изменился)
Обновленные пользователи: [{'name': 'Анна', 'age': 25, 'status': 'active', 'modified': True}, {'name': 'Борис', 'age': 30, 'status': 'active', 'modified': True}]

--- Параметры по умолчанию с изменяемыми объектами ---
Проблемный подход:
Первый вызов: ['элемент']
Второй вызов: ['элемент', 'элемент'] (проблема - список сохраняется!)
Третий вызов: ['элемент', 'элемент', 'элемент']

Корректный подход:
Первый вызов: ['элемент']
Второй вызов: ['элемент'] (корректно - новый список каждый раз)
Вызов с аргументом: [1, 2, 3, 'элемент']
```
Слайд 5: Пример 4 — Практическое применение параметров и переменных
Задача: Показать практическое применение параметров и переменных в реальных сценариях.
```python
print("=== Практическое применение параметров и переменных ===")

print("\n--- Система управления банковским счетом ---")
class BankAccount:
    """Класс для управления банковским счетом"""
    
    # Переменная класса (общая для всех экземпляров)
    bank_name = "Python Bank"
    total_accounts = 0
    
    def __init__(self, account_holder, initial_balance=0, account_type="сберегательный"):
        """Инициализация счета с параметрами"""
        # Переменные экземпляра (уникальные для каждого счета)
        self.account_holder = account_holder
        self.balance = initial_balance
        self.account_type = account_type
        self.account_number = self._generate_account_number()
        self.transaction_history = []
        
        # Обновляем глобальную статистику
        BankAccount.total_accounts += 1
        
        self._log_transaction(f"Счет создан. Начальный баланс: {initial_balance}")
    
    def _generate_account_number(self):
        """Генерирует номер счета (локальная переменная)"""
        import random
        account_num = f"PB{random.randint(100000, 999999)}"
        return account_num
    
    def _log_transaction(self, description):
        """Логирует транзакцию (локальная операция)"""
        from datetime import datetime
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.transaction_history.append(f"{timestamp}: {description}")
    
    def deposit(self, amount, description="Пополнение"):
        """Пополнение счета с параметрами"""
        if amount <= 0:
            return False, "Сумма должна быть положительной"
        
        self.balance += amount
        self._log_transaction(f"{description}: +{amount}. Баланс: {self.balance}")
        return True, f"Счет пополнен на {amount}"
    
    def withdraw(self, amount, description="Снятие"):
        """Снятие средств со счета"""
        if amount <= 0:
            return False, "Сумма должна быть положительной"
        
        if amount > self.balance:
            return False, "Недостаточно средств"
        
        self.balance -= amount
        self._log_transaction(f"{description}: -{amount}. Баланс: {self.balance}")
        return True, f"Снято {amount}"
    
    def transfer(self, amount, target_account, description="Перевод"):
        """Перевод средств на другой счет"""
        success, message = self.withdraw(amount, f"{description} -> {target_account.account_holder}")
        if success:
            target_account.deposit(amount, f"{description} от {self.account_holder}")
        return success, message
    
    def get_statement(self, transaction_count=5):
        """Выписка по счету с параметром количества транзакций"""
        statement = f"""
Выписка по счету {self.account_number}
Владелец: {self.account_holder}
Тип счета: {self.account_type}
Текущий баланс: {self.balance}

Последние транзакции ({transaction_count} из {len(self.transaction_history)}):
"""
        recent_transactions = self.transaction_history[-transaction_count:]
        for transaction in recent_transactions:
            statement += f"  {transaction}\n"
        
        return statement
    
    @classmethod
    def get_bank_info(cls):
        """Метод класса для получения информации о банке"""
        return f"{cls.bank_name}. Всего счетов: {cls.total_accounts}"

# Создание и использование счетов
print("Создание банковских счетов:")
account1 = BankAccount("Анна Иванова", 1000, "расчетный")
account2 = BankAccount("Борис Петров", 5000)
account3 = BankAccount("Мария Сидорова", 200, "кредитный")

print(f"Счет 1: {account1.account_holder} - {account1.balance} руб.")
print(f"Счет 2: {account2.account_holder} - {account2.balance} руб.")
print(f"Счет 3: {account3.account_holder} - {account3.balance} руб.")

print(f"\nИнформация о банке: {BankAccount.get_bank_info()}")

print("\n--- Операции со счетами ---")
# Пополнение счета
success, message = account1.deposit(1500, "Зарплата")
print(f"Операция: {message}")

# Снятие средств
success, message = account2.withdraw(2000, "Покупка техники")
print(f"Операция: {message}")

# Перевод между счетами
success, message = account1.transfer(500, account3, "Помощь")
print(f"Операция: {message}")

print("\n--- Выписки по счетам ---")
print(account1.get_statement(3))
print(account2.get_statement(2))

print("\n--- Система конфигурации приложения ---")
def load_app_config(*config_files, **override_settings):
    """
    Загружает конфигурацию приложения с переменным количеством параметров
    """
    # Базовая конфигурация (локальная переменная)
    default_config = {
        "app_name": "MyApp",
        "version": "1.0.0",
        "debug": False,
        "database": {
            "host": "localhost",
            "port": 5432,
            "name": "app_db"
        },
        "server": {
            "host": "0.0.0.0",
            "port": 8000
        }
    }
    
    # Применяем переопределения (параметры **kwargs)
    for key, value in override_settings.items():
        keys = key.split('.')
        current_level = default_config
        
        # Проходим по вложенным ключам
        for k in keys[:-1]:
            if k in current_level and isinstance(current_level[k], dict):
                current_level = current_level[k]
            else:
                current_level[k] = {}
                current_level = current_level[k]
        
        # Устанавливаем значение
        current_level[keys[-1]] = value
    
    # Обрабатываем конфигурационные файлы (параметры *args)
    config_sources = []
    for config_file in config_files:
        config_sources.append(f"файл: {config_file}")
    
    default_config["_meta"] = {
        "config_sources": config_sources,
        "override_settings": list(override_settings.keys())
    }
    
    return default_config

# Различные способы загрузки конфигурации
print("Различные конфигурации:")

# Базовая конфигурация
basic_config = load_app_config()
print("1. Базовая конфигурация:")
print(f"   Приложение: {basic_config['app_name']} v{basic_config['version']}")
print(f"   Сервер: {basic_config['server']['host']}:{basic_config['server']['port']}")

# Конфигурация с переопределениями
custom_config = load_app_config(
    debug=True,
    server_port=9000,
    database_host="192.168.1.100"
)
print("\n2. Кастомная конфигурация:")
print(f"   Debug: {custom_config['debug']}")
print(f"   Порт сервера: {custom_config['server']['port']}")
print(f"   Хост БД: {custom_config['database']['host']}")

# Конфигурация с файлами и переопределениями
advanced_config = load_app_config(
    "config/prod.json", 
    "config/secrets.json",
    app_name="ProductionApp",
    database_name="prod_db",
    server_host="api.example.com"
)
print("\n3. Продвинутая конфигурация:")
print(f"   Приложение: {advanced_config['app_name']}")
print(f"   Сервер: {advanced_config['server']['host']}:{advanced_config['server']['port']}")
print(f"   База данных: {advanced_config['database']['name']} на {advanced_config['database']['host']}")
print(f"   Источники: {advanced_config['_meta']['config_sources']}")
print(f"   Переопределения: {advanced_config['_meta']['override_settings']}")
```
Вывод в консоли:
```bash
=== Практическое применение параметров и переменных ===

--- Система управления банковским счетом ---
Создание банковских счетов:
Счет 1: Анна Иванова - 1000 руб.
Счет 2: Борис Петров - 5000 руб.
Счет 3: Мария Сидорова - 200 руб.

Информация о банке: Python Bank. Всего счетов: 3

--- Операции со счетами ---
Операция: Счет пополнен на 1500
Операция: Снято 2000
Операция: Снято 500

--- Выписки по счетам ---

Выписка по счету PB123456
Владелец: Анна Иванова
Тип счета: расчетный
Текущий баланс: 2000

Последние транзакции (3 из 3):
  2024-12-19 14:30:25: Счет создан. Начальный баланс: 1000
  2024-12-19 14:30:25: Зарплата: +1500. Баланс: 2500
  2024-12-19 14:30:25: Перевод -> Мария Сидорова: -500. Баланс: 2000


Выписка по счету PB654321
Владелец: Борис Петров
Тип счета: сберегательный
Текущий баланс: 3000

Последние транзакции (2 из 2):
  2024-12-19 14:30:25: Счет создан. Начальный баланс: 5000
  2024-12-19 14:30:25: Покупка техники: -2000. Баланс: 3000


--- Система конфигурации приложения ---
Различные конфигурации:
1. Базовая конфигурация:
   Приложение: MyApp v1.0.0
   Сервер: 0.0.0.0:8000

2. Кастомная конфигурация:
   Debug: True
   Порт сервера: 9000
   Хост БД: 192.168.1.100

3. Продвинутая конфигурация:
   Приложение: ProductionApp
   Сервер: api.example.com:8000
   База данных: prod_db на localhost
   Источники: ['файл: config/prod.json', 'файл: config/secrets.json']
   Переопределения: ['app_name', 'database_name', 'server_host']
```
Слайд 6: Задания для практики
Задание 1: Система учета студентов
```python
# Создайте систему учета студентов:
# 1. Функция добавления студента с параметрами
# 2. Функция обновления оценок 
# 3. Функция расчета среднего балла
# 4. Используйте локальные и глобальные переменные
# Ваш код здесь
```
Задание 2: Калькулятор бюджета
```python
# Создайте калькулятор бюджета:
# 1. Функция добавления доходов/расходов
# 2. Функция расчета баланса
# 3. Функция генерации отчета
# 4. Используйте изменяемые и неизменяемые параметры
# Ваш код здесь
```
Задание 3: Система аутентификации
```python
# Создайте систему аутентификации:
# 1. Функция регистрации пользователя
# 2. Функция проверки пароля
# 3. Функция сброса пароля
# 4. Используйте параметры по умолчанию и именованные аргументы
# Ваш код здесь
```
Слайд 7: Ответы к заданиям
```python
# #Задание 1: Система учета студентов
# Глобальные переменные
students_db = []
total_students = 0

def add_student(name, age, group, initial_grades=None):
    """Добавляет студента в систему"""
    global total_students
    
    if initial_grades is None:
        initial_grades = []
    
    student = {
        "id": total_students + 1,
        "name": name,
        "age": age,
        "group": group,
        "grades": initial_grades,
        "average_grade": calculate_average(initial_grades) if initial_grades else 0
    }
    
    students_db.append(student)
    total_students += 1
    return student["id"]

def update_grades(student_id, new_grades):
    """Обновляет оценки студента"""
    for student in students_db:
        if student["id"] == student_id:
            student["grades"].extend(new_grades)
            student["average_grade"] = calculate_average(student["grades"])
            return True
    return False

def calculate_average(grades):
    """Рассчитывает средний балл (локальная функция)"""
    if not grades:
        return 0
    return sum(grades) / len(grades)

def get_student_report(student_id, include_details=True):
    """Генерирует отчет по студенту"""
    for student in students_db:
        if student["id"] == student_id:
            report = f"Студент: {student['name']} (Группа: {student['group']})"
            if include_details:
                report += f"\nВозраст: {student['age']}"
                report += f"\nОценки: {student['grades']}"
                report += f"\nСредний балл: {student['average_grade']:.2f}"
            return report
    return "Студент не найден"

# Тестирование системы студентов
print("=== СИСТЕМА УЧЕТА СТУДЕНТОВ ===")
student1 = add_student("Анна Иванова", 20, "ИТ-21", [4, 5, 4])
student2 = add_student("Борис Петров", 21, "ИТ-22", [3, 4, 5])

update_grades(student1, [5, 4])
update_grades(student2, [4, 3])

print(f"Всего студентов: {total_students}")
print(get_student_report(1))
print(get_student_report(2, include_details=False))

# #Задание 2: Калькулятор бюджета
class BudgetTracker:
    """Класс для отслеживания бюджета"""
    
    def __init__(self, initial_balance=0):
        self.balance = initial_balance
        self.transactions = []
        self.categories = {
            "доходы": ["зарплата", "премия", "инвестиции"],
            "расходы": ["еда", "транспорт", "развлечения", "жилье"]
        }
    
    def add_transaction(self, amount, category, description=""):
        """Добавляет транзакцию"""
        transaction = {
            "amount": amount,
            "category": category,
            "description": description,
            "type": "доход" if amount > 0 else "расход"
        }
        
        self.transactions.append(transaction)
        self.balance += amount
        
        return True
    
    def get_balance(self):
        """Возвращает текущий баланс"""
        return self.balance
    
    def get_category_summary(self, category_type="все"):
        """Возвращает сводку по категориям"""
        summary = {}
        
        for transaction in self.transactions:
            if category_type == "все" or transaction["type"] == category_type:
                cat = transaction["category"]
                summary[cat] = summary.get(cat, 0) + transaction["amount"]
        
        return summary
    
    def generate_report(self, period="месяц"):
        """Генерирует финансовый отчет"""
        income = sum(t["amount"] for t in self.transactions if t["amount"] > 0)
        expenses = sum(t["amount"] for t in self.transactions if t["amount"] < 0)
        
        report = f"""
ФИНАНСОВЫЙ ОТЧЕТ ({period.upper()})
================================
Общий доход: {income:.2f}
Общие расходы: {expenses:.2f}
Текущий баланс: {self.balance:.2f}

Доходы по категориям:
"""
        income_summary = self.get_category_summary("доход")
        for category, amount in income_summary.items():
            report += f"  {category}: {amount:.2f}\n"
        
        report += "\nРасходы по категориям:\n"
        expense_summary = self.get_category_summary("расход")
        for category, amount in expense_summary.items():
            report += f"  {category}: {amount:.2f}\n"
        
        return report

# Тестирование калькулятора бюджета
print("\n=== КАЛЬКУЛЯТОР БЮДЖЕТА ===")
budget = BudgetTracker(1000)
budget.add_transaction(50000, "зарплата", "Зарплата за месяц")
budget.add_transaction(-15000, "жилье", "Аренда квартиры")
budget.add_transaction(-8000, "еда", "Продукты")
budget.add_transaction(-5000, "развлечения", "Кино и рестораны")
budget.add_transaction(10000, "премия", "Квартальная премия")

print(budget.generate_report())

# #Задание 3: Система аутентификации
users_db = {}

def register_user(username, password, email=None, role="user", **additional_info):
    """Регистрирует нового пользователя"""
    if username in users_db:
        return False, "Пользователь уже существует"
    
    if len(password) < 6:
        return False, "Пароль должен быть не менее 6 символов"
    
    user_data = {
        "username": username,
        "password": hash_password(password),  # В реальности нужно хеширование
        "email": email,
        "role": role,
        "is_active": True,
        "created_at": "2024-12-19",
        **additional_info
    }
    
    users_db[username] = user_data
    return True, "Пользователь успешно зарегистрирован"

def authenticate_user(username, password, remember_me=False):
    """Аутентифицирует пользователя"""
    if username not in users_db:
        return False, "Пользователь не найден"
    
    user = users_db[username]
    
    if not user["is_active"]:
        return False, "Учетная запись заблокирована"
    
    # В реальности нужно сравнивать хеши
    if user["password"] == hash_password(password):
        session_data = {
            "username": username,
            "role": user["role"],
            "remember_me": remember_me
        }
        return True, session_data
    else:
        return False, "Неверный пароль"

def reset_password(username, new_password, confirm_password, security_question=None):
    """Сбрасывает пароль пользователя"""
    if username not in users_db:
        return False, "Пользователь не найден"
    
    if new_password != confirm_password:
        return False, "Пароли не совпадают"
    
    if len(new_password) < 6:
        return False, "Пароль должен быть не менее 6 символов"
    
    users_db[username]["password"] = hash_password(new_password)
    return True, "Пароль успешно изменен"

def hash_password(password):
    """Хеширует пароль (упрощенная версия)"""
    return f"hashed_{password}"  # В реальности использовать bcrypt или similar

def update_user_profile(username, **updates):
    """Обновляет профиль пользователя с именованными параметрами"""
    if username not in users_db:
        return False, "Пользователь не найден"
    
    user = users_db[username]
    
    for key, value in updates.items():
        if key in ["username", "password"]:  # Запрещенные поля
            continue
        user[key] = value
    
    return True, "Профиль обновлен"

# Тестирование системы аутентификации
print("\n=== СИСТЕМА АУТЕНТИФИКАЦИИ ===")
success, message = register_user(
    "anna_ivanova", 
    "securepassword123",
    email="anna@example.com",
    full_name="Анна Иванова",
    phone="+79123456789"
)
print(f"Регистрация: {message}")

success, session = authenticate_user("anna_ivanova", "securepassword123", remember_me=True)
print(f"Аутентификация: {'Успешно' if success else 'Ошибка'}")
if success:
    print(f"  Сессия: {session}")

success, message = reset_password("anna_ivanova", "newpassword456", "newpassword456")
print(f"Сброс пароля: {message}")

success, message = update_user_profile(
    "anna_ivanova",
    email="new_anna@example.com",
    phone="+79998887766"
)
print(f"Обновление профиля: {message}")
```
Ключевые моменты:
```
Локальные переменные — существуют только внутри функции
Глобальные переменные — доступны во всей программе, изменяются через global
Параметры — получают значения при вызове функции
Аргументы — фактические значения, передаваемые в функцию
Изменяемые параметры — списки, словари (изменяются в функции)
Неизменяемые параметры — числа, строки (не изменяются в функции)
Параметры по умолчанию — должны быть неизменяемыми
Именованные аргументы — улучшают читаемость кода
```
https://github.com/GO-HTML-CSS-JS-REACT-VITE-PG-SASS-VUE/Python_BU/edit/main/README.md#:~:text=2025%20год


